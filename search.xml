<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2022%2F01%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FPython%2FPython%E5%9F%BA%E7%A1%80%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[字典和集合]]></title>
    <url>%2F2022%2F01%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FPython%2FPython%E5%9F%BA%E7%A1%80%2F%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[列表和元组]]></title>
    <url>%2F2022%2F01%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FPython%2FPython%E5%9F%BA%E7%A1%80%2F%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[列表和元组 基础 列表和元组都是可以放置任意数据类型的有序容器。 C++和Java的容器需要数据类型相同，Python的列表和元组没有这个限制。 1234567l = [1, 2, 'hello', 'world'] # 列表中同时含有int和string类型的元素l[1, 2, 'hello', 'world']tup = ('jason', 22) # 元组中同时含有int和string类型的元素tup('jason', 22) 区别 列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。 如果想对元组修改需要新建元组。 123456789tup = (1, 2, 3, 4)new_tup = tup + (5, ) # 创建新的元组new_tup，并依次填充原元组的值# new _tup# (1, 2, 3, 4, 5)l = [1, 2, 3, 4]l.append(5) # 添加元素5到原列表的末尾# l# [1, 2, 3, 4, 5] 操作方式 索引 123456789101112l = [1, 2, 3, 4]l[3]#4l[-1]#4tup = (1, 2, 3, 4)tup[3]#4tup[-1]#4 切片 1234567l = [1, 2, 3, 4]l[1:3] # 返回列表中索引从1到2的子列表#[2, 3]tup = (1, 2, 3, 4)tup[1:3] # 返回元组中索引从1到2的子元组#(2, 3) 嵌套 123l = [[1, 2, 3], [4, 5]] # 列表的每一个元素也是一个列表tup = ((1, 2, 3), (4, 5, 6)) # 元组的每一个元素也是一个元组 转换 tuple和list可以互相转化 123456list((1, 2, 3))[1, 2, 3]tuple([1, 2, 3])(1, 2, 3) 常用函数 123456789101112131415161718192021l = [3, 2, 3, 7, 8, 1]l.count(3) #2l.index(7)#3l.reverse()#l#[1, 8, 7, 3, 2, 3]l.sort()#l#[1, 2, 3, 3, 7, 8]tup = (3, 2, 3, 7, 8, 1)tup.count(3)#2tup.index(7)#3list(reversed(tup))#[1, 8, 7, 3, 2, 3]sorted(tup)#[1, 2, 3, 3, 7, 8] count(item) 表示统计列表 / 元组中 item 出现的次数。 index(item) 表示返回列表 / 元组中 item 第一次出现的索引。 list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。 reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，reversed() 返回一个倒转后的迭代器（上文例子使用 list() 函数再将其转换为列表）；sorted() 返回排好序的新列表。 存储方式 性能 元组性能略优于列表。 源于Python在元组不大时会保留内存，在下一次分配相同大小元组时可以快速复用。 反复初始化一个相同元素的列表和元组分别所需的时间来说，元组要远优于列表。 如果是索引操作，差距不大。 使用场景 列表：存储的数据或数量是可变的 元组：存储的数据和数量不变就优先元组]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python  Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKR复盘]]></title>
    <url>%2F2021%2F12%2F31%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2FOKR%2FOKR%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[OKR复盘 OKR复盘是对OKR执行情况的客观评价，和OKR评估不同，复盘是为了知道在下一个周期更好的进行OKE OKR复盘四步法 OKR复盘一定要在会议上进行，大家面对面交流。 审视目标 为何当初要制定这样的目标？ 制定的目标达成了吗？ 如果未达成，现实和预期之间的差距在哪里？ 回顾过程 整个目标执行过程是如何执行的？ 大致分几个阶段去执行？ 每个阶段中发生了什么重要事件？ 分析得失 这次周期中，哪些方面你做得很好？ 为什么好？ 那些方面你做得不够好？ 为什么不好？ 总结规律 如果在再次做同类的事情，你会怎么去做？ 对我们后续工作有何指导？ 我们收获了哪些规律、原则、方法论？]]></content>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKR评估]]></title>
    <url>%2F2021%2F12%2F31%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2FOKR%2FOKR%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[OKR评估的最佳实践 标准简化 KR的评分标准： 1.0 分：不可能做到，但实际做到了。 0.7 分：希望能做到，实际也做到了。 0.3 分：肯定能做到，实际也做到了。 0 分：肯定能做到，但实际没做到。 流程简化 评分流程只有一个：自我评估 自己的承诺，由自己去兑现，OKR评分完全由自己来决定。 最好的 OKR 评估方式就是自评，而 OKR 评估也是自我管理的有效手段。]]></content>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKR执行]]></title>
    <url>%2F2021%2F12%2F30%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2FOKR%2FOKR%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[OKR高效执行心得 OKR需要设定一个固定的执行周期。 OKR指定完毕后，必须定期对内容、进度、信心指数进行更新和同步，最大化避免OKR更新不及时。 将OKR与日常工作任务关联起来，并通过任务去驱动OKR完成。 核心秘诀： 核心秘诀在于：将任务与 OKR 之间看成是一个“二级驱动”关系，即任务驱动 KR 的完成，进而促使 KR 驱动 O 的达成。 一个OKR执行方案 每天更新、每周回顾、每月优化、每季复盘 周会上每个人向团队同步一次OKR 每月一次OKR交流会，对OKR进行更新]]></content>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKR制定]]></title>
    <url>%2F2021%2F12%2F29%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2FOKR%2FOKR%E5%88%B6%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[O的制定 O是OKR中的What层面 核心原则 O要有实际价值，你要深度思考。 O要能激励人心，你要善于表达。 O要短期可实现，你要脚踏实地。 注意事项 O尽可能要以动词形式开头。 O用通俗易懂的语言表达。 一定不要写一些自认为“高大上”的词汇，除非大家理解上都可以达成一致。 O最好能附上一句目标描述。 建议为 O 增加一句话描述，就“为何我要写这个目标？”这一问题，来向大家讲解。 KR的制定 KR是针对OKR中How层面 核心原则 KR要支撑目标，需要与O直接关联。 KR用数据说话，需要通过数据去度量。 KR具备挑战性，难易度设置需要恰到好处。 那么，如何判断自己制定的 KR 难度恰到好处呢？此时，我想给你介绍关于 OKR 的一个重要工具——信心指数，它用于呈现自己对每项 KR 的信心程度，一般可通过分数形式表示。 比如，0/10 表示没有信心，5/10 表示有五分信心，10/10 表示有十分信心。在制定 KR 时，建议按照 5/10 的信心指数来制定，即“跳一跳就能够得着”的状态。 KR如何支撑O 引领性指标：也称为“Lead 指标”，它是可以通过主动行为努力做到的。 滞后性指标：也称为“Lag 指标”，它是通过达成“引领性指标”后产生的影响，而无法通过主动行为做到的。 ![[Pasted image 20220113114742.png]] 例子： O：回到标准好身材，塑造更好的自己 KR1：管住嘴，坚决不吃高热量食物 //引领性 KR2：迈开腿，每天坚持跑步 3 公里 //引领性 KR3：体重减少 30 斤（从 160 斤 减到 130 斤）//滞后性 注意事项 KR 需要通过努力才可能完成 KR 不是日常工作或行动计划 KR 必须要具备良好的实操性]]></content>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKR落地]]></title>
    <url>%2F2021%2F12%2F29%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2FOKR%2FOKR%E8%90%BD%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[OKR的价值 自底向上：与上级目标对齐，全员对齐向公司目标推进 自顶向下 ：沟通了解下级的岗位特征和个人成长诉求 落地OKR的先决条件 团队需要有内驱力的文化。内驱力文化的判断标准： 面对沟通时，是否公开透明？ 面对交付时，是否信守承诺？ 面对压力时，是否勇于挑战？ OKR来提升团队内驱力 推动OKR的角度 两个角度促进团队内驱力并推动OKR： 个人成长 团队贡献 有效推广的建议 一定不要强制性地去推广 OKR，更不要在大家概念不一致的情况下就大规模推广 OKR。 当大家对 OKR 理解不一致时，一定要请外部 OKR 专家到企业内部做 OKR 培训，才能快速建立共识。 要充分发挥你的领导力去影响身边的人，让高管们对 OKR 表示认同，让团队成员们尝到 OKR 的甜头，这才是我们作为领导者需要去做的事情。]]></content>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKR与KPI]]></title>
    <url>%2F2021%2F12%2F29%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2FOKR%2FOKR%E4%B8%8EKPI%2F</url>
    <content type="text"><![CDATA[OKR和KPI的差别主要不在形式，而在于底层理念和实施方法。 两者都可以用于目标管理。OKR偏重于目标制订，配合信息化工具可进一步延展，从战略拆解到目标初始制订，然后上下左右对齐，再到目标完成度和问题追踪，接着依据情况（包括执行状况、团队资源和市场情形等）进行调整，再开始新的循环。按照其理念，KR虽然有量化，但并不用于考核，而是给团队衡量目标的达成情况。 KPI的量化指标其实就是目标，但因为直接是数字，实践中容易让人忽略其背后企业和团队真正要达成的使命，而变成主要用来考核。在不强调使命愿景的时代，这是简单易用的绩效管理方法。 OKR强调目标制订和绩效考核分开，运用得好团队就可能制订出有挑战性的目标。KPI直接用来考核，团队可能就会保守。 OKR和KPI都可以达到信息透明、沟通顺畅的目的。它们更主要的差别是，前者强调上级的辅导职能（时髦词叫赋能），帮助团队达成目标，而不是完成不了受惩罚。后者则强调监控，胡萝卜和大棒齐飞 OKR 和 KPI 的差别 关注对象 OKR 关注的是目标是否达成，而 KPI 关注的却是结果是否完成。OKR 的目标野心勃勃和无限挑战，而 KPI 体现的是制定的指标是否可以达标。 核心原理 OKR：目标对齐 KPI： 指标分解 实操过程 OKR：鼓励员工自己指定目标，激发主观能动性 KPI：领导下发指标，难免讨价还价 用户行为 OKR： 促生主动挑战 KPI： 不得不被动地执行 利益关联 OKR：利益不直接相关 KPI：与利益挂钩 OKR可以取代KPI吗？ OKR是目标管理工具，而KPI是绩效管理工具。 目标包含绩效但不局限于绩效 OKR可以添加绩效内容，但不要与考核以及薪资或奖金挂钩。否则一旦利益失效，OKR的驱动能力就没有了。 OKR 的出现不是为了取代 KPI，而且未来很长一段时间内 KPI 都会一直存在 OKR与KPI结合 OKR关注的是结果和过程，更关注过程，而KPI关注的是结果。两者可以完美结合。]]></content>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKR是什么]]></title>
    <url>%2F2021%2F12%2F29%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2FOKR%2FOKR%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[OKR 是什么 OKR 是一款目标管理工具，它由 Objectives（目标）和 Key Results（关键结果）两部分组成。 OKR的作用 使方向更聚焦 使沟通更加透明 使激励更加有效 有效使用OKR 对于O 方向明确 目标对齐 时间限制 对于KR 有挑战性 容易度量 不是任务 数据结构 一个OKR包含多个O, O不要超过三个 一个O下有多个KR, 一个O下的KR也不要超过三个 OKR使用流程 指定OKR 执行OKR 评估OKR OKR 不是静态不变的，而是动态可变的]]></content>
      <tags>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F2021%2F12%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E5%B1%82%2F%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络层 IP协议 IP header IP路由选择 ABC类地址 A类：1.0.0.0 到126.0.0.0 最高位：0 每个网络1亿台主机 共126个 B类：128.0.0.0到191.255.255.255 最高位：10 每个网络2^16个主机 共2^14个地址 C类：192.0.0.0到223.255.255.255 最高位：110 每个网络254个主机 共2 ^21个地址 子网 好处: 缩小路由表 子网掩码 特殊的IP的例子 表中的头两项，网络号为0 ，如主机使用 BOOTP 协议确定本机 IP 地址时只能作为初始化过程中的源地址出现。 ARP协议 格式 ARP为IP地址到对应的硬件地址之间提供动态映射 ARP代理 路由器应答ARP 之后网络包通过路由器转发 gratuitous A R P 主机发送ARP查找自己的IP，确认没被占用 RARP协议 格式 格式和ARP基本相同，操作代码不同 用于无盘系统引导时获取IP地址 ICMP协议（） 格式 用于传递差错报文和其他要注意的信息 不会产生差错报文的情况 ICMP差错报文 目的地是广播或多播地址的IP数据报 链路层的广播数据包 不是IP的第一分片 源地址不是单个主机 查询报文 地址掩码 时间戳查询 差错报文 端口不可达 格式 网络不可达 IP路由 步骤 搜索匹配的主机地址 搜索匹配的网络地址 搜索默认表项 路由表 直接路由项： 包含目的的iP地址和链路层地址 间接路由项: IP地址指明的是最终的目的地， 但是链路层地址指明的是网关 默认路由：若表中没有对应路由项，发往默认路由 ICMP重定向 ICMP路由发现 动态选路 当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层]]></title>
    <url>%2F2021%2F12%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E5%BA%94%E7%94%A8%E5%B1%82%2F%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[应用层 Ping 基于网络层的ICMP 格式 代码为0 类型为0/8 UNIX中标识符为进程ID -r 可提供IP路由路径 HTTP协议(WIP) HTTP2 帧 - Frame 帧是最小传输单位，二进制传输代替明文传输 帧结构 示意图 Length: 整个长度 24位 Type: 帧语义 8位 Flags: 布尔标识 8位 R: 保留的比特位 1位 Stream Identifier: 流控制用 31位 客户端奇数 服务端偶数 Payload: 内容主体 帧类型 HEADER 打开流 DATA 装填主体信息 PRIORITY 指定发送者建议的流优先级 RST_STREAM 用来取消流，或者表示发生错误 SETTINGS 设置连接参数 PING 判断连接是否可用 GOAWAY 发起关闭连接请求 WINDOW_UPDATE 更新窗口，用于流量控制，只限制DATA帧 CONTINUATION 用于首部压缩时继续传输首部序列 流 - Stream 特性 单个h2连接可以包含多个并发流 流可以由任一方关闭 接收方会把同一个流上的帧重新组装成完整的报文。 流的状态 状态转移图 IDLE reserved open half-closed closed 流的标识符 0x0 保留为连接控制消息 客户端发起流为奇数 服务端发起流为偶数 新的流ID必须大于所有已使用过的数字 流的优先级 用来调节多个流见的资源分配 流依赖 依赖表示优先将资源分配给父级流 每个流可以显式地依赖另一个流 父级流按优先级权重分配资源 独占流 标识其为父级流下唯一的依赖流 优先级调整 父级重置优先级，依赖流会随父级流移动 默认优先级 所有流都默认依赖于0x0 Server-Push 流量控制 流量控制作用域单个流或整个连接 初始值65535字节 流量控制是有方向的，由接收者控制 流量控制不能被禁用 只有DATA帧会受流量控制 首部压缩（HPACK） 索引表 静态索引 对于一些常用字段用静态索引值代替 动态索引 每个连接一份的索引，由双方共同维护。 FIOF队列，索引值从静态索引后边开始 编码类型表示 整数编码 varint 编码 字符编码 哈夫曼编码 FTP协议 SMTP协议 NTP（Network Time Protocol）协议]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据链路层]]></title>
    <url>%2F2021%2F12%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[数据链路层 链路层的三个目的 发送接收IP数据报 2.发送ARP和接收ARP应答 3.发送RARP请求和接收RARP应答 以太网和IEEE 802 封装格式 最小帧长 46字节 SLIP（穿行线路IP） 帧格式 1 ) I P 数据报以一个称作 E N D( 0 x c 0 ) 的 特 殊 字 符 结 束 。 同 时 ， 为 了 防 止 数 据 报 到 来 之 前 的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个 E N D字 符 ( 如 果 有 线 路噪声，那么 E N D 字 符 将 结 束 这 份 错 误 的 报 文 。 这 样 当 前 的 报 文 得 以 正 确 地 传 输 ， 而 前 一 个 错误报文交给上层后，会发现其内容毫无意义而被丢弃)。 2 ) 如果 I P 报 文 中 某 个 字 符 为 E N D ， 那 么 就 要 连 续 传 输 两 个 字 节 0 x d b 和 0 x d c 来 取 代 它 。 0 x d b 这个特殊字符被称作 S L I P 的 E S C 字符，但是它的值与 A S C I I码的 E S C 字符( 0 x 1 b )不同。 3) 如果 I P 报 文 中 某 个 字 符 为 S L I P 的 E S C 字 符 ， 那 么 就 要 连 续 传 输 两 个 字 节 0 x d b 和 0 x d d 来 取代它。 缺陷 每一端必须知道对方的地址 2.数据帧中没有类型字段，一条线路使用SLIP后，就都用SLIP 没有校验和 PPP（点对点协议） 帧格式 每一帧都以标志字符 0 x 7 e 开始和结束。紧接着是一个地址字节，值始终是 0 x ff ，然后是一 个值为 0 x 0 3 的控制字节。 优点 支持多种协议 每一帧都有CRC 双方IP地址可动态协商 对TCP和IP报文首部压缩 链路控制协议可以对多个数据链路选项进行设置 缺点 每一帧首部多3帧 回环接口 过程图 最大传输单元 MTU 以太网和802.3对数据帧的长度都有一个限制，其最大值分别是 1500和1492 路径MTU]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层]]></title>
    <url>%2F2021%2F12%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E4%BC%A0%E8%BE%93%E5%B1%82%2F%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[传输层 TCP 协议 Header 大小： 20字节+n(可选字段) 连接建立和终止 Time_Wait MSL(Maximum Segment Lifetime) 默认值为2 min 常用1 min或30 s 数据流 delayed ack Nagle 算法 滑动窗口 窗口大小 = min(拥塞窗口， 接收窗口) Push标志 拥塞 紧急标志 超时和重传 超时指数退避 abort interval （放弃重传） 9 min RTO ( Retransmission TimeOut） β是推荐为2的离散因子 R即RTT 定时器 Retransmission Timer RTO ( Retransmission TimeOut） β是推荐为2的离散因子 R即RTT PersistTimer 用于零窗口探活 60 s 糊涂窗口综合症 问题：频繁的小窗口交互，而不是满长度报文 解决： 接收方： 接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口(可以为0)， 除非窗口可以增加一个报文段大小(也就是将要接收的 M S S ) 或 者 可 以 增 加 接 收 方 缓 存 空 间 的一半，不论实际有多少。 发送方： 避免出现糊涂窗口综合症的措施是只有以下条件之一满足时才发送数据: ( a )可 以 发 送 一 个 满 长 度 的 报 文 段 ; ( b ) 可 以 发 送 至 少 是 接 收 方 通 告 窗 口 大 小 一 半 的 报 文 段 ; ( c ) 可以 发送任何数据并且不希望接收 A C K( 也 就 是 说 ， 我 们 没 有 还 未 被 确 认 的 数 据 ) 或 者 该 连 接 上 不能使用 N a g l e 算法 Keeplive Timer 四种情况 可能会发生 4 种不同的情况:对端仍然运行正常、对端已经崩溃、对端已经崩溃并重新启动以及对端当前无 法到达 Time_Wait Timer 2 MSL 性能优化 路径MTU发现 长肥管道 窗口扩大 时间戳 UDP 校验和 伪首部 和ARP交互 防止 ARP洪泛 R F C 要求实现中必须防止这种类型的 A R P 洪泛( A R P f l o o d i n g ， 即以高速率重复发送到同一个 I P 地址的 A R P 请求)。 建 议 最 高 速 率 是 每 秒 一 次 。 而 这 里 却在4.3 ms内发出了6个ARP请求。 数据包截断 由于 I P 能 够 发 送 或 接 收 特 定 长 度 的 数 据 报 并 不 意 味 着 接 收 应 用 程 序 可 以 读 取 该 长 度 的 数 据。因此， U D P 编 程 接 口 允 许 应 用 程 序 指 定 每 次 返 回 的 最 大 字 节 数 UDP输入队列 每个端口一个输入队列 输入队列满后，内核会丢弃包。 多个接受者 目标IP和端口号有多个端点(可理解为进程) 时 多播\广播地址——每个端点一份数据 单播地址 ——一个端点 具体是哪个取决于系统实现]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式事务]]></title>
    <url>%2F2021%2F12%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%2F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%2F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[分布式事务 CAP CAP 一致性 代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。 可用性 可靠性 平均无故障时间（Mean Time Between Failure，MTBF） 可维护性 平均修复时间（Mean Time To Repair，MTTR） A= MTBF/(MTBF+MTTR) 分区容忍性 网络分区后仍能正常服务 CAP不可兼得 如果放弃分区容忍性（CA without P），意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的，这不是你想不想的问题，而是只要用到网络来共享数据，分区现象就会始终存在。在现实中，最容易找到放弃分区容忍性的例子便是传统的关系数据库集群，这样的集群虽然依然采用由网络连接的多个节点来协同工作，但数据却不是通过网络来实现共享的。以 Oracle 的 RAC 集群为例，它的每一个节点均有自己独立的 SGA、重做日志、回滚日志等部件，但各个节点是通过共享存储中的同一份数据文件和控制文件来获取数据的，通过共享磁盘的方式来避免出现网络分区。因而 Oracle RAC 虽然也是由多个实例组成的数据库，但它并不能称作是分布式数据库。 如果放弃可用性（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中讨论的一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。在现实中，选择放弃可用性的 CP 系统情况一般用于对数据质量要求很高的场合中，除了 DTP 模型的分布式数据库事务外，著名的 HBase 也是属于 CP 系统，以 HBase 集群为例，假如某个 RegionServer 宕机了，这个 RegionServer 持有的所有键值范围都将离线，直到数据恢复过程完成为止，这个过程要消耗的时间是无法预先估计的。 如果放弃一致性（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，你再不想要也无法丢弃；而 A 通常是建设分布式的目的，如果可用性随着节点数量增加反而降低的话，很多分布式系统可能就失去了存在的价值，除非银行、证券这些涉及金钱交易的服务，宁可中断也不能出错，否则多数系统是不能容忍节点越多可用性反而越低的。目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，以 Redis 集群为例，如果某个 Redis 节点出现网络分区，那仍不妨碍各个节点以自己本地存储的数据对外提供缓存服务，但这时有可能出现请求分配到不同节点时返回给客户端的是不一致的数据。 分布式环境下，一般是放弃一致性，选择AP系统，追求最终一致性。 可靠事件队列 BASE ACID的替代 基本可用性（Basically Available） 柔性事务（Soft State） 最终一致性（Eventually Consistent） 最大努力交付 通过不断重试来使得关联业务全部完成，达到最终一致 TCC事务 相较于BASE提供了隔离性 三个阶段 Try 尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。 Confirm 确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。 Cancel 取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。 缺点 对业务代码侵入性强 SAGA事务 把一个大事务分解为可以交错运行的一系列子事务集合 过程 大事务拆分若干个小事务，将整个分布式事务 T 分解为 n 个子事务，命名为 T1，T2，…，Ti，…，Tn。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交 Ti等价。 为每一个子事务设计对应的补偿动作，命名为 C1，C2，…，Ci，…，Cn。Ti与 Ci必须满足以下条件： Ti与 Ci都具备幂等性。 Ti与 Ci满足交换律（Commutative），即先执行 Ti还是先执行 Ci，其效果都是一样的。 Ci必须能成功提交，即不考虑 Ci本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。 恢复策略 正向恢复 如果 Ti事务提交失败，则一直对 Ti进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景，譬如在别人的银行账号中扣了款，就一定要给别人发货。正向恢复的执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn。 反向恢复 如果 Ti事务提交失败，则一直执行 Ci对 Ti进行补偿，直至成功为止（最大努力交付）。这里要求 Ci必须（在持续重试后）执行成功。反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。 底线是避免脏写，在此之上，可能要因地制宜选择分布式事务方案]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务处理]]></title>
    <url>%2F2021%2F12%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%2F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务处理 ACID 原子性（Atomic） 在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。 隔离性（Isolation） 在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。 持久性（Durability） 事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。 本地事务 分类：单业务单数据源 原子性和持久性 CommitLogging 允许no-force，不允许steal Write-Ahead Logging(WAL) 允许no-force和steal 增加了Undo Log支持提前写入数据的回滚和故障恢复 崩溃恢复 分析阶段（Analysis） 分析阶段（Analysis）：该阶段从最后一次检查点（Checkpoint，可理解为在这个点之前所有应该持久化的变动都已安全落盘）开始扫描日志，找出所有没有 End Record 的事务，组成待恢复的事务集合，这个集合至少会包括 Transaction Table 和 Dirty Page Table 两个组成部分。 重做阶段（Redo） 重做阶段（Redo）：该阶段依据分析阶段中产生的待恢复的事务集合来重演历史（Repeat History），具体操作为：找出所有包含 Commit Record 的日志，将这些日志修改的数据写入磁盘，写入完成后在日志中增加一条 End Record，然后移除出待恢复事务集合。 回滚阶段（Undo） 回滚阶段（Undo）：该阶段处理经过分析、重做阶段后剩余的恢复事务集合，此时剩下的都是需要回滚的事务，它们被称为 Loser，根据 Undo Log 中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些 Loser 事务的目的。 划分方式 FORCE FORCE：当事务提交后，要求变动数据必须同时完成写入则称为 FORCE，如果不强制变动数据必须同时完成写入则称为 NO-FORCE。现实中绝大多数数据库采用的都是 NO-FORCE 策略，因为只要有了日志，变动数据随时可以持久化，从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。 STEAL STEAL：在事务提交前，允许变动数据提前写入则称为 STEAL，不允许则称为 NO-STEAL。从优化磁盘 I/O 性能考虑，允许数据提前写入，有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。 隔离性 隔离手段 写锁 读锁 范围锁 隔离级别 可串行化 可重复读 问题：幻读 加读写锁一直持有，但无范围锁 读已提交 问题：不可重复读 加读写锁，写锁一直持有，读锁读后即释放 读未提交 问题：脏读 加写锁一直持有，但无读锁 MVCC MVCC 是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的 增加CREATE_VERSION 和 DELETE_VERSION 一读一写场景无需读锁 加锁策略 乐观锁 竞争激烈情况下，乐观锁反而可能更慢 悲观锁 隔离级别 可重复读 总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录 读已提交 总是取最新的版本即可 全局事务 分类：单业务多数据源 两阶段提交（2PC） 角色划分 协调者 全局一个 参与者 单个资源的管理者 准备阶段 准备阶段：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。 提交阶段 提交阶段：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载操作。 缺点 单点问题 协调者单点 性能问题 两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record），整个过程将持续到参与者集群中最慢的那一个处理操作结束为止，这决定了两段式提交的性能通常都较差。 两次远程调用，三次持久化 一致性风险 当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。宕机恢复能力这一点不必多谈，1985 年 Fischer、Lynch、Paterson 提出了“FLP 不可能原理”，证明了如果宕机最后不能恢复，那就不存在任何一种分布式协议可以正确地达成一致性结果。该原理在分布式中是与“CAP 不可兼得原理“齐名的理论。而网络稳定性带来的一致性风险是指：尽管提交阶段时间很短，但这仍是一段明确存在的危险期，如果协调者在发出准备指令后，根据收到各个参与者发回的信息确定事务状态是可以提交的，协调者会先持久化事务状态，并提交自己的事务，如果这时候网络忽然被断开，无法再通过网络向所有参与者发出 Commit 指令的话，就会导致部分数据（协调者的）已提交，但部分数据（参与者的）既未提交，也没有办法回滚，产生了数据不一致的问题。 三阶段提交（3PC） CanCommit 新增阶段 协调者让各个资源管理者评估事务是否可以完成 PreCommit 原准备阶段 DoCommit 原提交阶段 增加了一轮协调，降低了失败概率 优势 单点问题有改善 回滚性能有改善 共享事务 分类：多业务单数据源 不易扩展，没有卵用 分布式事务 分类：多业务多数据源]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构安全]]></title>
    <url>%2F2021%2F12%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%2F%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%2F%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[架构安全 认证 “你是谁” 授权 RABC 天然满足最小特权原则 垂直权限 即功能权限 RABC即可解决 水平权限 出现在同一个角色上的不同用户间的权限隔离 如A用功能A里的A数据，B用功能A里的B数据 以用户级别进行数据的行级别、列级别授权 OAuth2 向第三方应用授权 授权方式 授权码模式 隐式授权模式 密码模式 客户端模式 凭证 Cookie-Session JWT 防篡改不防泄漏 保密 保密手段 摘要代替明文 加盐值再hash 慢hash 通过设置执行时间让暴力穷举无效 动态盐值 动态令牌 HTTPS 物理设备证书 传输 TLS 验证]]></content>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[压缩算法]]></title>
    <url>%2F2021%2F12%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%AE%97%E6%B3%95%2F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[压缩算法 压缩库 数据压缩分类 非适应/自适应（Non-adaptive/ adaptive） 非适应算法不需要针对特殊数据流进行训练以提升效率，而适应算法则需要有训练过程。 松散/非松散（Lossy/Lossless） 松散算法不保障对原始数据压缩后的结果唯一，而非松散算法对同样原始数据的压缩结果唯一。 对称/非对称（Symmetric/Asymmetric） 对称算法对数据的压缩、解压缩使用相同的算法实现，通过执行不同的代码路径切换压缩解压缩过程；非对称算法则在数据压缩、解压缩过程分别使用不同的算法。 具体算法 字典压缩 差分压缩 游程编码（RLE） 前缀压缩 VarInt编码 AutoEncoder BitMap]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火算法]]></title>
    <url>%2F2021%2F12%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%AE%97%E6%B3%95%2F%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%2F%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模拟退火算法 白话解释：首先随机选择一个解作为开始，接下来产生一个随机扰动，如果找到比上一个解更接近最优解的解，那么就直接接受这个解。而如果找到的解离得更远了，没关系，以一定的概率接受。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最优化算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拜占庭容错]]></title>
    <url>%2F2021%2F12%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%2F%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%2F</url>
    <content type="text"><![CDATA[拜占庭容错 pbft Zyzzyva pow BTC ETH 采用的算法 1、POW算法简介 POW（Proof of Work），即工作量证明，也称挖矿。工作量证明通过计算来猜测一个数值(nonce)，使得拼凑上交易数据后内容的Hash值满足规定的上限。由于Hash难题在目前计算模型下需要大量的计算，可以保证在一段时间内，系统中只能出现少数合法提案。如果能够提出合法提案，证明提案者确实已经付出了一定的工作量。 哈希现金是一种工作量证明机制，是Adam Back在1997年发明的，用于抵抗邮件的拒绝服务及垃圾邮件网关滥用。 2、POW算法原理 工作量证明的主要特征是客户端需要做一定难度的工作得出一个结果，验证方却很容易通过结果来检查出客户端是不是做了相应的工作。工作量证明方案的一个核心特征是不对称性：工作对于请求方是适中的，对于验证方则是易于验证的。 给定一个基本字符串，在基本字符串后面添加一个叫做nonce的整数值，对变更后（添加nonce)的字符串进行SHA256哈希运算，如果得到的哈希结果（以16进制的形式表示）是以某个字符串（如&quot;0000&quot;）开头的，则验证通过。为了达到工作量证明的目标，需要不停的递增nonce值，对得到的新字符串进行SHA256哈希运算。 由于给定的基本字符串在不同的场合并不确定，对于不同的基本字符串和nonce的组合，要使用SHA256计算得到某个字符串开头Hash值的计算次数并不确定，但会是一个符合统计学规律的概率事件。 按照规则，预期大概要进行2^16 次尝试（哈希值的伪随机特性可以做概率估算），才能得到4个前导0的哈希散列。 pos 1、POS算法简介 POS（Proof of Stake），即权益证明，是POW的一种升级共识机制，根据每个节点所占代币的比例和时间，等比例的降低挖矿难度，从而加快找随机数的速度。 鉴于POW的缺陷，2012年Sunny King提出了POS，并基于POW和POS的混合机制发布了点点币PPCoin。 2、POS算法原理 POS原理的核心概念为币龄，即持有货币的时间。例如有10个币、持有90天，即拥有900币天的币龄。 使用币即意味着币龄的销毁。 在POS中有一种特殊的交易称为利息币，即持有人可以消耗币龄获得利息，同时获得为网络产生区块以及POS造币的优先权。 POW通过算力证明自己有资格写区块链，而PoS通过拥有的币龄来证明自己有资格写区块链。 3、POS算法的优缺点 POS算法的优点： A、不消耗大量算力挖矿，节省能耗。 B、在一定程度上缩短了共识达成的时间 C、防作弊。 POS算法的缺点： A、本质仍然需要挖矿，未解决商业应用的痛点 B、极端的情况下会带来中心化的结果 dpos 1、DPOS算法简介 DPOS（Delegated Proof of Stake），即股份授权证明算法，是在POW及POS基础上诞生的一种新型共识算法，2014年4月由Bitshares的首席开发者Dan Larimer (现为EOS CTO)提出并应用。DPOS既能解决POW在挖矿过程中产生的DPOS大量能源过耗的问题，也能避免POS权益分配下可能产生的信任天平偏颇的问题。 DPOS是由被社区选举的可信账户（超级节点，比如得票数前101位可以成为）来创建区块。比如选出101个超级节点，即101个矿池，超级节点之间的权利是完全相等的。普通的持币者可以随时通过投票更换超级节点（矿池），DPOS的去中心化不是每个持币者就有直接的股份权益，而是需要间接的投票权力，来保证被推选出来的超级节点不作恶，同时也可以自己拉选票成为超级节点或者备用超级节点。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分布式共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非拜占庭场景]]></title>
    <url>%2F2021%2F12%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%2F%E9%9D%9E%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[非拜占庭场景 paxos raft ZAB QJM]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分布式共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编译Warning汇总]]></title>
    <url>%2F2021%2F08%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2FC-%E7%BC%96%E8%AF%91Warning%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[按条目记录平时遇到的编译Error和Warning，避免重复排查 -Wpessimizing-move -Wredundant-move 解决： 删除std::move调用。 https://developers.redhat.com/blog/2019/04/12/understanding-when-not-to-stdmove-in-c]]></content>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google技术写作课——笔记]]></title>
    <url>%2F2021%2F07%2F22%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2FGoogle%E6%8A%80%E6%9C%AF%E5%86%99%E4%BD%9C%E8%AF%BE%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文是阅读学习google 英文技术写作 课程的笔记。 Courses One Introduction Learning objectives 前后一致的使用术语（包括缩写形式） 能够区分并消除代词的歧义 能够识别被动语态和主动语态，并能将被动语态转换为主动语态 掌握让句子更加简短、表达更加清晰更加吸引人的几种方法。 理解项目符号列表和数字符号列表的区别，能够正确的选用 段落和文档结构上：能在文档开头说明关键点，学会写有效的段首句，每个段落只讲一个主题。 能够明白目标读者已经知道的和你想让他们知道的，避免知识诅咒 避免习语（黑话） 能够将大的话题拆成合适的段落分别说明 正确的使用标点符号 使用Markdown Word Define new or unfamiliar terms 对于目标读者不熟悉的术语： 如果是已经有的术语，给一个好的已有的解释的连接（不要重复造轮子） 如果是你的文档的新术语，给一个清晰的定义。如果很多，给一个术语表 Use tems consistently 前后一致的使用术语，如：不要前边用 Protocol Buffers 后边用 protobufs。 若要使用缩写应当在术语第一次出现时在括号内说明，之后保持一致。如： Protocol Buffers (or protobufs for short) Use acronyms properly 术语第一次出现时要写全称，但之后可以通过使用所写来简化段落。 但是不要出现全称和缩写再次混用。 Use the acronym or the full term 太多的简写读者的脑子里可能要维护一个大的map来存对应关系，因此对于一些术语我们可能不要用简写会好一点。 对于只出现几次的术语不需要定义简写 对同时满足一下情况的术语定义简写 简写要比全称短的多 简写会在文档里出现很多次（读者熟悉的缩写可以尽情使用，如HTML） Disambiguate pronouns 代词很容易出现歧义，在恰当时候使用，尽量重复使用名词来表达。 永远不要在你引入一个名词前就使用代词指代 将代词和它指代的名词放一起（5个单词举例以内——英文标准） 如果在代词和指定代的名词之间有第二个名词，建议直接重复使用名词。= This and That 对于this和 that有几种技巧能够消除歧义 直接将 this和that换成对应的名词 在this 和 that 后边紧跟一个名词 Active voice Distinguish active voice from passive voice in simple sentences Prefer active voice to passive voice 被动时态往往省略了行为人，读者需要猜测行为人 主动时态较被动时态要比被动时态直接 主动时态的句子一般比被动时态短 Clear sentences Choose strong verbs 技术写作中，动词（verb）是句子的最重要组成部分。动词用的好，句子就无需额外解释。 选用清晰、有力和具体的动词可以有效地吸引和教育读者。 Weak Verb Strong Verb The error occurs when clicking the Submit button. Clicking the Submit button triggers the error. This error message happens when… The system generates this error message when… We are very careful to ensure… We carefully ensure… 其他的句子问题： 句子中没有清晰的主语 被动时态句子 hava a xxx 或者 be xxx Reduce there is/there are 以There is 或者There are开头的句子开很千篇一律。 直接用具体的主语来代替。 用 you来代替 Minimize certain adjectives and adverbs 形容词和副词对于科技写作来说没有足够的客观性和精确性。 在科技写作中应当使用真实精确的数据替代这些。 Short sentences Focus each sentence on a single idea 每个句子应当只表达一个意思 Convert some long sentences to lists 当出现用到连词或者分号的长句子时，换用列表的形式更加直观。 Eliminate or reduce extraneous words 句子中往往会有很多废话（高级表达 ，要精简这样的词语。 Wordy Concise at this point in time now determine the location of find is able to can Reduce subordinate clauses 子句或者从句会打破一个句子只表达一个意思的原则，导致读者理解困难，所以要尽量减少脱离主句核心意思的从句。 Distinguish that from which that 和 which 从句分别何时使用，有一个经验法则： which 从句去掉后不影响主句的意思 that 去掉后主句的意思不完整 Python is an interpreted language, which means the processor runs the program directly. FORTRAN is perfect for mathematical calculations that don’t involve linear algebra. 或者：尝试读句子，如果发现读到从句时需要停顿，那适合使用 which；否则使用 that。 List and table Choose the correct type of list 项目符号列表 无序的项目（换顺序不影响表达的意思） 数字序号列表 有序的项目 嵌入列表（在句子中罗列） 一般不是一种好的方式，应该用其他两种代替 Keep list items parallel 好的列表在以下几个方面应该保持一致： 语法 逻辑类型 大小写 标点符号 Start numbered list items with imperative verbs 在有序列表中，使用祈使句来表达流程。 Punctuate items appropriately 只在列表项是一个句子时，首字母大写和使用标点符号。其他情况下不使用。 Create useful tables 加入表格应当遵守以下原则： 每一列都要有一个明确的列头。 避免一个单元格内有太多文本(不要超过两句话)。 表格内的数据应当尽量保持关联，不要将毫不相关的东西放到一起。 Introduce each list and table 在引入表格和列标签都用一句话介绍一下。 Paragraphs Write a great opening sentence 每段的第一句是最重要的。许多比较忙的读者可能只会跳着读每段的第一句 Focus each paragraph on a single topic 每段都应该只有一个主题思想。当段落内有描述其他段的内容时，应该直接删掉。 Dont’t make paragraphs too long or too short 太长的段落会看起来很吓人，容易被读者跳过。（3-5句为佳，超过7句就太长了） 相应的，也不要让段落太短了，这样会使读者聚德你的文章组织不靠谱。 Anser what, why, and how 一个段落应该能回答以下三个问题： What are you trying to tell your reader? Why is it important for the reader to know this? How should the reader use this knowledge? Alternatively, how should the reader know your point to be true? Audience good documentation = knowledge and skills your audience needs to do a task − your audience’s current knowledge and skills Define your audience 严肃的文档可能会做很多的调研工作来确定读者，但也有一些比较简单的方法： 确认读者角色 明确角色的knowledge base（相同角色的读者会有差不多的knowledge base） 找出对同一个角色的读者的差异 对于同一个角色的读者有些内容是有些人知道，有些人不知道的。如C++工程师可能比Python工程师更加熟悉操作系统 确认角色的日常经验 软件工程师虽然一般学过微积分，但可能他们长时间不用，已经不会了，但可能对项目中的知识很了解。 Sample audience analysis 这是一个例子： The target audience for Project Zylmon falls into the following roles: software engineers technical product managers The target audience has the following proximity to the knowledge: My target audience already knows the Zyljeune APIs, which are somewhat similar to the Zylmon APIs. My target audience knows C++, but has not typically built C++ programs in the new Winged Victory development environment. My target audience took linear algebra in university, but many members of the team need a refresher on matrix multiplication. Determine what your audience needs to learn 用一个列表写下所有你读者读完你的文档需要能够学到的东西。有时你列这些目标会有一个顺序，需要先知道xxx再学到jjj,也要列出来。如果你是在写一个份设计规约，最好关注在让你的读者了解整个设计，而不是专精于某个细节。 Fit documentation to your audience 你必须要用读者感兴趣的语言说明问题，而不是你自己习惯的表的方式。 Vovabulary and concepts 用读者能听懂的单词和概念。当目标读者比较广泛的时候，必须要进行更多的名词和概念的解释。 Curse of knowledge 一个专家可能意识不到读者不知道他已经知道的知识 Simple words 尽量使用简单的单词，避免给非母语者造成困扰。 Cultural neutrality and idioms 尽量保持文章文化中立。不要使用一些特定文化内的俗语或者缩写。 Documents State your document’s scope 一篇好的文档在开头就应当描述清楚文档的内容。更好的文档还会指明不会不包括的内容（可能是读者预期能够独到的）。 State your audience 在开头明确目标读者，除了明确目标读者的角色，可能还需要明确读者需要具备的知识或经验。在一些文档中，可能还要明确需要提前阅读的其他文档。 Establish your key points up front 在第一段就表明观点。保证你的第一段能够让读者理解。 在第一页多下功夫，以能够吸引读者读到后边去。 长文档一定要写一个执行摘要（TL; DR）；同时TLDR应当简短有趣，否则会吓退读者。 Write for your audience Define the audience Who is your target audience? What do your readers already know before they read your document? What should your readers know or be able to do after they read your document? Organize for your audience’s needs 以清晰的方式组织文档，以便读者能够有效地掌握或学习。 Break your topic into sections 有结构的切分你的话题 组织文章就像把罐子填满： 先以大的主题内容搭建文章框架。 再列举每一部分的主题。 最后用细节填充。 Courses Two Introduction Learning objectives 写草稿的方法和修正的方法。 几种检测文章中错误的方法 大型文档的组织方法 介绍文章内容和前置知识 清楚的数字说明 正确使用技术插图 创建有用的、准确的、简洁的、清晰的、可重用的、注释良好的示例代码 区分不同的文档类型 描述任何事情 为初学者读者提供指南 Self-editing Adopt a style guide 在组内或公司内使用统一的文档风格 style-guide highlights。 Think like your audience 在读者角度看你的文章，保证你的文档是清晰的，同时有必要的名词解释。 Read it out loud 通过大声读出来可以找出文章中不自然的地方。同时，读出来也能帮助你判断你的行文风格是否符合文档的场景，如： getting started guide 需要偏口语化，轻松一些； 开发者文档追求严谨，准确。 Come back to it later 在写完草稿后先放到一边，过1-2小时后再来看一遍，往往会注意到新的东西。 Change the context 将你的文档复制，用更换字体字号以及颜色等来进行修改。（类似于改作文时用红笔） Find a peer editor 和代码一样，文档也需要review。注意reviewer应当熟悉你们规定的文档风格。 Organizing large documents When to write large documents 不同的读者的阅读喜好不一样， 因此要区分开来。有以下几个指导原则： 操作指南、介绍性概述和概念介绍这类的文档，简短最好。 深入的教程、最佳实践指南和命令行参考页面这类的文档，可以长一点。 优秀的长文档应当能够引导读者一部分一部分的读完整个教程。 许多长文档的编写目的就不是被一次读完的，可能是供需要时查询。 Organize a document Outline a document 在写文章前要现有一份结构化的，高层次的大纲。一份好的大纲有以下指导原则： 在告诉读者要做什么之前，先告诉他们为什么 大纲里的一项涉及的范围应当限制在描述一个概念或执行一个具体的动作的范围内。 把你的大纲组织曾最能够方便读者理解的形式。 介绍概念和实践交替介绍，帮助读者最有影响的时候实践。 在开始草稿前应该把大纲分享给你的伙伴。 Introduce a document 如果读者不能知道你的文档是不是和他关心的主题有关，他可能就不会读了，所以文档中应该包含以下几个部分： What the document covers What prior knowledge you expect readers to have. What the document doesn’t cover Add navigation 添加导航栏，导航栏应该包括： 介绍和总结段 逻辑清晰的主题 能帮助读者理解主题的主副标题 能够显示当前位置的菜单栏 链接到相关的资源和更深层次的信息 链接到下一步该学习的内容 Prefer task-based headings 用读者正在处理的任务作为标题（如用C写服务器），避免出现读者目前还不熟悉的术语和工具（如不要出现具体的C框架名）。 Provide text under each heading 在每段标题下最少要有一段简短的介绍。不要标题挨着这标题 Disclose information progressively 太多的新术语和新名词会让读者难以读下去，应当在需要时才循序渐进的向读者提供信息。 以下小技巧可以帮助你更好的平衡： 尽量在需要用到的地方附近介绍新术语或概念 避免巨大的一段出现在文本上， 加入一些表格、插图或者标题。 将大的流程分成多步 。 用一个简单的例子开始，逐步的添加更多复杂的、有意思的技巧。 Illustrating 添加插图后，不管是好是坏，会让读者更愿意阅读文档 Write the caption first 好的标题： 应该是简洁的。 应该能够告知读者要点。 应该能够引导读者注意力在某一点上。 Constrain the amount of information in a single drawing 就像避免冗长复杂的句子一样，一个图例中也不要放太多信息（一个经验值：需要解释的内容不要超过5个项目符号）。 Focus the reader’s attention 使用一些视觉标记，比如说箭头或者圈，让读者能够注意到重要的部分。 Illustrating is re-illustrating 第一版的图或标题很难是最优的，因此需要反复迭代。 Creating sample code 好的示例代码就是最好的文档。 Correct 示例代码直接影响你的用户写的代码是什么样的，示例代码需要符合以下标准： Build without errors. Perform the task it claims to perform. Be as production-ready as possible. For example, the code shouldn’t contain any security vulnerabilities. Follow language-specific conventions. Running sample code 好的文档会解释怎么跑示例代码： Install a certain library. Adjust the values assigned to certain environment variables. Adjust something in the integrated development environment (IDE). Concise 示例代码应该是简短的，只包含必要的组件。 Understandable 有以下建议： Pick descriptive class, method, and variable names. Avoid confusing your readers with hard-to-decipher programming tricks. Avoid deeply nested code. Optional: Use bold or colored font to draw the reader’s attention to a specific section of your sample code. However, use highlighting judiciously—too much highlighting means the reader won’t focus on anything in particular. Commented Keep comments short, but always prefer clarity over brevity. Avoid writing comments about obvious code, but remember that what is obvious to you (the expert) might not be obvious to newcomers. Focus your commenting energy on anything non-intuitive in the code. When your readers are very experienced with a technology, don’t explain what the code is doing, explain why the code is doing it. Reusable 好的示例代码，应当提供以下内容： All information necessary to run the sample code, including any dependencies and setup. Code that can be extended or customized in useful ways. The example and the anti-example 同时展示正确示例和错误示例，有利于读者理解。 Sequenced 示例代码只展示了一部分的复杂性。太复杂的功能读者可能也理解不了。]]></content>
      <categories>
        <category>软技能</category>
      </categories>
      <tags>
        <tag>写作 英文写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灵光一闪]]></title>
    <url>%2F2021%2F04%2F21%2F%E7%81%B5%E5%85%89%E4%B8%80%E9%97%AA%2F</url>
    <content type="text"><![CDATA[记录一下平时突然想到的一些好的 idea。 计算机 架构应当解耦，但架构设计的思考过程不能解耦。 代码复用性越高，功能可用性就越低（观某难产项目后有感 80%的bug出现在设计阶段， 单测是横好的检验方法 高并发情境下，CPU以外的内存、磁盘都可能成为并发瓶颈 测试和需求是一致的， 有什么样的需求就会有什么样的测试。 代码的传染性：CodeBase内的代码会被各处copy 云作为基础设施，未来应当像自来水一样随用可取。同样的云原生应用也应当是随用可取的。 功能方面需求不要依赖用户理解接口实现，性能方面需求可以依赖理解接口实现 商业&amp;&amp;经济学 产品的第一步或冷增长应当是社交(爆款或裂变)为佳，机器推荐提供的是产品黏性。 服务业的服务价格取决于当地消费者的收入水平（机会成本），即你的收入实际上取决于与你分工的人的收入水平。如：剪发、按摩、中介等。 优质资产是相对概念在同一资产类目中排名靠前的资产即为优质资产。而排名考虑的是两点：α（超额收益）和β（系统风险系数） 新技术提供的是更多的可选项，而不是应该要使用。技术发展带来的是自由而不是“最新方案“的约束。 由于物质和能量守恒，所以物质财富是取之不竭的。其区别在于多少能够被人类所利用。 利润来源于系统不确定性。 确定概率的不确定性——偶然不确定性。 不确定概率的不确定性——认知（系统）不确定性。 风口不属于投机者，而是属于那些原本就在行业中深耕的人。 2020年中国零售消费市场 39万亿元 盈亏同源 投资的最重要的事 -&gt; 避险 -&gt;控制风险 -&gt; 控制不确定性 特别是系统不确定性 厚雪 长坡 护城河 预制菜的成熟发展成为了线下餐饮品牌化的重要一环，这使得中式餐厅第一次在标准化方面赶上了西式餐厅，也让中式连锁餐饮走入了规模化发展的时代。 可转债是上市公司的低息融资方式，目标是债主变股东，不用还钱。对于投资者来说是一个有较强保底的看涨期权，期权成本是利息差。 2021整个财富管理市场约220万亿元，到2023年预计到280万亿元 2021 公私募基金总规模44万亿元， 其中公募25.32万亿元，私募19.73万亿元 靠谱方法论 办事利索（指思路清晰，行动坚定）可以减少反复沟通造成的注意力损耗，从而更有利于高质量的完成任务。 可行性验证应当从最难的部分开始，而不是从简单可实现的部分开始下手。 旁观者在研究成功者的成功路径时，看到的是一条合理的确定路径。而成功者在当下，遇到的都是不确定性。 所以关键在于将自己代入情景，认识并学习成功者面对不确定性的方法。 邓宁克鲁格效应 先验概率应当被视为是先前经验的结果，而不是超越经验的，因为人的认识是有限主观的。 机器学习中，之前数据的训练结果即可视为一个先验概率，结合新的测试数据，进行最大似然概率的估计。]]></content>
  </entry>
  <entry>
    <title><![CDATA[工具杂记]]></title>
    <url>%2F2021%2F01%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E5%B7%A5%E5%85%B7%2F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[VScode 21个Vscode快捷键 Expand Bracket Selection 打开键盘快捷键(Ctrl + Shift + P 或 command + Shift + p)，搜索 Expand Bracket Selection。 VScode教程 这个教程还是很全的，只是找起来不太方便 CPP 工具 使用ccls：C++ language server 使用Doxygen创建C/C++文档 Git Git 中大文件清理 用来清理Git仓库中的大的blob Learn Git Branching 很不错的Git教程。 Docker Docker多阶段构建（多个 From） Docker 17.05版本以后，新增了Dockerfile多阶段构建。所谓多阶段构建，实际上是允许一个Dockerfile 中出现多个 FROM 指令。 GDB GDB保存断点 使用save breakpoint命令保存到指定的文件 必须在gdb加载文件的命令中指定断点文件，具体就是使用-x参数。例如，我需要调试fig8.3这个文件，指定刚才保存的断点文件fig8.3.bp。 我使用的是gdb fig8.3 -x fig8.3.bp 100 个GDB小技巧 GDB命令卡片 GDB Dashborad GDB dashboard is a standalone .gdbinit file written using the Python API that enables a modular interface showing relevant information about the program being debugged. Its main goal is to reduce the number of GDB commands needed to inspect the status of current program thus allowing the developer to primarily focus on the control flow. 挑选内容Merge https://stackoverflow.com/questions/449541/how-can-i-selectively-merge-or-pick-changes-from-another-branch-in-git You use the cherry-pick command to get individual commits from one branch. If the change(s) you want are not in individual commits, then use the method shown here to split the commit into individual commits. Roughly speaking, you use git rebase -i to get the original commit to edit, then git reset HEAD^ to selectively revert changes, then git commit to commit that bit as a new commit in the history. There is another nice method here in Red Hat Magazine, where they use git add --patch or possibly git add --interactive which allows you to add just parts of a hunk, if you want to split different changes to an individual file (search in that page for “split”). Having split the changes, you can now cherry-pick just the ones you want. GDB的那些奇淫技巧 - evilpan]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数修饰符]]></title>
    <url>%2F2020%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2FC-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[C++ 函数修饰符学习 https://tlanyan.me/cpp-function-modifier-summary/ 函数名前 返回值类型 返回值类型是C++中定义函数的必备部分，这些修饰符包括void，(unsigned) int，bool等内置基本数据类型和自定义类型，也包括修饰返回值const关键字（如const int*），还包括C++11中新增的类型自动推导auto关键字。 template template关键字声明函数是模板函数。 virtual virtual关键字声明函数是虚函数，可被子类覆盖。 inline inline关键字提示编译器应将函数内联。 srtatic static修饰类的成员函数时指示函数是静态成员函数，不从属于具体对象；修饰单独的函数时，限定函数的可见范围为本文件内。 extern extern关键字声明一个定义在外部的函数 explicit explicit关键字在C++11新增，只用于构造函数，指定构造函数要显式定义，不能隐式转换。 friend friend关键字声明类的友元函数，在函数内可直接访问对象的私有或受保护成员及成员函数。 constexpr C++11中新增，指示函数返回常量表达式（可以简单理解为返回字面量）。 函数名后 noexcept https://www.cnblogs.com/sword03/p/10020344.html https://www.zhihu.com/question/30950837 noexcept关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。 如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。 const 表示函数不会修改对象（或者说调用期间对象不变），注意不包括mutable修饰的成员变量 volatile 类似于const修饰的函数，表示对象状态可能随时会改变；const修饰的函数内只能调用自身的const成员方法，同理volatile函数内也只能调用自身volatile成员函数。 &amp; C++11引入的功能，左值引用限定符，指示函数只能被左值对象调用。 &amp;&amp; C++11引入，右值引用限定符，指示函数只能被右值调用。如果函数没有引用限定符修饰，左值和右值均可调用。一个引用限定例子： C++收起 123456789101112#include &lt;iostream&gt; struct S &#123; void f() &amp; &#123; std::cout &lt;&lt; &quot;lvalue\n&quot;; &#125; void f() &amp;&amp;&#123; std::cout &lt;&lt; &quot;rvalue\n&quot;; &#125; &#125;; int main()&#123; S s; s.f(); // 打印“ lvalue ” std::move(s).f(); // 打印“ rvalue ” S().f(); // 打印“ rvalue ” &#125; override C++11引入的功能，声明成员函数覆盖父类的虚函数。声明为override后，子类声明时可不写virtual。 final C++11引入，指示函数是最终实现，子类不应当再定义或覆盖，可与override同时使用。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>CPP基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘空间不足的排查方法]]></title>
    <url>%2F2020%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2FLinux%2F%E8%BF%90%E7%BB%B4%2F%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[磁盘空间不足原因及排查方法 https://blog.csdn.net/jiedao_liyk/article/details/78497625 不足原因： block满 df -h inode满 df -i 文件被占用一直没被彻底删除 lsof |grep deleted]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Include路径顺序]]></title>
    <url>%2F2020%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2FC-Include%E8%B7%AF%E5%BE%84%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C++ Include C++ 中include头文件时&lt;&gt;与&quot;&quot;的区别 #include &lt;&gt;格式：引用标准库头文件，编译器从标准库目录(IncludePath)开始搜索 #incluce &quot;&quot;格式：引用非标准库的头文件，编译器从用户的工作目录开始搜索，然后再在标准位置寻找文件。 Include 搜索过程 #include “headfile.h”引用头文件的搜索顺序为： 先搜索当前目录 然后搜索-I指定的目录 再搜索gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH） 最后搜索gcc的内定目录：/usr/include，/usr/local/include，/usr/lib/gcc/x86_64-redhat-linux/4.1.1/include各目录存在相同文件时，先找到哪个使用哪个。 #include &lt;headfile.h&gt;引用头文件的搜索顺序为： 先搜索-I指定的目录 然后搜索gcc的环境变量CPLUS_INCLUDE_PATH 最后搜索gcc的内定目录：/usr/include，/usr/local/include，/usr/lib/gcc/x86_64-redhat-linux/4.1.1/include 各目录存在相同文件时，先找到哪个使用哪个。 库搜索过程 编译时，库文件搜索路径： gcc会去找-L 再找gcc的环境变量LIBRARY_PATH 再找内定目录 /lib /usr/lib /usr/local/lib，这是当初compile gcc时写在程序内的 运行时，动态库搜索路径： 编译目标代码时指定的动态库搜索路径（这是通过gcc 的参数&quot;-Wl,-rpath,“指定。当指定多个动态库搜索路径时，路径之间用冒号”：&quot;分隔） 环境变量LD_LIBRARY_PATH指定的动态库搜索路径（当通过该环境变量指定多个动态库搜索路径时，路径之间用冒号&quot;：&quot;分隔） 配置文件/etc/ld.so.conf中指定的动态库搜索路径； 默认的动态库搜索路径/lib； 默认的动态库搜索路径/usr/lib。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>CPP基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pthread_barrier_t]]></title>
    <url>%2F2020%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fpthread-barrier-t%2F</url>
    <content type="text"><![CDATA[pthread_barrier_t 概念 barrier是用户协调多个线程并行工作的同步机制 原理：屏障允许每个线程等待，直到所有的合作线程都到达某一点（屏障），然后从该点继续执行工作 初始化和释放 int pthread_barrier_init(pthread_barrier_t *restrict barrier,const pthread_barrierattr_t *restrict attr,unsigned int count)： **功能：**对屏障变量进行初始化 参数： **参数1：**初始化的屏障变量 **参数2：**屏障初始化时的属性。如果用默认属性，此处填NULL（屏障属性见文章：https://blog.csdn.net/qq_41453285/article/details/90904886） **参数3：**用此参数指定，在允许所有线程继续执行之前，必须到达屏障的线程数目。当到达了这个数目之后就可以继续执行 int pthread_barrier_destroy(pthread_barrier_t *barrier)： **功能：**屏障变量的反初始化，释放销毁 **参数：**屏障变量 如果在pthread_barrier_destroy之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失 **备注（重点）：**此函数只是反初始化屏障变量，并没有释放内存空间，如果屏障变量是通过malloc等函数申请的，那么需要在free掉读屏障变量之前调用pthread_barrier_destroy函数 同步wait int pthread_barrier_wait(pthread_barrier_t *barrier); **功能：**线程调用该函数用来表示自己已经到达了屏障 **工作原理：**如果线程调用这个函数发现屏障的线程计数还未满足要求，那么线程就会进入休眠状态。如果线程调用此函数之后，发现刚好满足屏障计数，那么所有的线程都被唤醒 返回值:成功返回0或者PTHREAD_BARRIER_SERIAL_THREAD；否则返回错误编号 **返回值的注意事项：**如果一个线程调用该函数返回PTHREAD_BARRIER_SERIAL_THREAD，那么其他在屏障中的线程就返回0.这使得一个线程可以作为主线程，它可以工作在其他所有线程已经完成的工作结果上]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>CPP进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++拾遗]]></title>
    <url>%2F2020%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fc-%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[constexpt使用 https://www.cnblogs.com/DswCnblog/p/6513310.html sleep、yield、busy Spin的区别 sleep 交出cpu 等待SIGALRM唤醒重新调度 yield 交出CPU时间片 等待下次调度 busy Spin 一直占用cpu时间片 C++ 函数模板——返回值 https://blog.csdn.net/caroline_wendy/article/details/17003679 函数模板的返回值也可以定义为模板参数(template parameter), 但是由于无法推导(deduce), 需要显式(explicit)指定; 由于显式指定的顺序是从左至右, 返回值参数尽量放在左面,其余函数参数可以通过传入实参(argument)进行推导; 【C++】 variant https://www.cnblogs.com/thinkway/p/6743684.html https://en.cppreference.com/w/cpp/utility/variant c++17标准中引入了variant来作为union的类型安全替代品。它可以在任意时间保存模板参数列表中某一类型的值或者空值。 C++ handle 在编程时常常看到Handle这个概念。参照：https://stackoverflow.com/questions/1303123/what-is-a-handle-in-c/1303180#1303180 可以了解到，handle是指向某些resource的索引或者工具。你本身无法从handle中获得资源的信息，但将其传给API后就可以进行很多操作。 还有一类是Opaque handle，这一类handle 你在定义时也不能知道其中的内容信息。见：https://www.geeksforgeeks.org/opaque-pointer/ C++ 类成员函数中访问同类对象的私有成员 https://blog.csdn.net/walle_love_eva/article/details/9151273 C++的访问修饰符的作用是以类为单位，而不是以对象为单位。 类方法是所有该类对象共同使用的，因此不存在每个对象有一组类方法的副本。类方法自然可以访问所有该类对象的私有成员。 模板元编程 https://www.cnblogs.com/liangliangh/p/4219879.html GTest 值参数化测试 https://www.cnblogs.com/jycboy/p/6118073.html C++ 函数的类型 123456789101112131415161718// store a call to a member functionstd::function&lt;void(const Foo&amp;, int)&gt; f_add_display = &amp;Foo::print_add;const Foo foo(314159);f_add_display(foo, 1);f_add_display(314159, 1); // store a call to a data member accessorstd::function&lt;int(Foo const&amp;)&gt; f_num = &amp;Foo::num_;std::cout &lt;&lt; "num_: " &lt;&lt; f_num(foo) &lt;&lt; '\n'; // store a call to a member function and objectusing std::placeholders::_1;std::function&lt;void(int)&gt; f_add_display2 = std::bind( &amp;Foo::print_add, foo, _1 );f_add_display2(2); // store a call to a member function and object ptrstd::function&lt;void(int)&gt; f_add_display3 = std::bind( &amp;Foo::print_add, &amp;foo, _1 );f_add_display3(3); C++服务编译耗时优化原理及实践 JeMalloc https://zhuanlan.zhihu.com/p/48957114 C++ ROV RVO是Return Value Optimization的缩写，即返回值优化，NRVO就是具名的返回值优化，为RVO的一个变种，此特性从C++11开始支持。 C++lambda表达式 https://www.jianshu.com/p/d686ad9de817 一文读懂C++右值引用和std::move https://zhuanlan.zhihu.com/p/335994370 但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升 除非设计不允许移动，STL类大都支持移动语义函数，即可移动的。 另外，编译器会默认在用户自定义的class和struct中生成移动语义函数，但前提是用户没有主动定义该类的拷贝构造等函数(具体规则自行百度哈)。 因此，可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用std::move触发移动语义，提升性能。 C++ 完美转发 forward原理 https://www.cnblogs.com/5iedu/p/11324772.html https://www.yuanguohuo.com/2018/05/25/cpp11-perfect-forward/ 万能引用 https://www.cnblogs.com/5iedu/p/11378023.html C++11中range-based for loops中&amp;&amp;与&amp;的区别 https://blog.csdn.net/haolexiao/article/details/56842552 C++ memory order std::atomic_thread_fence https://blog.csdn.net/wxj1992/article/details/103917093 而在C++ 11及之后的标准里，除了利用原子操作指定内存序，还定义了单独使用memory fence（std::atomic_thread_fence）的方式，fence可以和原子操作组合进行同步，也可以fence之间进行同步， GTEST 系列 Guide https://google.github.io/googletest/ Benchmark Guide https://benchmark.docsforge.com/master/getting-started/ 浅析std::ref与reference_wrapper https://blog.csdn.net/u014645632/article/details/78966340 声明于 中的 class std::reference_wrapper&lt;&gt; 主要用来“喂 ” reference 给function template, 后者原本以 by value方式接受参数。对于一个给定类型 T ，这个 class 提供 ref () 用以隐式转换为 T&amp; ，一个 cref () 用以隐式转换为 const T&amp; ，这往往允许 function template 得以操作 reference 而不需要另写特化版本。 STL 中迭代器失效 https://blog.csdn.net/skyroben/article/details/70877008 向容器中添加或者删除元素的操作可能会使指向容器元素的迭代器失效，失效的迭代器将不指向任何元素。 一般有两种情况无法通过迭代器++操作遍历整个stl容器; 无法通过迭代器存取迭代器所指向的内存。 Modern Cmake https://cliutils.gitlab.io/modern-cmake/ enable_if的几种用法 https://yixinglu.gitlab.io/enable_if.html 用法一：类型偏特化 用法二：控制函数返回类型 用法三：校验函数模板参数类型 typename用法 https://feihu.me/blog/2014/the-origin-and-usage-of-typename/ A name used in a template declaration or definition and that is dependent on a template-parameter is assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified by the keyword typename. 对于用于模板定义的依赖于模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前使用了typename关键字来修饰，编译器才会将该名称当成是类型。除了以上这两种情况，绝不会被当成是类型。 C++ 中的 mutable 关键字 https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/ C++中智能指针做函数参数和返回值的指导 不要返回 智能指针的引用 做参数时 表达所有权借用使用值的参数形式 表达所有权修改使用引用的参数形式]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>CPP, 文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker内使用SSH-Key]]></title>
    <url>%2F2020%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E5%B7%A5%E5%85%B7%2FDocker%E5%86%85%E4%BD%BF%E7%94%A8SSH-Key%2F</url>
    <content type="text"><![CDATA[Docker内使用SSH Key DockerFile： 123456789101112ARG SSH_KEYARG SSH_KEY_PASSPHRASE# Authorize SSH HostRUN mkdir -p /root/.ssh &amp;&amp; \ chmod 0700 /root/.ssh &amp;&amp; \ ssh-keyscan github.com &gt; /root/.ssh/known_hosts # Add the keys and set permissionsRUN echo "$ssh_prv_key" &gt; /root/.ssh/id_rsa &amp;&amp; \ echo "$ssh_pub_key" &gt; /root/.ssh/id_rsa.pub &amp;&amp; \ chmod 600 /root/.ssh/id_rsa &amp;&amp; \ chmod 600 /root/.ssh/id_rsa.pub 构建命令 1$ docker build -t example --build-arg ssh_prv_key="$(cat ~/.ssh/id_rsa)" --build-arg ssh_pub_key="$(cat ~/.ssh/id_rsa.pub)"]]></content>
      <categories>
        <category>k8s/docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中Static]]></title>
    <url>%2F2020%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2FC-%E4%B8%ADStatic%2F</url>
    <content type="text"><![CDATA[C++中static用途 从两方面来分析： 作用域 生存期 C/C++都有 静态局部变量 作用域：函数体内部 生存期：整个程序运行期间 12345678int foo()&#123; static int si = 1; //note:1 int ci = 1; //note:2 si += 1; printf("&amp;si = %p\t si = %d\t &amp;ci = %p\t ci = %d\n", &amp;si, si, &amp;ci, ci); return si;&#125; 静态全局变量 作用域：文件内部 生存期：整个程序运行期间 12345678910static int gsi = 1;//note:3int gi = 1; //note:4 int gfoo()&#123; gsi += 1; gi += 1; printf("gfoo &amp;gsi= %p\t gsi = %d\t &amp;gi= %p\t gi = %d\n", &amp;gsi, gsi, &amp;gi, gi); return gsi;&#125; 静态函数 作用域：文件内部 生存期：整个程序运行期间 123456789101112131415//extern.c void cfoo()&#123; printf("this is non-static cfoo in extern.c &amp;egsi = %p\t egsi = %d\n", &amp;egsi ,egsi);&#125; //mian.cextern void cfoo();int main()&#123; cfoo(); return 0;&#125; C++中用途 静态数据成员 作用域：全局 生存期：整个程序 静态成员函数 作用域：类 生存期：整个程序]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP, CPP基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NanoLog-纳秒级C++日志]]></title>
    <url>%2F2020%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2FNanoLog-%E7%BA%B3%E7%A7%92%E7%BA%A7C-%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[NanoLog 背景 现有日志系统缺陷 同步写日志——慢 放到后台线程写，仍有代价。且为了不被卡住，要减少产生日志量： 设置日志等级 随机采样log 观察 人可读懂的Log不是必须在应用中产生。 日志信息存在广泛的重复，大部分内容是静态内容。 设计 思想 在编译阶段提取log信息中的重复的静态部分，用字典ID代替字符串 将format工作推迟到离线任务。 压缩日志中的动态变量，减少IO。 详细设计 NanoLog的具体设计如下图所示： 整个日志系统参与的生命周期被分为了三个部分，分别是：编译、运行时以及离线处理。 编译 编译阶段中，NanoLog的PreProcessor会对用户代码进行处理。其中两个关键函数是record（）和compact（）： record(): record函数接收一个buffer和id，ID唯一表示了一个日志调用，而buffer中，储存了日志调用中的动态变量，有了这些信息，NanoLog即可拼接出日志信息。 compact()：compact函数接收一个buffer，负责将buffer中的数据压缩，减少io消耗。 主要包括几个工作： PreProcessor对用户代码中的NanoLog宏进行处理，对于每个宏调用，会记录其文件、代码行数、静态日志字符串、动态变量类型以及为其生成一个独立的ID。之后会将宏调用替换为一个record()函数调用。 对每个宏调用对记录信息，会通过Combiner合成一个完整对字典，共runtime使用 之后，生成对字典会和NanoRuntime的库代码编译出一份静态库，该库和处理过的用户代码最终编译成可执行文件。 运行时 运行过程中，用户的日志操作实际上就是一个非常简单的函数调用，传入id和buffer，然后被记录为一个带时间戳的event，存入线程单独的stagingBuffer，因此也没有同步开销。 实际写入的是后台的Compaction线程，compaction线程读取各个用户线程stagingBuffer,将其中的event的数据根据编译阶段生成的字典中记录的类型信息进行压缩。之后写入磁盘。 离线 NanoLog实际落盘的是一个压缩过的二进制日志文件，要生成人可读的Log还需要使用Decompressor进行解压。 使用 NanoLog目前提供了2种集成方式。 preprocessor：这种方式利用一个python脚本，在编译前，对代码中的日志调用进行处理，生成新的static调用. c++17 precompile：这种方式利用了c17的一些precompile特性实现了和preprocessor一样对效果，用户不需要提前用preprocessor处理代码。 但需要c17的特性支持。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>日志技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-如何写代码注释]]></title>
    <url>%2F2020%2F09%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FPrograming%2F%E8%BD%AC-%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[许多人认为，如果代码写得足够扎实，注释就没什么用了。在他们看来，当一切都设计妥当时，代码本身会记录其作用，因此代码注释是多余的。我对此持不同意见，主要出于两个原因： \1. 许多注释并未起到解释代码的作用。 \2. 注释使读者不必凭空想象太多细枝末节，帮助读者降低认知负担。 注释的分类 我的工作始于随机地阅读Redis源代码，以检查注释是否以及为什么在不同的上下文中起作用。我很快发现，注释的作用来源于多方面：它们在功能，编程风格，长度和更新频率方面往往非常不同。我最终转向了注释分类。 在研究期间，我确定了九种注释类别： * 函数注释 Function comments * 设计注释 Design comments * 原因注释 Why comments * 教学注释 Teacher comments * 清单注释 Checklist comments * 引导注释 Guide comments * 琐碎注释 Trivial comments * （代码）负债注释 Debt comments * 备份注释 Backup comments 在我看来，前六个主要是非常积极的注释形式，而最后三个有点值得怀疑。在接下来的部分中，我将使用Redis源代码中的示例分析每种注释类型。 函数注释 函数注释的目标是防止读者直接阅读代码。 在阅读注释之后，读者应该可以将一些代码视为应遵守某些规则的黑箱子。通常情况下，函数注释位于函数定义的顶部。 rax.c： C++收起 1234/ * 在当前节点的子树中寻找最大的key。 如果内存不足返回0，否则 返回1. * /int raxSeekGreatest（raxIterator * it）&#123; ...&#125; 函数注释实际上是一种内联API文档。如果函数注释编写得好，那么用户在大多数时候能跳回到她正在阅读的内容（如阅读调用此类API的代码），而无需阅读函数（function），类（class），宏（macro）等的实现过程。 在所有注释类型中，函数注释被整个编程界广泛接受和需要。要分析的唯一一点是：在代码内部放置以API参考文档为主的注释是否是件好事。 对我来说答案很简单：我希望API文档与代码完全匹配。随着代码的更改，文档也得到更改。出于这个原因，我们将函数注释用作函数或其他元素的序言，使API文档接近代码，完成三个任务： * 随着代码的更改，我们可以轻松更改文档，API参考也不会有过时的风险。 * 这种方法使得更改者（理应是最清楚更改目的的人）在最大限度上成为API文档的更改者。 * 读者能通过阅读代码直接找到函数或方法（method）的文档，以便阅读代码的读者只关注代码，而不是代码和文档之间的上下文切换。 设计注释 “函数注释”通常位于函数的开头，而设计注释通常位于文件的开头。 设计注释一般说明了给定代码片段使用某些算法、技术、技巧和具体实现的方式和原因，对代码中实现的内容进行了更高级别的概述。在这样的背景下，阅读代码会更简单一些。 bio.c C++收起 1234567*设计* ------**设计很简单，我们用一个结构代表要执行的一项 Job*每种Job类型有不同的线程和Job队列。*每个线程都在等待队列中的新Job，并按照顺序处理*每个Job。 ... 原因注释 原因注释解释了代码执行某些操作的原因——即使代码执行的操作非常明确。请看以下来自Redis replication的代码 的示例。 replication.c： C++收起 123456789101112131415161718192021222324if（idle&gt; server.repl_backlog_time_limit）&#123; /* 当我们释放 backlog时，我们总是使用新的 * replication ID并清除ID2。这是 * 因为在没有backlog时，master_repl_offset * 未更新，但我们仍会保留我们的 * replication ID，由此导致以下问题： * * 1.我们是一个主实例（master instance）。 * 2.我们的副本成为主服务器（Master）。repl-id-2将会 * 与我们的repl-id相同。 * 3.我们作为主服务器，收到了一些更新命令，但不会 * 增加master_repl_offset。 * 4.稍后我们将变成副本，连接到新的 * 主服务器，它将接受我们第二个副本ID的 * PSYNC请求，但会有数据不一致的情况 * 因为我们接受了写命令。*/ changeReplicationId（）; clearReplicationId2（）; freeReplicationBacklog（）; serverLog(LL_NOTICE, &quot;Replication backlog freed after %d seconds &quot; &quot;without connected replicas.&quot;, (int) server.repl_backlog_time_limit); &#125; 如果我只检查函数调用，就没什么需要纠结的：如果超时了就更改主replication ID，清除辅助ID，最后释放replication backlog。 教学注释 教学注释不会试图解释代码本身或我们应该注意的某些副作用。教学注释教授的是代码运行的“领域”（例如数学，计算机图形学，网络系统，统计，复杂的数据结构等），这些信息可能超出了读者的认知范围，或者细节多到难以回忆。 版本5中的LOLWUT命令需要在屏幕上显示旋转的方块。为了做到这一点，它使用了一些基本的三角函数：尽管涉及的数学内容很简单，但许多阅读Redis源代码的程序员可能没有任何数学背景知识，因此函数顶部的注释解释了该函数的原理。 C++收起 123456789101112131415/** 绘制一个以指定的x，y坐标为中心的正方形* 旋转角度和大小已定。为了写出旋转方块的代码，我们使用了* 参数方程：** x = sin（k）* y = cos（k）** 绘制一个圆（0-2*PI）。然后，如果我们从45度* 开始，即k = PI / 4，以此作为第一个点，然后我们发现* 其他三个点的K值以PI / 2（90度）递增，于是我们得到* 了构成一个圆的点。为了旋转方块，我们从* k = PI / 4 + rotation_angle开始，然后我们就完事儿了。* ......* / 注释不包含任何与函数本身的代码，或其副作用，或与函数相关的技术细节等内容。注释描述的部分仅限于函数内部使用以达到给定目标的数学概念。 清单注释 这是一个非常常见且奇怪的问题：有时由于语言限制，设计问题，或者仅仅因为系统内部固有的复杂性，我们无法将某个概念或界面集中在一个代码片段中，因此代码中有一些部分能提醒你在代码的某个部分做某件事。一般概念是： / * 警告：如果你在此处添加类型ID，请务必修改 * getTypeNameByID（）函数。* / 在一个完美世界中，我们永远不需要添加这类注释；但在实践中有时没法省略这一步。 在这种情况下，防御性注释有时能起作用：如果你修改了某节代码，它会提醒你修改代码的其他相关部分。具体而言，清单注释会发挥以下一种作用（或者两种兼而有之）： * 告诉你在修改某些内容时要执行的一系列操作。 * 警告你应该如何进行某些更改。 引导注释 我滥用引导注释到这种程度：Redis中的大多数注释都是引导注释。然而，引导注释正是大多数人认知中那类完全无用的注释： * 他们没有说明代码中不甚明了的内容。 * 指导注释不提供有关设计方面的提示。 引导注释只做了一件事：他们照顾了读者的需求，在读者处理源代码中的内容时提供明确的划分（division）和节奏（rhythm），并介绍接下来需要阅读的内容。 rax.c C++收起 12345678910/*调用节点回调（如果有的话），如果回调返回true *则替换节点指标*/if (it-&gt;node_cb &amp;&amp; it-&gt;node_cb(&amp;it-&gt;node)) memcpy(cp,&amp;it-&gt;node,sizeof(it-&gt;node)); /*对于“下一步”，每次找到一个键就停止*一次，因为相比较后面子节点分支中的内容*键本身字典序较小。*/if (it-&gt;node-&gt;iskey) &#123; it-&gt;data = raxGetData(it-&gt;node); return 1;&#125; Redis内“实际上”充满了引导注释，所以基本上你打开的每个文件都会包含很多引导注释。为什么要费这个力气呢？在这篇博客文章中所分析的所有注释类型中，这绝对是最主观的一种。我并不觉得没有引导注释的代码就不是好代码。但我坚信，如果人们认为Redis代码是可读的，部分原因就在于其中的引导注释。 引导注释还有一些别的用处。因为它们明确地将代码划分为独立的部分，所以我们能在合适的位置插入新代码，而不是随便加在其他代码后面。在代码附近设置相关语句能大大提高可读性。 引导注释能简要地告诉读者函数将要执行什么操作，所以如果你只对大框架感兴趣，则无需回过头去阅读函数。 琐碎注释 引导注释是非常主观的工具。不管你喜不喜欢，我反正超爱引导注释。 然而，引导注释可能会退化为极其糟糕的注释：它很容易变成“琐碎注释”（trivial comment）。 琐碎注释这种引导注释所带来的认知负荷和仅阅读相关代码比起来相差无几，甚至可能更高。以下这种琐碎注释正是许多书籍规劝你避免的。 array_len ++; / 增加数组的长度。 / 因此，如果你写引导注释的话，请避免写琐碎注释。 （代码）负债注释 负债注释是源代码内部硬编码的技术债务语句： C++收起 12345entries -= to_delete;marked_deleted += to_delete;if (entries + marked_deleted &gt; 10 &amp;&amp; marked_deleted &gt; entries/2) &#123; / * TODO：执行垃圾收集操作。* /&#125; FIXME，TODO，XXX，这些都是负债注释。总的来说这些注释不算好，我试图避免使用它们，但看起来不太可能。有时候，比起永远忘记一个问题，我更喜欢在源代码中放置一个节点。程序员至少应该定期查看这些注释，看看是否可以能改进一下表述，或者这些问题是否已不再相关或可以立即解决。 备份注释 备份注释是开发人员对某些代码块的旧版本甚至是整个函数做出的注释，因为他/她对新版本中运行的更改放不下心。令人费解的是，现在有了Git，人们却还在使用这类注释。我想人们对于丢失代码片段有一种不安全感，过去提交代码时，使用备份注释会显得更加理智可靠。 但源代码并不是用来备份的。如果你需要保存旧版本的函数或代码，说明你的工作尚未完成，也无法提交。要么确保新函数比过去的更好，要么只在开发树（development tree）中使用它，直到你确定为止。 备份注释是我分类中的最后一项。我们来做个总结。 总结 注释是和未来的代码读者聊天，读者们还能在Twitter上评价你的注释。所以在这个过程中，你真心地在审视自己所注释的内容是否“能让人接受”，看自己写得是否足够体面、足够好。如果不是，你就勤勤恳恳地再做一遍，拿出更好的注释来。 你可能认为编写注释不是个高端工作。毕竟你“会写代码”！但请考虑这一点：代码是一组语句和函数调用（或者你做的其他编程范例也一样）。如果代码写得不好，这些语句就没有多大意义。注释常常要求你进行一些设计过程，并从更深层次来理解你正在编写的代码。 最重要的是，为了写出好的注释，你必须培养自己的写作能力。这种写作技巧能帮你更好地编写电子邮件、文案、设计文档、博客文章和提交文件。 我写代码是因为我迫切想要与他人沟通交流、分享想法。注释能够为代码提供帮助，把作者的心血表现出来。说到底，我喜欢写注释，就像我喜欢写代码一样。]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
        <tag>代码注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-日志规范]]></title>
    <url>%2F2020%2F09%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FPrograming%2F%E8%BD%AC-%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[日志 日志是什么？ 日志，维基百科的定义是记录服务器等电脑设备或软件的运作。 日志文件提供精确的系统记录，根据日志最终定位到错误详情和根源。日志的特点是，它描述一些离散的（不连续的）事件。 例如：应用通过一个滚动的文件输出 INFO 或 ERROR 信息，并通过日志收集系统，存储到一些存储引擎（Elasticsearch）中方便查询。 日志有什么用？ 在上文中我们解释了日志的作用是提供精准的系统记录方便根因分析。那么具体在哪些具体方面它可以发挥作用？ 打印调试：即可以用日志来记录变量或者某一段逻辑。记录程序运行的流程，即程序运行了哪些代码，方便排查逻辑问题。 问题定位：程序出异常或者出故障时快速的定位问题，方便后期解决问题。因为线上生产环境无法 debug，在测试环境去模拟一套生产环境，费时费力。所以依靠日志记录的信息定位问题，这点非常重要。还可以记录流量，后期可以通过 ELK（包括 EFK 进行流量统计）。 用户行为日志：记录用户的操作行为，用于大数据分析，比如监控、风控、推荐等等。这种日志，一般是给其他团队分析使用，而且可能是多个团队，因此一般会有一定的格式要求，开发者应该按照这个格式来记录，便于其他团队的使用。当然，要记录哪些行为、操作，一般也是约定好的，因此，开发者主要是执行的角色。 根因分析（甩锅必备）：即在关键地方记录日志。方便在和各个终端定位问题时，别人说时你的程序问题，你可以理直气壮的拿出你的日志说，看，我这里运行了，状态也是对的。这样，对方就会乖乖去定位他的代码，而不是互相推脱。 什么时候记录日志？ 上文说了日志的重要性，那么什么时候需要记录日志。 系统初始化：系统或者服务的启动参数。核心模块或者组件初始化过程中往往依赖一些关键配置，根据参数不同会提供不一样的服务。务必在这里记录 INFO 日志，打印出参数以及启动完成态服务表述。 编程语言提示异常：如今各类主流的编程语言都包括异常机制，业务相关的流行框架有完整的异常模块。这类捕获的异常是系统告知开发人员需要加以关注的，是质量非常高的报错。应当适当记录日志，根据实际结合业务的情况使用 WARN 或者 ERROR 级别。 业务流程预期不符：除开平台以及编程语言异常之外，项目代码中结果与期望不符时也是日志场景之一，简单来说所有流程分支都可以加入考虑。取决于开发人员判断能否容忍情形发生。常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等。 系统核心角色，组件关键动作：系统中核心角色触发的业务动作是需要多加关注的，是衡量系统正常运行的重要指标，建议记录 INFO 级别日志，比如电商系统用户从登录到下单的整个流程；微服务各服务节点交互；核心数据表增删改；核心组件运行等等，如果日志频度高或者打印量特别大，可以提炼关键点 INFO 记录，其余酌情考虑 DEBUG 级别。 第三方服务远程调用：微服务架构体系中有一个重要的点就是第三方永远不可信，对于第三方服务远程调用建议打印请求和响应的参数，方便在和各个终端定位问题，不会因为第三方服务日志的缺失变得手足无措。 日志打印 Slf4j &amp; Logback Slf4j 英文全称为 “ Simple Logging Facade for Java ”，为 Java 提供的简单日志门面。Facade 门面，更底层一点说就是接口。它允许用户以自己的喜好，在工程中通过 Slf4j 接入不同的日志系统。 Logback 是 Slf4j 的原生实现框架，同样也是出自 Log4j 一个人之手，但拥有比 Log4j 更多的优点、特性和更做强的性能，Logback 相对于 Log4j 拥有更快的执行速度。基于我们先前在 Log4j 上的工作，Logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上 10 倍。在保证 Logback 的组件更加快速的同时，同时所需的内存更加少。 日志文件 日志文件放置于固定的目录中，按照一定的模板进行命名，推荐的日志文件名称： Plain Text收起 123当前正在写入的日志文件名：&lt;应用名&gt;[-&lt;功能名&gt;].log如：example-server-book-service-access.log已经滚入历史的日志文件名：&lt;应用名&gt;[-&lt;功能名&gt;].yyyy-MM-dd-hh.[滚动号].log 如：example-server-book-service-access.2019-12-01-10.1.log 日志变量定义 推荐使用 lombok（代码生成器） 注解 @lombok.extern.slf4j.Slf4j 来生成日志变量实例。 代码示例 Java收起 12345678910import lombok.extern.slf4j.Slf4j; @Slf4jpublic class LogTest &#123; public static void main(String[] args) &#123; log.info(&quot;this is log test&quot;); &#125; &#125; 日志配置 日志记录采用分级记录，级别与日志文件名相对应，不同级别的日志信息记录到不同的日志文件中。如有特殊格式日志，如 access log，单独使用一个文件，请注意避免重复打印（可使用 additivity**=“false”** 避免 ）。 参数占位格式 使用参数化形式 {} 占位，[] 进行参数隔离，这样的好处是可读性更高，而且只有真正准备打印的时候才会处理参数。 Java收起 1234// 正确示例，必须使用参数化信息的方式log.debug(&quot;order is paying with userId:[&#123;&#125;] and orderId : [&#123;&#125;]&quot;,userId, orderId);// 错误示例，不要进行字符串拼接,那样会产生很多 String 对象，占用空间，影响性能。及日志级别高于此级别也会进行字符串拼接逻辑。log.debug(&quot;order is paying with userId: &quot; + userId + &quot; and orderId: &quot; + orderId); 日志的基本格式 日志时间 作为日志产生的日期和时间，这个数据非常重要，一般精确到毫秒。 Plain Text 1yyyy-MM-dd HH:mm:ss.SSS 日志级别 日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。 主要使用如下的四个级别： DEBUG：DEUBG 级别的主要输出调试性质的内容，该级别日志主要用于在开发、测试阶段输出。该级别的日志应尽可能地详尽，开发人员可以将各类详细信息记录到 DEBUG 里，起到调试的作用，包括参数信息，调试细节信息，返回值信息等等，便于在开发、测试阶段出现问题或者异常时，对其进行分析。 INFO：INFO 级别的主要记录系统关键信息，旨在保留系统正常工作期间关键运行指标，开发人员可以将初始化系统配置、业务状态变化信息，或者用户业务流程中的核心处理记录到INFO日志中，方便日常运维工作以及错误回溯时上下文场景复现。建议在项目完成后，在测试环境将日志级别调成 INFO，然后通过 INFO 级别的信息看看是否能了解这个应用的运用情况，如果出现问题后是否这些日志能否提供有用的排查问题的信息。 WARN：WARN 级别的主要输出警告性质的内容，这些内容是可以预知且是有规划的，比如，某个方法入参为空或者该参数的值不满足运行该方法的条件时。在 WARN 级别的时应输出较为详尽的信息，以便于事后对日志进行分析。 ERROR：ERROR 级别主要针对于一些不可预知的信息，诸如：错误、异常等，比如，在 catch 块中抓获的网络通信、数据库连接等异常，若异常对系统的整个流程影响不大，可以使用 WARN 级别日志输出。在输出 ERROR 级别的日志时，尽量多地输出方法入参数、方法执行过程中产生的对象等数据，在带有错误、异常对象的数据时，需要将该对象一并输出。 DEBUG / INFO 的选择 DEBUG 级别比 INFO 低，包含调试时更详细的了解系统运行状态的东西，比如变量的值等等，都可以输出到 DEBUG 日志里。 INFO 是在线日志默认的输出级别，反馈系统的当前状态给最终用户看的。输出的信息，应该对最终用户具有实际意义的。从功能角度上说，INFO 输出的信息可以看作是软件产品的一部分，所以需要谨慎对待，不可随便输出。如果这条日志会被频繁打印或者大部分时间对于纠错起不到作用，就应当考虑下调为 DEBUG 级别。 由于 DEBUG 日志打印量远大于 INFO，出于前文日志性能的考虑，如果代码为核心代码，执行频率非常高，务必推敲日志设计是否合理，是否需要下调为 DEBUG 级别日志。 注意日志的可读性，不妨在写完代码 review 这条日志是否通顺，能否提供真正有意义的信息。 日志输出是多线程公用的，如果有另外一个线程正在输出日志，上面的记录就会被打断，最终显示输出和预想的就会不一致。 WARN / ERROR 的选择 当方法或者功能处理过程中产生不符合预期结果或者有框架报错时可以考虑使用，常见问题处理方法包括： 增加判断处理逻辑，尝试本地解决：增加逻辑判断吞掉报警永远是最优选择抛出异常，交给上层逻辑解决 抛出异常，交给上层逻辑解决 记录日志，报警提醒 使用返回码包装错误做返回 一般来说，WARN 级别不会短信报警，ERROR 级别则会短信报警甚至电话报警，ERROR 级别的日志意味着系统中发生了非常严重的问题，必须有人马上处理，比如数据库不可用，系统的关键业务流程走不下去等等。错误的使用反而带来严重的后果，不区分问题的重要程度，只要有问题就error记录下来，其实这样是非常不负责任的，因为对于成熟的系统，都会有一套完整的报错机制，那这个错误信息什么时候需要发出来，很多都是依据单位时间内 ERROR 日志的数量来确定的。 强调ERROR报警 ERROR 级别的日志打印通常伴随报警通知。ERROR的报出应该伴随着业务功能受损，即上面提到的系统中发生了非常严重的问题，必须有人马上处理。 ERROR日志目标 给处理者直接准确的信息：ERROR 信息形成自身闭环。 问题定位： 发生了什么问题，哪些功能受到影响 获取帮助信息：直接帮助信息或帮助信息的存储位置 通过报警知道解决方案或者找何人解决 线程名称 输出该日志的线程名称，一般在一个应用中一个同步请求由同一线程完成，输出线程名称可以在各个请求产生的日志中进行分类，便于分清当前请求上下文的日志。 opentracing 标识 在分布式应用中，用户的一个请求会调用若干个服务完成，这些服务可能还是嵌套调用的，因此完成一个请求的日志并不在一个应用的日志文件，而是分散在不同服务器上不同应用节点的日志文件中。该标识是为了串联一个请求在整个系统中的调用日志。 唯一字符串（trace id） 调用层级（span id） 通过搜索 trace id 就可以查到这个 trace id 标识的请求在整个系统中流转（处理）过程中产生的所有日志。 biz 标识 在业务开发中，我们的日志都是和业务相关联的，有时候是需要根据用户或者业务做聚类的，因此一次请求如果可以通过某项标识做聚类的时候，可以将聚类标识打印到日志中。 用户标识（user id） 业务标识（biz id） 日志记录器名称 日志记录器名称一般使用类名，日志文件中可以输出简单的类名即可，看实际情况是否需要使用包名和行号等信息。主要用于看到日志后到哪个类中去找这个日志输出，便于定位问题所在。 日志内容 禁用 System.out.println 和 System.err.println 变参替换日志拼接 输出日志的对象，应在其类中实现快速的 toString 方法，以便于在日志输出时仅输出这个对象类名和 hashCode 预防空指针:不要在日志中调用对象的方法获取值，除非确保该对象肯定不为 null，否则很有可能会因为日志的问题而导致应用产生空指针异常。 异常堆栈 异常堆栈一般会出现在 ERROR 或者 WARN 级别的日志中，异常堆栈含有方法调用链的系统，以及异常产生的根源。异常堆栈的日志属于上一行日志的，在日志收集时需要将其划至上一行中。 最佳实践 日志格式 Bash 12019-12-01 00:00:00.000|pid|log-level|[svc-name,trace-id,span-id,user-id,biz-id]|thread-name|package-name.class-name : log message 时间 pid，pid log-level，日志级别 svc-name，应用名称 trace-id，调用链标识 span-id，调用层级标识 user-id，用户标识 biz-id，业务标识 thread-name，线程名称 package-name.class-name，日志记录器名称 log message，日志消息体 日志模块扩展 日志模块是基于以下技术点做扩展的。 Slf4j MDC 实现原理（暂不开展详解，如有兴趣私下沟通） Opentracing Scope 原理（暂不开展详解，如有兴趣私下沟通） 在每个 tracing 链路中，将 Opentracing Scope 中的上下文信息放置 MDC 中，根据 Spring Boot Logging 扩展接口扩展的取值逻辑 **logging.pattern.level **的取值逻辑。 相关源码参考 [Spring Cloud Sleuth]github.com/spring-clou… 修改 logback 配置文件中每个 appender 的 pattern 为以下默认值即可实现标准化。 Bash 1%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;|$&#123;PID:- &#125;|%level|$&#123;LOG_LEVEL_PATTERN:-%5p&#125;|%t|%-40.40logger&#123;39&#125;: %msg%n logback.xml 节选 XML收起 12345678&lt;configuration&gt;&lt;property name=&quot;LOG_PATH&quot; value=&quot;$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;&quot;/&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;APP_NAME&quot; source=&quot;spring.application.name&quot; defaultValue=&quot;spring-boot-fusion&quot;&quot;LOG_PATTERN&quot; value=&quot;%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;|$&#123;PID:- &#125;|%level|$&#123;LOG_LEVEL_PATTERN:-%5p&#125;|%t|%-40.40logger&#123;39&#125;: %msg%n&quot;&quot;fileInfo&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;$&#123;LOG_PATH&#125;/$&#123;APP_NAME&#125;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;$&#123;LOG_PATH&#125;/$&#123;APP_NAME&#125;&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt;$&#123;LOG_PATTERN&#125;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;复制代码 代码使用示例： Plain Text收起 12345678910@Overridepublic Result&lt;PagingObject&lt;SimpleResponse&gt;&gt; page(@RequestParam(value = &quot;page-num&quot;, defaultValue = &quot;1&quot;) int pageNum, @RequestParam(value = &quot;page-size&quot;, defaultValue = &quot;10&quot;) int pageSize) &#123; LogStandardUtils.putUserId(&quot;userId123&quot;); LogStandardUtils.putBizId(&quot;bizId321&quot;); producerService.sendMsg(&quot;xxx&quot;); simpleClient.page(pageNum, pageSize); return new Result&lt;&gt;(simpleService.page(pageNum, pageSize));&#125;复制代码 日志记录 Bash收起 123456782019-12-04 16:29:08.223|43546|INFO|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.n.u.concurrent.ShutdownEnabledTimer : Shutdown hook installed for: NFLoadBalancer-PingTimer-example-server-order-service2019-12-04 16:29:08.224|43546|INFO|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.netflix.loadbalancer.BaseLoadBalancer : Client: example-server-order-service instantiated a LoadBalancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=example-server-order-service,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:null2019-12-04 16:29:08.234|43546|INFO|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.n.l.DynamicServerListLoadBalancer : Using serverListUpdater PollingServerListUpdater2019-12-04 16:29:08.247|43546|INFO|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.n.l.DynamicServerListLoadBalancer : DynamicServerListLoadBalancer for client example-server-order-service initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=example-server-order-service,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:ConsulServerList&#123;serviceId=&apos;example-server-order-service&apos;, tag=null&#125;2019-12-04 16:29:08.329|43546|WARN|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.p.f.l.ctl.common.rule.StrategyRule : No up servers available from load balancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=example-server-order-service,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:ConsulServerList&#123;serviceId=&apos;example-server-order-service&apos;, tag=null&#125;2019-12-04 16:29:08.334|43546|WARN|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.p.f.l.ctl.common.rule.StrategyRule : No up servers available from load balancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=example-server-order-service,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:ConsulServerList&#123;serviceId=&apos;example-server-order-service&apos;, tag=null&#125;2019-12-04 16:29:08.342|43546|ERROR|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.p.f.w.c.advice.ExceptionHandlerAdvice : 当前程序进入到异常捕获器，出错的 url 为：[ http://127.0.0.1:10011/simples ]，出错的参数为：[ &#123;&quot;querystring&quot;:&quot;&#123;&#125;&quot;,&quot;payload&quot;:&quot;&quot;&#125; ]java.lang.RuntimeException: com.netflix.client.ClientException: Load balancer does not have available server for client: example-server-order-service 实践说明 普通格式日志 Bash 12019-11-26 15:01:03.332|1543|INFO|[example-server-book-service,28f019d57b8336ab,630697c7f34ca4fa,105,45982043|XNIO-1 task-42]|c.p.f.w.pay.PayServiceImpl : order is paying with userId: 105 and orderId: 45982043 普通日志前缀是固定的，可以固定分词索引，方便更快的查询分析。 特定格式日志 以 access 日志为例 Bash收起 12345678910111213142019-11-26 15:01:03.332|1543|INFO|[example-server-book-service,28f019d57b8336ab,630697c7f34ca4fa,105,45982043|XNIO-1 task-42]|c.p.f.w.logging.AccessLoggingFilter : &gt; url: http://liweichao.com:10011/actuator/health&gt; http-method: GET&gt; request-header: [Accept:&quot;text/plain, text/*, */*&quot;, Connection:&quot;close&quot;, User-Agent:&quot;Consul Health Check&quot;, Host:&quot;liweichao.com:10011&quot;, Accept-Encoding:&quot;gzip&quot;]&gt; request-time: 2019-11-26 15:01:03.309&gt; querystring: -&gt; payload: -&gt; extra-param: - &lt; response-time: 2019-11-26 15:01:03.332&lt; take-time: 23&lt; http-status: 200&lt; response-header: [content-type:&quot;application/vnd.spring-boot.actuator.v2+json;charset=UTF-8&quot;, content-size:&quot;15&quot;]&lt; response-data: &#123;&quot;status&quot;:&quot;UP&quot;&#125; 特定格式日志可按格式创建索引更方便聚焦查询分析和告警，如根据 take-time，http-status，biz-code 等值。 作者：猿天地 链接：https://juejin.im/post/6844904030330683405 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k8s-servicedns]]></title>
    <url>%2F2019%2F07%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E5%B7%A5%E5%85%B7%2Fk8s-servicedns%2F</url>
    <content type="text"><![CDATA[在集群NODE中解析Kuebernetes service域名 只要将core DNS的cluster IP加入到/etc/resolv.conf 即可。但注意，重启系统会根据网卡重写/etc/resolv.conf]]></content>
      <categories>
        <category>k8s/docker</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shared_memory]]></title>
    <url>%2F2019%2F04%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2FLinux%2F%E5%86%85%E6%A0%B8%2Fshared-memory%2F</url>
    <content type="text"><![CDATA[[转]C/C++经典案例：Linux难点分析之共享内存shm和mmap的比较 共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过mmap()映射普通文件(特殊情况下还可以采用匿名映射)机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号灯等同步机制共同使用。 1. mmap的机制如：就是在磁盘上建立一个文件，每个进程存储器里面，单独开辟一个空间来进行映射。如果多进程的话，那么不会对实际的物理存储器(主存)消耗太大。 2. shm的机制：每个进程的共享内存都直接映射到实际物理存储器里面。 mmap函数是unix/linux下的系统调用，来看《Unix Netword programming》卷二12.2节有详细介绍。 mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。 mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再 调用read()，write()等操作。mmap并不分配空间, 只是将文件映射到调用进程的地址空间里, 然后你就可以用memcpy等操作写文件, 而不用write()了.写完后用msync()同步一下, 你所写的内容就保存到文件里了. 不过这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了. 简单说就是把一个文件的内容在内存里面做一个映像，内存比磁盘快些。 总结： 1、mmap有两种方式，一种是映射内存，它把普通文件映射为实际物理内存页，访问它就和访问物理内存一样(这也就和shm的功能一样了)(同时不用刷新到文件) 2、mmap可以映射文件，不确定会不会像windows“内存映射文件”一样的功能，如果是，那么他就能映射好几G甚至好几百G的内存数据，对大数据处理将提供强大功能了。 3、shm只做内存映射，和mmap第一个功能一样!只不过不是普通文件而已，但都是物理内存。 本文版权归黑马程序员C/C++学院所有，欢迎转载，转载请注明作者出处。谢谢！ 作者：黑马程序员C/C++培训学院 首发：http://c.itheima.com/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux, 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[optimize_program]]></title>
    <url>%2F2019%2F04%2F17%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FPrograming%2Foptimize-program%2F</url>
    <content type="text"><![CDATA[Tips for program optimization 编码优化 恰当的使用 inline来减少函数调用造成的开销。 消除连续的重复调用，将结果固定的重复计算移出循环体。如：数组的size() 消除不必要的内存访问，如:将结果存在一个临时变量中，结果计算完成后一次性写入到内存 结构化优化 通过交换、组合或分配等方式，减少耗时操作(如：乘除法)的计算次数。 采用循环展开(loop unrolling)技术，循环展开在2方面提升了程序性能： 减少条件判断和循环计数计算的操作数量 可以合并一些相关操作，减少关键路径上的操作数量。 利用处理器流水线特性，分离操作，使其能够在流水线中并行。 在分支语句中使用特性，并尽量使得判断条件在大多数情况下成立，减少分支预测错误带来的惩罚。 保持你的代码cache friendly,例：尽管查找树等数据结构算法复杂度更低，但考虑到cache的存在，数组等顺序储存结构的整体性能可能会更高。 并发优化]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++内存模型]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fc-mamorymodel%2F</url>
    <content type="text"><![CDATA[问题引入 乱序 说到内存模型，首先需要明确一个普遍存在，但却未必人人都注意到的事实：程序通常并不是总按着照源码中的顺序一一执行，此谓之乱序，乱序产生的原因可能有好几种： 编译器出于优化的目的，在编译阶段将源码的顺序进行交换。 程序执行期间，指令流水被 cpu 乱序执行。 inherent cache 的分层及刷新策略使得有时候某些写读操作的从效果上看，顺序被重排。 从乱序的种类来看分为以下四类： 写写乱序(store store), 前面的写操作被放到了后面的操作之后，比如： 12345a = 3;b = 4;被乱序为：b = 4;a = 3; 写读乱序(store load)，前面的写操作被放到了后面的读操作之后，比如： 12345a = 3;load(b);被乱序为load(b);a = 3; 读读乱序(load load)， 前面的读操作被放到了后一个读操作之后，比如： 12345load(a);load(b);被乱序为：load(b);load(a); 读写乱序(load store), 前面的读操作被放到了后一个写操作之后，比如： 12345load(a);b = 4;被乱序为：b = 4;load(a); 程序的乱序在单线程的世界里多数时候并没有引起太多引人注意的问题，但在多线程的世界里，这些乱序就制造了特别的麻烦，究其原因，最主要的有2个： 并发不能保证修改和访问共享变量的操作原子性，使得一些中间状态暴露了出去，因此像 mutex，各种 lock 之类的东西在写多线程时被频繁地使用。 变量被修改后，该修改未必能被另一个线程及时观察到，因此需要“同步”。 解决同步问题就需要确定内存模型，也就是需要确定线程间应该怎么通过共享内存来进行交互(查看维基百科). memory model 内存模型所要表达的内容主要是怎么描述一个内存操作的效果，在各个线程间的可见性的问题。修改操作的效果不能及时被别的线程看见的原因有很多，比较明显的一个是，对计算机来说，通常内存的写操作相对于读操作是昂贵很多很多的，因此对写操作的优化是提升性能的关键，而这些对写操作的种种优化，导致了一个很普遍的现象出现：写操作通常会在 CPU 内部的 cache 中缓存起来。这就导致了在一个 CPU 里执行一个写操作之后，该操作导致的内存变化却不一定会马上就被另一个 CPU 所看到，这从另一个角度讲，效果上其实就是读写乱序了。 1234cpu1 执行如下：a = 3;cpu2 执行如下：load(a); 对如上代码，假设 a 的初始值是 0, 然后 cpu1 先执行，之后 cpu2 再执行，假设其中读写都是原子的，那么最后 cpu2 如果读到 a = 0 也其实不是什么奇怪事情。很显然，这种在某个线程里成功修改了全局变量，居然在另一个线程里看不到效果的后果是很严重的。 因此必须要有必要的手段对这种修改公共变量的行为进行同步。 c++11 中的 atomic library 中定义了以下6种语义来对内存操作的行为进行约定，这些语义分别规定了不同的内存操作在其它线程中的可见性问题： 12345678enum memory_order &#123; memory_order_relaxed, //对其它读写操作没有同步，只保证本操作是原子的 memory_order_consume, //load操作，当前线程依赖该原子变量的访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_acquire, //load操作，当前线程所有访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_release, //store操作，当前线程所有访存操作不能reorder到该指令之后，对其他线程load操作(consume)可见 memory_order_acq_rel, //load/store操作，memory_order_acquire + memory_order_release memory_order_seq_cst //memory_order_acq_rel + 顺序一致性(sequential consisten)&#125;;]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>CPP进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock-Free 编程]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FPrograming%2Flock-free%2F</url>
    <content type="text"><![CDATA[Lock-Free 编程 Lock-Free 编程描述了代码所表述的性质，而没有限定或要求代码该如何编写。一般理解来讲即尽量少的使用LOCK或MUTEX等互斥量或锁，以降低线程间的相互阻塞。可以通过以下框图来判断是否符合lock-free. 从这个意义上来说，Lock-Free 中的 “Lock” 并没有直接涉及 Mutex 或 Lock 等互斥量结构，而是描述了应用程序因某种原因被阻塞的可能性，例如可能因为死锁（DeadLock）、活锁（LiveLock）或线程调度（Thread Scheduling）导致优先级被抢占等。 Lock-Free 编程的一个重要效果就是，在一系列访问 Lock-Free 操作的线程中，如果某一个线程被挂起，那么其绝对不会阻止其他线程继续运行（Non-Blocking）。 通常，应该没有人会期待一个大型的应用程序中全部采用 Lock-Free 技术，应是在有特定需求的类的设计上采用 Lock-Free 技术。例如，如果需要一个 Stack 类应对多线程并发访问的场景，可以使用 Lock-Free 相关技术实现 ConcurrentStack 类，在其 Push 和 Pop 操作中进行具体的实现。在使用 Lock-Free 技术前，需要预先考虑一些软件工程方面的成本： Lock-Free 技术很容易被错误的使用，代码后期的维护中也不容易意识到，所以非常容易引入 Bug，而且这样的 Bug 还非常难定位。 Lock-Free 技术的细节上依赖于内存系统模型、编译器优化、CPU架构等，而这在使用 Lock 机制时是不相关的，所以也增加了理解和维护的难度。 Lock-Free 实现技术 我们要满足 Lock-Free 编程中的非阻塞条件时，有一系列的技术和方法可供使用，如原子操作（Atomic Operations）、内存栅栏（Memory Barrier）、避免 ABA 问题（Avoiding ABA Problem）等。下图提供了一些判断依据： 原子操作(Atomic Operations) 原子操作（Atomic Operations）在操作内存时可以被看做是不可分割的（Indivisible），其他线程不会打断该操作，没有操作只被完成一部分之说。在现代的 CPU 处理器上，很多操作已经被设计为原子的，例如对齐读（Aligned Read）和对齐写（Aligned Write）等。 在C++中可以通过引入来进行原子操作。 RMW 操作在不同的 CPU 家族中是通过不同的方式来支持的。 x86/64 和 Itanium 架构通过 Compare-And-Swap (CAS)方式来实现； PowerPC、MIPS 和 ARM 架构通过Load-Link/Store-Conditional (LL/SC) 方式来实现； Compare-And-Swap 循环（CAS Loops） CAS是由CPU提供的原子操作。 通常开发人员会设计在一个循环中重复地执行 CAS 操作以试图完成一个事务操作。这个过程分为 3 步： 从指定的内存位置读取原始的值； 根据读取到的原始的值计算出新的值； 检测如果内存位置仍然是原始的值时，则将新值写入该内存位置； ABA 问题（ABA Problem） 在实现 CAS Loops 时，当存在多个线程交错地对共享的内存地址进行处理时，如果实现设计的不正确，将有可能遭遇 ABA 问题。 若线程对同一内存地址进行了两次读操作，而两次读操作得到了相同的值，通过判断 “值相同” 来判定 “值没变”。然而，在这两次读操作的时间间隔之内，另外的线程可能已经修改了该值，这样就相当于欺骗了前面的线程，使其认为 “值没变”，实际上值已经被篡改了。 下面是 ABA 问题发生的过程： T1 线程从共享的内存地址读取值 A； T1 线程被抢占，线程 T2 开始运行； T2 线程将共享的内存地址中的值由 A 修改成 B，然后又修改回 A； T1 线程继续执行，读取共享的内存地址中的值仍为 A，认为没有改变然后继续执行； 由于 T1 并不知道在两次读取的值 A 已经被 “隐性” 的修改过，所以可能产生无法预期的结果。 例如，使用 List 来存放 Item，如果将一个 Item 从 List 中移除并释放了其内存地址，然后重新创建一个新的 Item，并将其添加至 List 中，由于优化等因素，有可能新创建的 Item 的内存地址与前面删除的 Item 的内存地址是相同的，导致指向新的 Item 的指针因此也等同于指向旧的 Item 的指针，这将引发 ABA 问题。 内存模型 在多线程系统中，当多个线程同时访问共享的内存时，就需要一个规范来约束不同的线程该如何与内存交互，这个规范就称之为内存模型（Memory Model）。 在传统的C中，需要通过内存栅栏(memory barrier)的方式，在指令间插入内存栅栏来保证内存访问和修改的执行顺序。 在C++11中提供了memoryorder的支持来支持跨平台内存模型规范。详见另一篇博文。]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++多线程]]></title>
    <url>%2F2019%2F04%2F09%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fc-thread%2F</url>
    <content type="text"><![CDATA[thread 类 &lt;thread&gt;：头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在这个头文件中。 std::thread 构造函数 (1)默认构造函数：创建一个空的 thread 执行对象。 (2) 初始化构造函数：创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。 (3)拷贝构造函数(被禁用)：意味着 thread 不可被拷贝构造。 (4)move 构造函数，move 构造函数：调用成功之后 x 不代表任何 thread 执行对象。 joinable thread thread 类中提供了一个成员函数bool jionable() 用于检测线程是否joinable joinable ： 代表该线程是可结合的线程。如果线程处于joinable状态，则只能只能被创建他的线程等待终止。 **not-joinable ：**通常一下几种情况会导致线程成为not-joinable 由thread的缺省构造函数构造而成(thread()没有参数)。 该thread被move过（包括move构造和move赋值, 原thread被销毁) 该线程调用过join或者detach join and detach 创建一个线程之后，我们还需要考虑一个问题：该如何处理这个线程的结束？ 一种方式是等待这个线程结束，在一个合适的地方调用 thread 实例的 join() 方法，调用者线程将会一直等待着目标线程的结束，当目标线程结束之后调用者线程继续运行； 另一个方式是将这个线程分离，由其自己结束，通过调用 thread 实例的 detach() 方法将目标线程置于分离模式。 move and swap 1234567891011121314151617#include&lt;thread&gt; using namespace std; int main() &#123; thread t1([]() &#123; cout &lt;&lt; "thread1" &lt;&lt; endl; &#125;); cout &lt;&lt; "thread1' id is " &lt;&lt; t1.get_id() &lt;&lt; endl; thread t2 = move(t1);; cout &lt;&lt; "thread2' id is " &lt;&lt; t2.get_id() &lt;&lt; endl; return 0; &#125; 运行结果: thread1 thread1' id is 5620 thread2' id is 5620 可以看到，线程t2可以通过 move 移动 t1 来获取 t1 的全部属性，而 t1 却销毁了。 使用swap也有同样移动的效果： 1234567891011121314151617181920212223242526272829#include&lt;thread&gt; using namespace std; int main() &#123; thread t1([]() &#123; cout &lt;&lt; "thread1" &lt;&lt; endl; &#125;); thread t2([]() &#123; cout &lt;&lt; "thread2" &lt;&lt; endl; &#125;); cout &lt;&lt; "thread1' id is " &lt;&lt; t1.get_id() &lt;&lt; endl; cout &lt;&lt; "thread2' id is " &lt;&lt; t2.get_id() &lt;&lt; endl; cout &lt;&lt; "swap after:" &lt;&lt; endl; swap(t1, t2);//线程交换 cout &lt;&lt; "thread1' id is " &lt;&lt; t1.get_id() &lt;&lt; endl; cout &lt;&lt; "thread2' id is " &lt;&lt; t2.get_id() &lt;&lt; endl; return 0; &#125; 运行结果: thread1 thread2 thread1' id is 4836 thread2' id is 4724 swap after: thread1' id is 4724 thread2' id is 4836 这两种的不同是swap仅仅进行实例（以 id 作标识）的互换，而move则在进行实例标识的互换之前，还进行了转移目的实例（如之前的t2）的清理（通过调用std::terminate()）。 yeild and sleep 123456//让线程等待3秒 this_thread::sleep_for(chrono::seconds(3)); //让线程等待直到到达指定时间this_thread::sleep_until (time);//让cpu执行其他空闲的线程 this_thread::yield(); mutex Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 &lt;mutex&gt; 头文件中。 std::mutex用法 构造函数:std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。 lock():调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况： 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 unlock() 解锁，释放对互斥量的所有权。 try_lock() 尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况: 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 std::recursive_mutex recursive_mutex 与 mutex相同，唯一不同的是**std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，相对应的std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()。** std::time_mutex time_mutex相较于mutex提供了2个新的方法来进行时间相关的上锁： try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 同样的也有对应的recursive_timed_mutex来提供递归上锁。 lock类 std::lock_guard std::lock_gurad 是 C++11 中定义的模板类。定义如下： ​ template &lt;class Mutex&gt; class lock_guard; lock_guard 对象通常用于管理某个锁(Lock)对象，与 Mutex RAII 相关，方便线程对互斥量上锁，即在某个 lock_guard 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 lock_guard 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 shared_ptr 等智能指针管理动态分配的内存资源)。 模板参数 Mutex 代表互斥量类型，例如 std::mutex 类型，它应该是一个基本的 BasicLockable 类型，标准库中定义几种基本的 BasicLockable 类型，分别 std::mutex, std::recursive_mutex, std::timed_mutex，std::recursive_timed_mutex以及 std::unique_lock。 在 lock_guard 对象构造时，传入的 Mutex 对象(即它所管理的 Mutex 对象)会被当前线程锁住。在lock_guard 对象被析构时，它所管理的 Mutex 对象会自动解锁，由于不需要程序员手动调用 lock 和 unlock 对 Mutex 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。 构造函数： locking 初始化 :std::lock_guard&lt;std::mutex&gt; lck(mtx); lock_guard 对象管理 Mutex 对象 m，并在构造时对 m 进行上锁（调用 m.lock()）。 adopting初始化:std::lock_guard&lt;std::mutex&gt; lck(mtx, std::adopt_lock); lock_guard 对象管理 Mutex 对象 m，与 locking 初始化不同的是， Mutex 对象 m 已被当前线程锁住。 拷贝构造: lock_guard对象的拷贝构造和移动构造(move construction)均被禁用，因此 lock_guard 对象不可被拷贝构造或移动构造 std::unique_lock C++11 标准中定义了另外一个与 Mutex RAII 相关类 unique_lock，该类与 lock_guard 类相似，也很方便线程对互斥量上锁，但它提供了更好的上锁和解锁控制。 unique_lock 对象以独占所有权的方式（ unique owership）管理 mutex 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权。 在构造(或移动(move)赋值)时，unique_lock 对象需要传递一个 Mutex 对象作为它的参数，新创建的 unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作。 std::unique_lock 对象也能保证在其自身析构时它所管理的 Mutex 对象能够被正确地解锁（即使没有显式地调用 unlock 函数） 值得注意的是，unique_lock 对象同样也不负责管理 Mutex 对象的生命周期,在某个 unique_lock 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 unique_lock 的生命周期结束之后，它所管理的锁对象会被解锁，这一点和 lock_guard 类似，但 unique_lock 给程序员提供了更多的自由。 另外，与 lock_guard 一样，模板参数 Mutex 代表互斥量类型，例如 std::mutex 类型，它应该是一个基本的 BasicLockable 类型。 构造函数： 默认构造函数 新创建的 unique_lock 对象不管理任何 Mutex 对象。 locking 初始化 新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.lock() 对 Mutex 对象进行上锁，如果此时另外某个 unique_lock 对象已经管理了该 Mutex 对象 m，则当前线程将会被阻塞。 try-locking 初始化 新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.try_lock() 对 Mutex 对象进行上锁，但如果上锁不成功，并不会阻塞当前线程。 deferred 初始化 新创建的 unique_lock 对象管理 Mutex 对象 m，但是在初始化的时候并不锁住 Mutex 对象。 m 应该是一个没有当前线程锁住的 Mutex 对象。 adopting 初始化 新创建的 unique_lock 对象管理 Mutex 对象 m， m 应该是一个已经被当前线程锁住的 Mutex 对象。(并且当前新创建的 unique_lock 对象拥有对锁(Lock)的所有权)。 locking 一段时间(duration) 新创建的 unique_lock 对象管理 Mutex 对象 m，并试图通过调用 m.try_lock_for(rel_time) 来锁住 Mutex 对象一段时间(rel_time)。 locking 直到某个时间点(time point) 新创建的 unique_lock 对象管理 Mutex 对象m，并试图通过调用 m.try_lock_until(abs_time) 来在某个时间点(abs_time)之前锁住 Mutex 对象。 拷贝构造 [被禁用] unique_lock 对象不能被拷贝构造。 移动(move)构造 新创建的 unique_lock 对象获得了由 x 所管理的 Mutex 对象的所有权(包括当前 Mutex 的状态)。调用 move 构造之后， x 对象如同通过默认构造函数所创建的，就不再管理任何 Mutex 对象了。 综上所述，由 (2) 和 (5) 创建的 unique_lock 对象通常拥有 Mutex 对象的锁。而通过 (1) 和 (4) 创建的则不会拥有锁。通过 (3)，(6) 和 (7) 创建的 unique_lock 对象，则在 lock 成功时获得锁。 atomic std::atomic std::atomic对int, char, bool等数据结构进行原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。 构造函数 默认构造函数 atomic() noexcept = default; 初始化构造函数 constexpr atomic (T val) noexcept; 拷贝构造函数 atomic (const atomic&amp;) = delete。可以看出atomic对象是不可复制的。 由上可知，atomic对象可以用其内部存储类型赋值，但是atomic本身是不能进行赋值拷贝的。 atomic经常用的函数有store和load，如下： store函数 12void store (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;void store (T val, memory_order sync = memory_order_seq_cst) noexcept; 其实就是用val替换内部保存的值。内部替换的时候其实是加了线程同步的，所以不用担心多线程访问的问题。 load函数 12T load (memory_order sync = memory_order_seq_cst) const volatile noexcept;T load (memory_order sync = memory_order_seq_cst) const noexcept; 返回内部保存的值，其实就是访问内部值。 std::atomic_flag atomic_flag是一个原子布尔类型。不同于std::atomic的所有专门化，它保证是lock_free。不像std::stomic&lt; bool &gt;，std::atomic_flag不提供负载或存储操作。 构造函数 atomic_flag在构建(或设置或清除)上处于一个未指定的状态，除非它被显式地初始化为ATOMIC_FLAG_INIT。 atomic_flag值不能复制/移动。 成员函数：test_and_set bool test_and_set (memory_order sync = memory_order_seq_cst) volatile noexcept; bool test_and_set (memory_order sync = memory_order_seq_cst) noexcept;。 设置atomic_flag并返回是否在调用之前已经设置的。 整个操作是原子的(一个原子的读-修改-写操作):当在这个函数被修改的时候,读取的(返回)值被读取，值不受其他线程的影响。 成员函数:atomic_flag_clear void clear (memory_order sync = memory_order_seq_cst) volatile noexcept; void clear (memory_order sync = memory_order_seq_cst) noexcept; 清除atomic_flag(即把atomic_flag 设为假)。清除atomic_flag使下一次调用成员atomic_flag::test_and_set对象返回false。 操作是原子的，按照sync所指定的内存顺序。 future std::promise promise 对象可以保存某一类型T值，该值可被 future 对象读取（可能在另外一个线程中）， promise 提供了一种线程同步的手段。 在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值。 可以通过 get_future 来获取与该 promise 对象相关联的 future 对象，调用该函数之后，两个对象共享相同的共享状态(shared state) promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值。 future 对象可以异步返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标志变为 ready，然后才能获取共享状态的值。 12345678910111213141516171819202122232425// promise example #include &lt;iostream&gt; // std::cout #include &lt;functional&gt; // std::ref #include &lt;thread&gt; // std::thread #include &lt;future&gt; // std::promise, std::future void print_int(std::future&lt;int&gt;&amp; fut) &#123; int x = fut.get(); std::cout &lt;&lt; "value: " &lt;&lt; x &lt;&lt; std::endl; &#125; int main() &#123; std::promise&lt;int&gt; prom; // create promise std::future&lt;int&gt; fut = prom.get_future(); // engagement with future std::thread th1(print_int, std::ref(fut)); // send future to new thread prom.set_value(10); // fulfill promise // (synchronizes with getting the future) th1.join(); return 0; &#125; promise 只有移动语义没有拷贝语义。 std::promise::get_future：返回一个与promise共享状态相关联的future对象 std::promise::set_value：设置共享状态的值，此后promise共享状态标识变为ready std::promise::set_exception：为promise设置异常，此后promise的共享状态标识变为ready std::promise::set_value_at_thread_exit：设置共享状态的值，但是不将共享状态的标志设置为 ready，当线程退出时该 promise 对象会自动设置为 ready（注意：该线程已设置promise的值，如果在线程结束之后有其他修改共享状态值的操作，会抛出future_error(promise_already_satisfied)异常） std::promise::swap：交换 promise 的共享状态 std::future 简单来说，std::future提供了一种访问异步操作结果的机制。 从字面意思看，它表示未来。通常一个异步操作我们是不能马上就获取操作结果的，只能在未来某个时候获取。我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态： deferred：异步操作还没开始 ready：异步操作已经完成 timeout：异步操作超时 获取future结果有三种方式：get、wait、wait_for: get 等待异步操作结束(ready)并返回结果 wait 只是等待异步操作完成，没有返回值 wait_for 是超时等待返回结果。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>CPP</tag>
        <tag>CPP进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSIsample]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FOSIsample%2F</url>
    <content type="text"><![CDATA[OSI七层结构示意图]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI七层结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux namespace与Cgroup简述]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2FLinux%2F%E5%86%85%E6%A0%B8%2Fnamespace-cgroup%2F</url>
    <content type="text"><![CDATA[NameSpace 概述 Namespace 用于不同进程组之间的资源隔离，其目的是将某个特定的全局系统资源（global system resource）通过抽象方法使得namespace 中的进程看起来拥有它们自己的隔离的全局系统资源实例。 Linux 内核中实现了六种 namespace，按照引入的先后顺序，列表如下： namespace 引入的相关内核版本 被隔离的全局系统资源 在容器语境下的隔离效果 Mount namespaces Linux 2.4.19 文件系统挂接点 每个容器能看到不同的文件系统层次结构 UTS namespaces Linux 2.6.19 nodename 和 domainname 每个容器可以有自己的 hostname 和 domainame PID namespaces Linux 2.6.24 进程 ID 数字空间 （process ID number space） 每个 PID namespace 中的进程可以有其独立的 PID； 每个容器可以有其 PID 为 1 的root 进程；也使得容器可以在不同的 host 之间迁移，因为 namespace 中的进程 ID 和 host 无关了。这也使得容器中的每个进程有两个PID：容器中的 PID 和 host 上的 PID。 IPC namespaces Linux 2.6.19 特定的进程间通信资源，包括System V IPC 和 POSIX message queues 每个容器有其自己的 System V IPC 和 POSIX 消息队列文件系统，因此，只有在同一个 IPC namespace 的进程之间才能互相通信 Network namespaces 始于Linux 2.6.24 完成于 Linux 2.6.29 网络相关的系统资源 每个容器用有其独立的网络设备，IP 地址，IP 路由表，/proc/net 目录，端口号等等。这也使得一个 host 上多个容器内的同一个应用都绑定到各自容器的 80 端口上。 User namespaces 始于 Linux 2.6.23 完成于 Linux 3.8) 用户和组 ID 空间 在 user namespace 中的进程的用户和组 ID 可以和在 host 上不同； 每个 container 可以有不同的 user 和 group id；一个 host 上的非特权用户可以成为 user namespace 中的特权用户； Cgroup概述 在Linux里，一直以来就有对进程进行分组的概念和需求，比如session group， progress group等，后来随着人们对这方面的需求越来越多，比如需要追踪一组进程的内存和IO使用情况等，于是出现了cgroup,主要有两大用途: 用来统一将进程进行分组。 在分组的基础上对进程进行监控和资源控制管理等。 cgroup是Linux下的一种将进程按组进行管理的机制，在用户层看来，cgroup技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个subsystem关联，树的作用是将进程分组，而subsystem的作用就是对这些组进行操作。cgroup主要包括下面两部分： subsystem 一个subsystem就是一个内核模块，他被关联到一颗cgroup树之后，就会在树的每个节点（进程组）上做具体的操作。subsystem经常被称作&quot;resource controller&quot;，因为它主要被用来调度或者限制每个进程组的资源，但是这个说法不完全准确，因为有时我们将进程分组只是为了做一些监控，观察一下他们的状态，比如perf_event subsystem。 hierarchy 一个hierarchy可以理解为一棵cgroup树，树的每个节点就是一个进程组，每棵树都会与零到多个subsystem关联。在一颗树里面，会包含Linux系统中的所有进程，但每个进程只能属于一个节点（进程组）。系统中可以有很多颗cgroup树，每棵树都和不同的subsystem关联，一个进程可以属于多颗树，即一个进程可以属于多个进程组，只是这些进程组和不同的subsystem关联。目前Linux支持12种subsystem，如果不考虑不与任何subsystem关联的情况（systemd就属于这种情况），Linux里面最多可以建12颗cgroup树，每棵树关联一个subsystem，当然也可以只建一棵树，然后让这棵树关联所有的subsystem。当一颗cgroup树不和任何subsystem关联的时候，意味着这棵树只是将进程进行分组，至于要在分组的基础上做些什么，将由应用程序自己决定，systemd就是一个这样的例子。 到目前为止，Linux支持12种subsystem，比如限制CPU的使用时间，限制使用的内存，统计CPU的使用情况，冻结和恢复一组进程等。 subsystemID 引入的相关内核版本 提供效果 cpu Linux 2.6.24; CONFIG_CGROUP_SCHED 用来限制cgroup的CPU使 cpuacct Linux 2.6.24; CONFIG_CGROUP_CPUACCT 统计cgroup的CPU的使用率。 cpuset Linux 2.6.24; CONFIG_CPUSETS 绑定cgroup到指定CPUs和NUMA节点。 memory Linux 2.6.25; CONFIG_MEMCG 统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。 devices Linux 2.6.26; CONFIG_CGROUP_DEVICE 限制cgroup创建(mknod)和访问设备的权限。 freezer Linux 2.6.28; CONFIG_CGROUP_FREEZER suspend和restore一个cgroup中的所有进程。 net_cls Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID 将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。 blkio Linux 2.6.33; CONFIG_BLK_CGROUP 限制cgroup访问块设备的IO速度。 perf_event Linux 2.6.39; CONFIG_CGROUP_PERF 对cgroup进行性能监控 net_prio Linux 3.3; CONFIG_CGROUP_NET_PRIO 针对每个网络接口设置cgroup的访问优先级。 hugetlb Linux 3.5; CONFIG_CGROUP_HUGETLB 限制cgroup的huge pages的使用量。 pids Linux 4.3; CONFIG_CGROUP_PIDS 限制一个cgroup及其子孙cgroup中的总进程数。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux, container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ trivial类型]]></title>
    <url>%2F2019%2F03%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fc-trivial%2F</url>
    <content type="text"><![CDATA[Trival类型 最近在看《STL源码剖析》时看到对于Trival和POD类型，模板会有相应的特化，对于Trival类型的操作不需逐个调用构造函数和析构函数。但是不清楚Trival的含义，因此查了一下。 A trivially copyable class is a class that: — has no non-trivial copy constructors (12.8), — has no non-trivial move constructors (12.8), — has no non-trivial copy assignment operators (13.5.3, 12.8), — has no non-trivial move assignment operators (13.5.3, 12.8), and — has a trivial destructor (12.4). A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable. [ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes.—end note ] 其他要求： ①没有虚成员（不含虚函数以及虚基类） ②没有类内初始化的非静态数据成员 ③如果它拥有基类或者非静态成员，它们也应该是trivial的 trivial constructor and trivial destructor trivial构造函数即构造函数“什么都不干”。通常情况下，不定义类的构造函数，编译器就会为我们生成一个平凡的默认构造函数。但如果该类含有虚函数或者数据成员没有默认构造函数，编译器是不会为我们生成trivial的默认构造函数的。析构函数也是一样的道理。 trivial copy constructor and trivial copy constructor trivial 拷贝构造函数基本上等同于memcpy进行类型的构造。同trivial 构造函数一样，编译器在用户不提供的情况下，通常会提供trivial 拷贝构造函数。 trivial 移动构造函数执行的操作与trivial 拷贝构造函数相同，都是bytewise的拷贝，只是用于移动语义。 详细请看]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>CPP进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[copy_move_constractor]]></title>
    <url>%2F2019%2F03%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fcopy-move-constractor%2F</url>
    <content type="text"><![CDATA[拷贝构造函数和拷贝赋值函数 12345678910//拷贝构造函数A(const A&amp; t)&#123; ...&#125;//拷贝赋值运算符A&amp; operator=(const A&amp; rhs)&#123; ...&#125; 拷贝构造函数只在对象实例化时才会被调用，也就是说，在复制构造函数调用期间，这个对象处于一个未决状态（直到复制构造函数被成功调用），另外拷贝构造函数不返回任何值。 拷贝构造函数应用的场合有以下几个方面： 1 函数的参数是一个对象，并且是值传递方式 2 函数的返回值是一个对象，并且是值传递方式 3 用一个对象初始化另外一个对象 赋值运算符则在一个现存的对象被赋予新的值时被调用，并且它有返回值。 123456789Test test; //实例化test对象时调用了默认构造函数Test test1=test;// test1使用了复制构造函数（因为这是一个新的对象产生）Test test2(test);//test2时也是用了复制构造函数，Test test3=test2=test1;//而test2=test1则使用了赋值构造函数（没有新的对象产生），Test test3=test2=test1;//test3=test2则使用了复制构造函数，原因同上。 移动构造函数和移动赋值函数 12345678910//移动构造函数A(A&amp;&amp; t)&#123; ...&#125;//移动赋值运算符A&amp; operator=(A&amp;&amp; rhs)&#123; ...&#125; 要实现转移语义，需要定义转移构造函数，当然还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么拷贝构造函数和赋值操作符会被调用。 两者区别与拷贝构造函数和赋值运算符的区别相同，这里不再赘述。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>知识辨析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++命名空间]]></title>
    <url>%2F2019%2F03%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fc-namespace%2F</url>
    <content type="text"><![CDATA[一、命名空间 **命名空间:**实际上就是一个由程序设计者命名的内存区域，程序设计者可以根据需要指定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开来。 123namespace n1&#123; ...&#125; 命名冲突：只有同一个名字空间中同一作用域下，相同的名字才会冲突。所以要解决冲突无非就是修改名字空间或者作用域。 首先说修改作用域，在C中，文件作用域的标识符有一个链接属性，static修饰的，的作用域仅仅限于本.c文件，而extern（或者默认情况下）作用域是所有.c文件，所以我们可以个其中一个conan加上static修饰，这样就改变了作用域，就不会冲突了，但是问题是，我们既然定义成全局变量，通常情况下，我们都希望它有外部链接属性。我们之所以定义成全局变量，很可能就是为了让其他.c文件使用。所以static虽然解决了冲突，但是没有达到我们的目的。 那么我们只能够用另一种方法解决冲突了，就是修改名字空间，这在C语言中是不可行的，但是在C中是可行的，因为C可以自定义名字空间。 二、嵌套名字空间 1. 普通嵌套名字空间 一个嵌套名字空间就是一个嵌套作用域，其作用域嵌套在包含他的名字空间中。 在外部引用嵌套空间中的成员时,使用下面的形式 1包含嵌套空间的名字空间的名字::嵌套空间的名字::嵌套空间的成员 2. 内联嵌套名字空间 C++11中，新增inline namespace，指示命名空间中的名称同时是外层命名空间直接包含的名称。这便于命名空间的版本管理，减少冲突。 inline描述符使得内联命名空间中的声明看起来就好像是直接在外围的命名空间中进行声明的一样。（使用inline关键字定义的内联名字空间成为默认名字空间。） inline描述符由命名空间的设计者放置，即命名空间的作者可以通过放置inline描述符来表示当前最新的命名空间是哪个. 三、全局命名空间 全局命名空间是隐式声明的,存在于每个程序中。在全局作用域定义实体的每个文件将那些名字加到全局命名空间。 可以用作用域操作符引用全局命名空间的成员。因为全局命名空间是隐含的,它没有名字, 所以使用记号如下方法引用全局命名空间的成员。 1::member_name 四、匿名名字空间 命名空间可以是未命名的,未命名的命名空间在定义时没有给定名字。其定义方法如下： 1234namespace //No name&#123; //members....&#125; 未命名的命名空间与其他命名空间不同,未命名的命名空间的定义局部于特定文件,从不跨越多个文本文件。 未命名的命名空间可以在给定文件中不连续,但不能跨越文件,每个文件有自己的未命名的命名空间。 未命名的命名空间用于声明局部于文件的实体。在未命名的命名空间中定义的变量在程序开始时创建,在程序结束之前一直存在。 未命名的命名空间中定义的名字可直接使用,因为没有命名空间名字来限定它们。 由以上特性，未命名的命名空间可以取代文件中的静态声明 在标准 C++ 中引入命名空间之前,程序必须将名字声明为static,使它们的作用域约束于一个文件中。 文件中静态声明的方法是从 C 语言继承而来, C++ 不赞成文件静态声明，因为这可能在未来版本中不支持。 所以应该避免文件静态而使用未命名空间代替。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>CPP基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类内存结构]]></title>
    <url>%2F2019%2F03%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fc-classmemory%2F</url>
    <content type="text"><![CDATA[原文地址]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[goole styleguide 学习笔记]]></title>
    <url>%2F2019%2F03%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fstyleguide-note%2F</url>
    <content type="text"><![CDATA[一、头文件 1.1. Self-contained 头文件 所有.h头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。 不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 .inc 文件扩展名。 1.2. #define 保护 所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ . 1.3. 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 前置声明有一些优点，也有一些缺点： 优点： 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。 很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义： 12345678910&gt; &gt; // b.h:&gt; &gt; struct B &#123;&#125;;&gt; &gt; struct D : B &#123;&#125;;&gt; &gt; &gt; &gt; // good_user.cc:&gt; &gt; #include "b.h"&gt; &gt; void f(B*);&gt; &gt; void f(void*);&gt; &gt; void test(D* x) &#123; f(x); &#125; // calls f(B*)&gt; &gt; 如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) . 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂. **注意：**前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。 1.4. 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 在通常情况下虚函数和递归函数即使声明为内联也不一定会被编译器内联。 包含循环或switch的函数内联往往得不偿失。 析构函数由于有隐含成员和基类虚构调用的关系，因此往往比想象的长，内联需谨慎。 1.5. #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 对应头文件 -&gt; C 库 -&gt; C++ 库 -&gt; 其他库的 .h -&gt; 本项目内的 .h. 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录). 例如, google-awesome-project/src/base/logging.h 应该按如下方式包含: 1#include "base/logging.h" 二、作用域 1.命名空间 鼓励在 .cc 文件内使用匿名命名空间或 static 声明。 使用具名的命名空间时, 其名称可基于项目名或相对路径。 禁止使用 using 指示（using-directive）。 禁止使用内联命名空间（inline namespace）。 遵守 命名空间命名 中的规则。 像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。 123456789101112131415161718192021// .h 文件namespace mynamespace &#123;// 所有声明都置于命名空间中// 注意不要使用缩进class MyClass &#123; public: ... void Foo();&#125;;&#125; // namespace mynamespace// .cc 文件namespace mynamespace &#123;// 函数定义都置于命名空间中void MyClass::Foo() &#123; ...&#125;&#125; // namespace mynamespace 不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件. 不要在头文件中使用 命名空间别名 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。 1234567891011121314// 在 .cc 中使用别名缩短常用的命名空间namespace baz = ::foo::bar::baz;// 在 .h 中使用别名缩短常用的命名空间namespace librarian &#123;namespace impl &#123; // 仅限内部使用namespace sidetable = ::pipeline_diagnostics::sidetable;&#125; // namespace implinline void my_inline_function() &#123; // 限制在一个函数中的命名空间别名 namespace baz = ::foo::bar::baz; ...&#125;&#125; // namespace librarian 2. 匿名命名空间和静态变量 在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。但是不要在 .h 文件中这么做。 3.非成员函数、静态成员函数和全局函数 使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数… 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间。 4.局部变量 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化. 有一例外： 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低. 1234567891011// 低效的实现for (int i = 0; i &lt; 1000000; ++i) &#123; Foo f; // 构造函数和析构函数分别调用 1000000 次! f.DoSomething(i);&#125;//高效的实现Foo f; // 构造函数和析构函数只调用 1 次for (int i = 0; i &lt; 1000000; ++i) &#123; f.DoSomething(i);&#125; 5. 静态和全局变量 禁止定义静态储存周期非POD变量(POD : Plain Old Data 原生数据类型) 禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。 TODO:这部分还看不太明白 三、类 1. 构造函数职责 不要在构造函数中调用虚函数。 不要在构造函数中尝试报告一个非致命错误。如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 Init() 方法或工厂函数. 2. 隐式类型转化 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字. 接受一个 std::initializer_list 作为参数的构造函数也应当省略 explicit, 以便支持拷贝初始化 (例如 MyType m = {1, 2};) . 拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换. 3. 可拷贝类型和可移动类型 除非你的类型需要才让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用. 123// MyClass is neither copyable nor movable.MyClass(const MyClass&amp;) = delete;MyClass&amp; operator=(const MyClass&amp;) = delete; 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义。 如果让类型可移动，那么就给出移动的两个操作 (移动构造函数和赋值操作) 的定义. 12345678class Foo &#123; public: Foo(Foo&amp;&amp; other) : field_(other.field) &#123;&#125; // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符. private: Field field_;&#125;; 4. 结构体VS类 仅当只有数据成员时使用 struct, 其它一概使用 class. 如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class. 5. 继承 使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承. 所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式. 6. 多重继承 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类 7. 接口 当一个类满足以下要求时, 称之为纯接口，这些类以 Interface 为后缀: 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数). 没有非静态数据成员. 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected. 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承. 8.运算符重载 只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, | 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道. 建议不要将不进行修改的二元运算符定义为成员函数. 不要引入用户定义字面量。 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的。 例如, 如果你重载了 &lt;, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数, &lt; 和 &gt; 不会同时返回 true. 9. 存取控制 将 所有 数据成员声明为 private, 除非是 static const 类型成员 10. 说明顺序 类定义应以 public: 开始, 后跟 protected:, 最后是 private:. 省略空部分. 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数,赋值运算符, 析构函数, 其它函数, 数据成员. 不要将大段的函数定义内联在类定义中. 只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 四、函数 1.参数顺序 函数的参数顺序为: 输入参数在先, 后跟输出参数. 输入参数通常是值参或 const 引用, 输出参数或输入/输出参数则一般为非 const 指针. 2.编写简短函数 果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割. 3. 引用参数 函数参数列表中, 所有引用参数都必须是 const 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap(). 这实际上是Google codestyle 的一个硬性约定 4. 函数重载 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数. 5. 缺省参数 只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. . (例如, 不要写像 void f(int n = counter++); 这样的代码.) 对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作 6. 函数返回类型后置语法 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法. 五、命名约定 1.变量 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_. 123456789101112131415161718string table_name; // 好 - 用下划线.string tablename; // 好 - 全小写.string tableName; // 差 - 混合大小写class TableInfo &#123; ... private: string table_name_; // 好 - 后加下划线. string tablename_; // 好. static Pool&lt;TableInfo&gt;* pool_; // 好.&#125;;struct UrlTableProperties &#123; string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool;&#125;; 2.常量命名 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:const int kDaysInAWeek = 7; 4.类型命名 类型名称采用驼峰式命名, 不包含下划线: MyExcitingClass, MyExcitingEnum. 5.宏命名 尽量不要使用宏 如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 6.枚举命名 枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME. 7. 函数命名 常规函数使用驼峰式命名。 例如： MyExcitingFunction(), MyExcitingMethod(), 取值和设值函数要与变量名匹配，并采用下划线连接 例如： ``my_exciting_member_variable(),set_my_exciting_member_variable()`. 8. 命名空间命名 命名空间以小写字母命名。 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突。 顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字。 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中。 9.文件命名 文件名要全部小写。 可以依照项目的约定包含下划线 (_) 或连字符 (-)。如果没有约定, 那么 “_” 更好。 C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾。 不要使用已经存在于 /usr/include 下的文件名。 通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好。 内联函数定义必须放在 .h 文件中。 复杂的内联函数的定义, 可以放在后缀名为 -inl.h 的头文件中。 六、注释 1.文件注释 在每一个文件开头加入版权公告. 文件注释描述了该文件的内容。 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释。除此之外的其他文件都需要文件注释. 2.类注释 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显. 12345678910// Iterates over the contents of a GargantuanTable.// Example:// GargantuanTableIterator* iter = table-&gt;NewIterator();// for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) &#123;// process(iter-&gt;key(), iter-&gt;value());// &#125;// delete iter;class GargantuanTableIterator &#123; ...&#125;; 3.函数注释 函数声明处的注释描述函数功能; 定义处的注释描述函数实现. 函数声明处注释的内容: 函数的输入输出. 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 函数是否分配了必须由调用者释放的空间. 参数是否可以为空指针. 是否存在函数使用上的性能隐患. 如果函数是可重入的, 其同步前提是什么? 函数定义处注释： 如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 如果函数参数的意义不明显，可采用以下方式： 如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破。 考虑更改函数的签名, 让某个 bool 类型的参数变为 enum 类型, 这样可以让这个参数的值表达其意义。 如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例。 用具名变量代替大段而复杂的嵌套表达式。 万不得已时, 才考虑在调用点用注释阐明参数的意义。 例： 12345ProductOptions options;options.set_precision_decimals(7);options.set_use_cache(ProductOptions::kDontUseCache);const DecimalNumber product = CalculateProduct(values, options, /*completion_callback=*/nullptr); 4. 变量注释 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明. 类数据成员 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途。 如果有变量的抽象属性(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释。 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释. 全局变量 和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因。 5.代码注释 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释. 代码前注释 巧妙或复杂的代码段前要加注释. 比如: 1234567// Divide result by two, taking into account that x// contains the carry from the add.for (int i = 0; i &lt; result-&gt;size(); i++) &#123; x = (x &lt;&lt; 8) + (*result)[i]; (*result)[i] = x &gt;&gt; 1; x &amp;= 1;&#125; 行注释 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如: 123456789101112DoSomething(); // Comment here so the comments line up.DoSomethingElseThatIsLonger(); // Two spaces between the code and the comment.&#123; // One space before comment when opening a new scope is allowed, // thus the comment lines up with the following comments and code. DoSomethingElse(); // Two spaces before line comments normally.&#125;std::vector&lt;string&gt; list&#123; // Comments in braced lists describe the next element... "First item", // .. and should be aligned appropriately."Second item"&#125;;DoSomething(); /* For trailing block comments, one space is fine. */ 6.TODO注释与弃用注释 TODO注释要使用全大写的字符串TODO, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一TODO` 相关的 issue。 您可以写上包含全大写的 DEPRECATED 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行。 在 DEPRECATED 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识。 七、格式 1. 一些普遍格式 每一行代码字符数不超过 80列。 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码。 只使用空格, 每次缩进 2 个空格。 变量初始化用 =, () 和 {} 均可。 预处理指令不要缩进, 从行首开始。 水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白。 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行. 2. 函数声明与定义 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行。 如果同一行文本太多, 放不下所有参数: 12345ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) &#123; DoSomething(); ...&#125; 甚至连第一个参数都放不下: 1234567ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) &#123; DoSomething(); // 2 space indent ...&#125; 注意以下几点: 使用好的参数名. 只有在参数未被使用或者其用途非常明显时, 才能省略参数名. 如果返回类型和函数名在一行放不下, 分行. 如果返回类型与函数声明或定义分行了, 不要缩进. 左圆括号总是和函数名在同一行. 函数名和左圆括号间永远没有空格. 圆括号与参数间没有空格. 左大括号总在最后一个参数同一行的末尾处, 不另起新行. 右大括号总是单独位于函数最后一行, 或者与左大括号同一行. 右圆括号和左大括号间总是有一个空格. 所有形参应尽可能对齐. 缺省缩进为 2 个空格. 换行后的参数保持 4 个空格的缩进. 不要在 return 表达式里加上非必须的圆括号。 3.Lambda表达式 Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开。 若用引用捕获, 在变量名和 &amp; 之间不留空格. 12int x = 0;auto add_to_x = [&amp;x](int n) &#123; x += n; &#125;; 4.函数调用 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里. 如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格： 12bool retval = DoSomething(averyveryveryverylongargument1, argument2, argument3); 参数也可以放在次行, 缩进四格： 12345678if (...) &#123; ... ... if (...) &#123; DoSomething( argument1, argument2, // 4 空格缩进 argument3, argument4); &#125; 如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数： 12int my_heuristic = scores[x] * y + bases[x];bool retval = DoSomething(my_heuristic, x, y, z); 或者放着不管, 补充上注释： 12bool retval = DoSomething(scores[x] * y + bases[x], // Score heuristic. x, y, z); 5.条件语句 1234567if (condition) &#123; // 圆括号里没有空格. ... // 2 空格缩进.&#125; else if (...) &#123; // else 与 if 的右括号同一行. ...&#125; else &#123; ...&#125; 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用: 12if (x == kFoo) return new Foo();if (x == kBar) return new Bar(); 如果语句有 else 分支则不允许: 123// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行if (x) DoThis();else DoThat(); 通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题,但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用: 123456789101112131415161718// 不可以这样子 - IF 有大括号 ELSE 却没有.if (condition) &#123; foo;&#125; else bar;// 不可以这样子 - ELSE 有大括号 IF 却没有.if (condition) foo;else &#123; bar;&#125;// 只要其中一个分支用了大括号, 两个分支都要用上大括号.if (condition) &#123; foo;&#125; else &#123; bar;&#125; 6.循环和switch语句 switch 语句 如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果 default 应该永远执行不到, 简单的加条 assert: 12345678910111213switch (var) &#123; case 0: &#123; // 2 空格缩进 ... // 4 空格缩进 break; &#125; case 1: &#123; ... break; &#125; default: &#123; assert(false); &#125;&#125; 循环语句 在单语句循环里, 括号可用可不用： 123456for (int i = 0; i &lt; kSomeNumber; ++i) printf("I love you\n");for (int i = 0; i &lt; kSomeNumber; ++i) &#123; printf("I take it back\n");&#125; 空循环体应使用 {} 或 continue, 而不是一个简单的分号. 12345while (condition) &#123; // 反复循环直到条件失效.&#125;for (int i = 0; i &lt; kSomeNumber; ++i) &#123;&#125; // 可 - 空循环体.while (condition) continue; // 可 - contunue 表明没有逻辑. 7.指针和引用表达式 句点或箭头前后不要有空格。 指针/地址操作符 (*, &amp;) 之后不能有空格. 8.类 声明 类声明 (下面的代码中缺少注释, 参考 类注释) 的基本格式如下: 12345678910111213141516171819class MyClass : public OtherClass &#123; public: // 注意有一个空格的缩进 MyClass(); // 标准的两空格缩进 explicit MyClass(int var); ~MyClass() &#123;&#125; void SomeFunction(); void SomeFunctionThatDoesNothing() &#123; &#125; void set_some_var(int var) &#123; some_var_ = var; &#125; int some_var() const &#123; return some_var_; &#125; private: bool SomeInternalFunction(); int some_var_; int some_other_var_;&#125;; 注意事项: 所有基类名应在 80 列限制下尽量与子类名放在同一行. 关键词 public:, protected:, private: 要缩进 1 个空格. 除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空. 这些关键词后不要保留空行. public 放在最前面, 然后是 protected, 最后是 private. 构造函数 下面两种初始值列表方式都可以接受: 123456789101112131415161718192021222324// 如果所有变量能放在同一行:MyClass::MyClass(int var) : some_var_(var) &#123; DoSomething();&#125;// 如果不能放在同一行,// 必须置于冒号后, 并缩进 4 个空格MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) &#123; DoSomething();&#125;// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行// 并逐行对齐MyClass::MyClass(int var) : some_var_(var), // 4 space indent some_other_var_(var + 1) &#123; // lined up DoSomething();&#125;// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行// 如果这样做合适的话MyClass::MyClass(int var) : some_var_(var) &#123;&#125; 9.命名空间 命名空间内容不缩进 10.水平留白 通用 123456789101112131415void f(bool b) &#123; // 左大括号前总是有空格. ...int i = 0; // 分号前不加空格.// 列表初始化中大括号内的空格是可选的.// 如果加了空格, 那么两边都要加上.int x[] = &#123; 0 &#125;;int x[] = &#123;0&#125;;// 继承与初始化列表中的冒号前后恒有空格.class Foo : public Bar &#123; public: // 对于单行函数的实现, 在大括号内加上空格 // 然后是函数实现 Foo(int b) : Bar(), baz_(b) &#123;&#125; // 大括号里面是空的话, 不加空格. void Reset() &#123; baz_ = 0; &#125; // 用括号把大括号与实现分开. 循环和条件语句 1234567891011121314if (b) &#123; // if 条件语句和循环语句关键字后均有空格.&#125; else &#123; // else 前后有空格.&#125;while (test) &#123;&#125; // 圆括号内部不紧邻空格.switch (i) &#123;for (int i = 0; i &lt; 5; ++i) &#123;switch ( i ) &#123; // 循环和条件语句的圆括号里可以与空格紧邻.if ( test ) &#123; // 圆括号, 但这很少见. 总之要一致.for ( int i = 0; i &lt; 5; ++i ) &#123;for ( ; i &lt; 5 ; ++i) &#123; // 循环里内 ; 后恒有空格, ; 前可以加个空格.switch (i) &#123; case 1: // switch case 的冒号前无空格. ... case 2: break; // 如果冒号有代码, 加个空格 操作符 1234567891011121314// 赋值运算符前后总是有空格.x = 0;// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.// 圆括号内部没有紧邻空格.v = w * x + y / z;v = w*x + y/z;v = w * (x + z);// 在参数和一元操作符之间不加空格.x = -5;++x;if (x &amp;&amp; !y) ... 模板和转化 123456// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.vector&lt;string&gt; x;y = static_cast&lt;char*&gt;(x);// 在类型与指针操作符之间留空格也可以, 但要保持一致.vector&lt;char *&gt; x;]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>code-style</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tempelte_specialize]]></title>
    <url>%2F2019%2F03%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Ftempelte-specialize%2F</url>
    <content type="text"><![CDATA[函数模板具体化 CPP中允许使用模板来进行泛型编程，在C++中模板原型如下所示： 12template &lt;typename T&gt;void swap(T &amp;a, T &amp;b) 模板原型不提供函数声明和定义，需要经过模板具体化过程生成相应声明和定义。 1. 隐式实例化 最初，编译器只能通过隐式实例化，通过对参数列表的类型推断，来使用模板生成对应函数定义，这也是我们最常用的方法；如可以像下面这样使用上面定义的函数模板： 1234short a, b;swap(a, b); // T 为 short 类型int c, d;swap(c, d); // T 为 int 类型 2. 显式实例化 现在C++还允许显式实例化(explicit instrantiation)。这意味着可以直接命令编译器创建特定的实例，其语法有两种形式： 123template void swap&lt;int&gt;(int, int); //显式实例化声明orswap&lt;int&gt;(a,b) //直接在程序中调用 显示实例化可以省去编译器的类型推断过程。 3.显式具体化 显式实例化和显式具体化区别在于：这些声明的意思是“不要使用swap()模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义。”这些原型必须有自己的函数定义。显式具体化声明在关键字template后包含&lt;&gt;，而显式实例化没有。 显式具体化有两种等价声明： 12template &lt;&gt; void swap&lt;int&gt; (int &amp;, int &amp;); //explicit specializationtemplate &lt;&gt; void swap (int &amp;, int &amp;); //根据参数列表的具体化 警告：试图在同一个文件中(或转换单元)中使用同一种类型的显式实例化和显式具体化 将出错。 常规模板，具体化模板，非模板函数的优先调用顺序： 非模板函数（普通函数）&gt; 具体化模板函数 &gt; 常规模板 类模板具体化 使用类模板可以通过类模板自动生成多个类，其模板定义如下： 1234template&lt;typename T1, typename T2&gt;class Point &#123; ...&#125; 1.隐式实例化 2.显式实例化 这两个部分的实例化语法，类模板和函数模板没有太大的区别。 3.显示具体化 类模板的显示具体化语法如下： 1234template&lt;&gt;class Point&lt;char *, char *&gt; &#123; ...&#125; 其中模板类方法的实现的具体化语法和函数模板有所区别，不需要带模板头template&lt;&gt;： 123void Point&lt;char*, char*&gt;::display() const &#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;", y="&lt;&lt;m_y&lt;&lt;endl;&#125; 4. 部分显式具体化 类模板还支持部分显式具体化，即只具体化部分模板参数类型： 12345678910template&lt;typename T2&gt;class Point&lt;char*, T2&gt; &#123; ...&#125;// 部分显式具体化还是需要加上模板头template&lt;typename T2&gt;void Point&lt;char*,T2&gt;::display() const &#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;" | y="&lt;&lt;m_y&lt;&lt;endl;&#125; 部分显式具体化只能用于类模板，不能用于函数模板。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>CPP基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPP类型转换符]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2FC-cast%2F</url>
    <content type="text"><![CDATA[四种类型转换运算符 dynamic_cast 用于多态类型的转换 static_cast 用于非多态类型的转换 const_cast 用于删除const ,volatile 和 __unaligned 属性 reinterpret_cast 用于位的简单重新解释 dynamic_cast 1dynamic_cast&lt;type&gt;(expression); 将expression转换为type类型,在运行期间转换，且会执行运行时检查，性能有相应消耗。 转换类型必须是一个指针、引用或者void，用于将基类的指针或引用安全地转换成派生类的指针或引用；* dynamic_cast在运行期间强制转换，运行时进行类型转换检查； 对指针进行转换，失败返回null，成功返回type类型的对象指针，对于引用的转换，失败抛出一个bad_cast ，成功返回type类型的引用； dynamic_cast不能用于内置类型的转换； 用于类的转换，基类中一定要有virtual定义的虚函数（保证多态性），不然会编译错误。 可以在整个类层次结构中移动指针，包括向上转换、向下转换 static_cast 1static_cast&lt;type&gt;(expression); 将expression转换为type类型，在编译过程中完成。有下几个应用场景： 用于非多态类型的转换 **内置类型转换：**转换过程中的精度损失由开发者负责，除非无法完成类型转化，否则编译器不会警告或报错。 把void*转化为目标类型指针 把任意类型转化为void 基类与派生类之间指针或引用的转换：由于不会进行类型检查，所以向上转换时安全的，向下转换是不安全的。 需要注意static_cast无法转换expression的const/volitale/__unaligned属性（会报编译时错误）。 const_cast 1const_cast&lt;type&gt;(expression); 可以提供一个移除expression的const/volitale/__unaligned属性的指针，但只限同类型间转换。 const_cast不能执行其他任何类型转换，只能用于同类型之间不同const/volitale属性的移除。否则会报编译时错误。 需要注意的是，const_cast通常对指针和引用进行转换，而无法直接移除内置类型的const/volitale属性，换言之，这种语法直接提供了一个具有写权限的指针或引用，可以通过间接访问的方式，修改常量。 reinterpret_cast 1reinterpret_cast&lt;type&gt;(expression); reinterpret_cast 允许将任何指针转换为任何其他指针类型。 也允许将任何整数类型转换为任何指针类型以及反向转换。 用于位的简单重新解释,本质作用是重新定义内存数据的解释方式，而不进行任何二进制转换. 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP, CPP基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[destory和desallocate的区别]]></title>
    <url>%2F2019%2F03%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fdestory-desallocate%2F</url>
    <content type="text"><![CDATA[deallocate： 123456template &lt;class T&gt; inline void _deallocate(T* buffer) &#123; ::operator delete(buffer); //为什么不用 delete [] ? ,operator delete 区别于 delete //operator delete 是一个底层操作符 &#125; destory: 12345template &lt;class T&gt; inline void _destory(T *ptr) &#123; ptr-&gt;~T(); &#125; destory负责调用类型的析构函数，销毁相应内存上的内容（但销毁后内存地址仍保留） deallocate负责释放内存（此时相应内存中的值在此之前应调用destory销毁，将内存地址返回给系统，代表这部分地址使用引用-1） 原文地址]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>知识辨析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc、calloc、realloc的区别]]></title>
    <url>%2F2019%2F03%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fmalloc-calloc-realloc%2F</url>
    <content type="text"><![CDATA[函数原型： 1. malloc ​ void* malloc(unsigned size); ​ 在堆内存中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度。 2. calloc ​ void* calloc(size_t numElements, size_t sizeOfElement); ​ 与malloc相似，参数sizeOfElement为单位元素长度（例如：sizeof(int)），numElements为元素个数，即在内存中申请numElements * sizeOfElement字节大小的连续内存空间。 3. realloc ​ void* realloc(void* ptr, unsigned newsize); 使用realloc函数为ptr重新分配大小为size的一块内存空间。下面是这个函数的工作流程： ​ (1)，对ptr进行判断，如果ptr为NULL，则函数相当于malloc(new_size)，试着分配一块大小为new_size的内存，如果成功将地址返回，否则返回NULL。如果ptr不为NULL，则进入(2)。 ​ (2)，查看ptr是不是在堆中，如果不是的话会抛出realloc invalid pointer异常。如果ptr在堆中，则查看new_size大小，如果new_size大小为0，则相当于free(ptr)，将ptr指向的内存空间释放掉，返回NULL。如果new_size小于原大小，则ptr中的数据可能会丢失，只有new_size大小的数据会保存；如果size等于原大小，等于什么都没有做；如果size大于原大小，则查看ptr指向的位置还有没有足够的连续内存空间，如果有的话，分配更多的空间，返回的地址和ptr相同，如果没有的话，在更大的空间内查找，如果找到size大小的空间，将旧的内容拷贝到新的内存中，把旧的内存释放掉，则返回新地址，否则返回NULL。 区别 函数malloc不能初始化所分配的内存空间,而函数calloc能.如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据.也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题. 函数calloc() 会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零. 函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void类型.void表示未确定类型的指针.C,C++规定，void* 类型可以强制转换为任何其它类型的指针. realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失.realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反，realloc返回的指针很可能指向一个新的地址. realloc是从堆上分配内存的.当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动.]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>知识辨析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc 和new]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%2Fmalocandnew%2F</url>
    <content type="text"><![CDATA[​ malloc() 与 free()相对应，new/new[]与delete/delete[]相对应，都应配对使用。 申请内存位置不同 new操作符可以从其他位置上分配内存，不一定局限于堆。 malloc函数从堆上动态分配内存。 返回类型安全性 new操作符返回的是对象类型的指针，类型匹配，故类型安全。 malloc函数分配成功返回void*，需要进行强制类型转换。 内存分配失败时的返回值 new分配失败会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 空间大小指定方式不同 new 会根据类型推断需要分配的内存的大小。malloc需要自行计算指出内存大小。 分配行为不同 new分配内存会有3个步骤： 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。 第三步：对象构造完成后，返回一个指向该对象的指针。 malloc 只会开辟空间。 对数组的处理 C++提供了new[]与delete[]来专门处理数组类型: A * ptr = new A[10];//分配10个A对象 使用new[]分配的内存必须使用delete[]进行释放：delete [] ptr; new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。 而malloc，它并不知道你在这块内存上要放的数组还是别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小： 是否可以被重载 opeartor new /operator delete可以被重载 而malloc/free并不允许重载。 能否直观地重新分配内存 使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。 new没有。 new与malloc是否可以相互调用 operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。 客户处理内存分配不足 在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数。 对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>知识辨析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化Video_avatars]]></title>
    <url>%2F2019%2F01%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%2Fvideo-avatar%2F</url>
    <content type="text"><![CDATA[Video_avatars 这个项目来自马普所的一篇论文Video Based Reconstruction of 3D People Models ，日前，研究人员公布了他们的实现以及数据集。 Website:https://graphics.tu-bs.de/people-snapshot Github: https://github.com/thmoa/videoavatars 由于其文档比较匮乏，使用它的代码对自己的数据进行复现并不容易，经过几天努力，成功的完成了整个建模过程，故记录如下。相关代码以上传到了我的Github上。 原版本Demo 请先使用原版本Demo来验证环境部署成功:Video Avatars 数据准备 这个部分，我们将利用自摄的视频来进行的建模尝试，首先需要有一段如原论文视频相同的自摄视频，提供我的格式： 项目 格式 分辨率 1080*1080 帧率 24FPS 身体姿态 A形姿态旋转3圈 之后你可以使用 frame_get.py来获取到所有视频帧，以供下一步处理。 Step1:视频帧人体区域获取 这一步中，我们需要获得每一视频帧中，如下图形式的人体区域的二值图像： ![mask1](https://wpy-blog.oss-cn-shanghai.aliyuncs.com/mask1.jpg/wpy-blog) 在这一步中，我采用了百度AI开放平台的人像分割API来进行，你也可以采用其他AI开放平台的API，或者使用自己的语义分割实现。这一部分脚本在 human_mask.py 中可以找到。 ![origin](https://wpy-blog.oss-cn-shanghai.aliyuncs.com/origin1.jpg/wpy-blog) 受限于一些图像干扰，以及语义分割本身问题，获取到的mask图像往往还需要进一步处理： 可以看到，有一些无意义的区域，为了提升准确率，需要对mask进行取最大连通域的处理，之后可以再进行一次形态学膨胀操作消除空洞。这部分工作在mask_process.py中实现。 至此，我们就完成了mask的处理工作，之后，利用video_avatars/prpare_data/mask2hdf5.py即可将其转化为HDF5文件。 Step2：人体关节点标识 这一步需要将每一帧的关节点及其坐标转换为Jason格式，这里直接使用，Openpose来进行关节点识别。同样你也可以使用自己的实现或其他途径来进行关节点识别，只需符合COCO模型的关节点模式： Openpose具体安装和使用可以参考这里，我就不再详细介绍。 获取到所有的关节点的json文件后，使用video_avatars/prpare_data/2djoints2hdf5.py 可将其转化为HDF5文件。 Step3:相机相关参数 在video_avatars/prpare_data下，还有 create_camera.py来进行相机相关参数的序列化。 1234567parser.add_argument('out', type=str, help="Output file (.pkl)")parser.add_argument('width', type=int, help="Frame width in px")parser.add_argument('height', type=int, help="Frame height in px")parser.add_argument('-f', type=float, nargs='*', help="Focal length in px (2,)")parser.add_argument('-c', type=float, nargs='*', help="Principal point in px (2,)")parser.add_argument('-k', type=float, nargs='*', help="Distortion coefficients (5,)") 主要参数是分辨率以及像素焦距（Focal length in pixels ），由于我使用手机拍摄，其他参数难以获取，如果你能获取到准确数据可以将相应数据加入。 对于像素焦距（Focal length in pixels ），有以下公式可以计算： Focallengthinpixels=(imagewidthinpixels)∗(focallengthonearth)/(CCDwidthonearth)Focal length in pixels = (image width in pixels) * (focal length on earth) / (CCD width on earth) Focallengthinpixels=(imagewidthinpixels)∗(focallengthonearth)/(CCDwidthonearth) 构建运行 与之前的Demo相同，可以在这里找到具体命令。 最终效果 无衣着效果： 有衣着效果：]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>3D重建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hadoop】jar包及其替换]]></title>
    <url>%2F2019%2F01%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E5%B7%A5%E5%85%B7%2FHadoop-jars%2F</url>
    <content type="text"><![CDATA[获取Jar包 安装好Hadoop后，在hadoop的文件夹下可以看到share文件夹： 在share文件夹下，doc包含所有的文档内容，hadoop下就是我们可以获得到的Hadoop所有的源码以及测试jar包。 这里我们直接进入hadoop文件夹下，可以看到各个hadoop模块，根据需要可以找到相应jar包。 如果想要修改相应的hadoop模块，那么只需将相应的jar包替换为自己的实现即可。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo部署到云服务器上]]></title>
    <url>%2F2018%2F09%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E5%B7%A5%E5%85%B7%2F%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[一、准备 本地环境配置 本文本地环境为Windows10,确保你的计算机环境中装有 nodeJS、npm以及 Git,再进行接下来的步骤。 初始化 hexo 安装 打开命令行，执行以下命令： 1npm install hexo-cli -g 初始化 hexo 安装完成后，进入建立你的hexo目录,并完成初始化: 12345mkdir hexo-blogcd hexo-bloghexo init myblogcd myblognpm install 二、服务器配置 服务器系统为CentOS(7.1) 搭建远程Git库 登陆到远程服务器 安装git 123git --version // 如无，则安装yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y git 建立git用户并配置仓库 参考资料 123456789useradd gitpasswd git # 设置密码su git # 这步很重要，不切换用户后面会很麻烦cd /home/git/mkdir -p hexo/blog # 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git # 创建一个裸露的仓库cd blog.git/hooksvi post-receive # 创建hook钩子函数，输入内容如下（原理可以参考上面的链接） 12#!/bin/shgit --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f 添加完毕后修改钩子的权限，执行如下命令 123chmod +x post-receiveexit # 退出到 root 登录chown -R git:git /home/git/repos/blog.git # 添加权限 测试git仓库是否建立成功 找到另外的空白文件夹，执行如下命令 1git clone git@server_ip:/home/git/repos/blog.git 如果成功的完成克隆，则仓库可用。 设置ssh公钥访问 为了免去每次部署博客时输入密码的麻烦，我们需要采用ssh公钥来登陆服务器. 进入C://User//你的用户名/.ssh,查看是否已有密钥对:id_rsa和id_rsa.pub 若没有已建好密钥对参考此文。 将id_rsa.pub通过WinScp等工具上传至远端服务器/home/git/.ssh目录下，并改名为authorized_keys. 建议登陆git用户上传，上传后确保公钥拥有者为git 搭建nginx服务器 安装nginx 1yum install -y ngix 验证安装是否成功： 1ngix #启动后通过浏览器连接到server_IP 检查是否可以看到测试页面 配置nginx 12345678nginx -s stop # 先停止nginxcd /etc/nginxmv nginx.conf nginx.conf.copycp nginx.conf.defult nginx.conf #移除测试配置，导入默认配置vim nginx.conf#修改 root 解析路径 /home/git/hexo/blog# 同时将 user 改为 root 如下图，不然nginx无法访问nginx -s reload 三、本地部署配置 回到本地hexo目录，修配置文件_config.yml 以上，所有工作顺利完成！ 使用以下命令部署你的hexo: 12hexo g #生成静态文件hexo d #部署到远端 四、总结 整个过程经历了许多波折，大多是ssh公钥相关的配置问题，不过最终，还是解决了问题，可以开心地写博客了！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
</search>
