<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2021-09-技术文摘]]></title>
    <url>%2F2021%2F09%2F03%2FTechnicalDigest%2F2021-09-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[降低软件复杂性的一般原则和方法 https://tech.meituan.com/2019/09/19/common-method-of-reduce-complexity.html 系统整体的复杂度并不简单等于所有子模块复杂度的累加，还要考虑该模块的开发维护所花费的时间在整体中的占比(对应权重值tp）。也就是说，即使某个模块非常复杂，如果很少使用或修改，也不会对系统的整体复杂度造成大的影响。 层次和抽象 复杂性下沉 异常处理 深模块(Deep Module)指的是拥有强大功能和简单接口的模块 浅模块(Shallow Module)，功能简单，接口复杂 ABA问题解决 https://blog.csdn.net/hanchao5272/article/details/79689355 总结： 如何知道看到的值是新还是旧？一般分两种情况： 值是特殊的。ready=true是个特殊值，只要线程2看到ready为true就意味着更新了。只要设定了特殊值，读到或没有读到特殊值都代表了一种含义。 总是累加。一些场景下没有特殊值，那我们就用fetch_add之类的指令累加一个变量，只要变量的值域足够大，在很长一段时间内，新值和之前所有的旧值都会不相同，我们就能区分彼此了。]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编译Warning汇总]]></title>
    <url>%2F2021%2F08%2F26%2FC-%E7%BC%96%E8%AF%91Warning%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[按条目记录平时遇到的编译Error和Warning，避免重复排查 -Wpessimizing-move -Wredundant-move 解决： 删除std::move调用。 https://developers.redhat.com/blog/2019/04/12/understanding-when-not-to-stdmove-in-c]]></content>
  </entry>
  <entry>
    <title><![CDATA[2021-08-技术文摘]]></title>
    <url>%2F2021%2F08%2F02%2FTechnicalDigest%2F2021-08-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[一文解释清楚Google BBR拥塞控制算法原理 https://www.taohui.pub/2019/08/07/网络协议/一文解释清楚google-bbr拥塞控制算法原理/ BBR对TCP性能的提升是巨大的，它能更有效的使用当下网络环境，Youtube应用后在吞吐量上有平均4%提升（对于日本这样的网络环境有14%以上的提升）： 报文的往返时延RTT降低了33%，这样如视频这样的大文件传输更快，用户体验更好： 不像CUBIC这种基于丢包做拥塞控制，常导致瓶颈路由器大量报文丢失，所以重新缓存的平均间隔时间也有了11%提升： 协议 https://queue.acm.org/detail.cfm?id=3022184 BBR 论文 https://datatracker.ietf.org/doc/html/draft-cardwell-iccrg-bbr-congestion-control 论坛 https://groups.google.com/g/bbr-dev 对比 BBRv2 和 BBR https://dropbox.tech/infrastructure/evaluating-bbrv2-on-the-dropbox-edge-network Parallel-hashmap https://byronhe.com/post/2020/11/10/parallel-hashmap-btree-fast-multi-thread-intro/ Header only: 无需链接。直接 include 头文件即可用。 drop-in replacement for std::unordered_map, std::unordered_set, std::map and std::set。 原样替换，api 完全兼容标准 stl 容器 。 要求支持 C++11 的编译器 , 并且提供 C14 和 C17 的 API (例如 try_emplace) Very efficient, 明显比编译器默认提供的 unordered map/set 快， 也比 boost 的实现快，比 sparsepp 快。这里有个 benchmark ： https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/ ，大概 比 std::unorder_map 就是 insert快1倍，find 快3倍 Memory friendly: 低内存占用，尽管略微高于 sparsepp 。 参考 abseil 的数据，https://abseil.io/about/design/btree 目前 64位模式下， libstdc++ 实现的 std::set&lt;int32_t&gt; 对插入的每个value，分配 40 字节， 而 absl::btree_set&lt;int32_t&gt; 对每个 value 分配 ~4.3 至 ~5.1 字节 支持 heterogeneous lookup 很容易前向声明 forward declare: 只需要在头文件中 include phmap_fwd_decl.h 来声明 Parallel Hashmap 容器就行 [注: 目前这种对包含指针作为 key 的哈希表不适用。] Dump/load 特性: 当一个 flat 哈希表存储了 std::trivially_copyable 的数据时, 表可以被 dump 到磁盘文件，并作为一个简单的数组高效地 restore 恢复，并且过程中不需要进行 hash 计算。这通常比逐个元素地序列化到磁盘快 10倍，但是会额外占用 10% - 60% 的磁盘空间。 见 examples/serialize.cc. (flat hash map/set only) Tested 在这些平台上经过了测试： Windows (vs2015 &amp; vs2017, vs2019, Intel compiler 18 and 19), linux (g++ 4.8.4, 5, 6, 7, 8, clang++ 3.9, 4.0, 5.0) 和 MacOS (g++ and clang++) - click on travis and appveyor icons above for detailed test status. 自动支持 boost 的 hash_value() 方法，用来提供哈希函数 (见 examples/hash_value.h). 并且提供 std::pair 和 std::tuple 的哈希函数实现. natvis visualization support in Visual Studio (hash map/set only) 都是事件驱动，为什么Nginx的性能远高于Redis？ https://www.taohui.tech/2020/12/14/nginx/都是事件驱动，为什么nginx的性能远高于redis？/ 为了榨干多核CPU的价值，Nginx无所不用其极：通过绑定CPU提升二级缓存的命中率，通过静态优先级扩大时间片，通过多种手段均衡Worker进程之间的负载，在独立线程池中隔离阻塞的IO操作，等等。可见，高性能既来自于架构，更来自于细节。 使用预设字典进行压缩 https://rocksdb.org/blog/2021/05/31/dictionary-compression.html A preset dictionary makes it possible for the compressor to start from a useful state instead of from an empty one, making compression immediately effective. 深入理解 iptables 和 netfilter 架构 https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/ Linux 上最常用的防火墙工具是 iptables。iptables 与协议栈内有包过滤功能的 hook 交 互来完成工作。这些内核 hook 构成了 netfilter 框架。 每个进入网络系统的包（接收或发送）在经过协议栈时都会触发这些 hook，程序 可以通过注册 hook 函数的方式在一些关键路径上处理网络流量。iptables 相关的内核模 块在这些 hook 点注册了处理函数，因此可以通过配置 iptables 规则来使得网络流量符合 防火墙规则。 GRPC数据流 https://ilily.site/grpc-06/ Epoll：水平触发与边缘触发 https://www.jianshu.com/p/7eaa0224d797 https://segmentfault.com/a/1190000021369433 Pingcap工程体系 https://pingcap.com/zh/blog/behind-tidb-5.0-engineering-system-of-pingcap-1 活锁问题 https://www.zhihu.com/question/20566246 死锁如果是两个不动的齿轮，活锁大概就是你低头走在路上，正好快要碰上一个美女，你马上往左边垮了一步，但美女也正好往右边跨了一步，不断循环，最后谁都过不去。 [LockFree之美] 共享变量的并发读写 http://oceanbase.org.cn/?p=82 http://oceanbase.org.cn/?cat=14 规范Git Commit https://zhuanlan.zhihu.com/p/182553920 一套可行的验证工具， 通过git hook来检查commit message https://github.com/typicode/husky https://github.com/conventional-changelog/commitlint 美团外卖数仓建设实践 https://tech.meituan.com/2021/08/26/data-warehouse-in-meituan-waimai.html 大数据实时系统架构： Lamba架构 离线和实时双路生产，在应用层面整合。 Kappa 架构 一套逻辑同时生产离线和实时。]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google技术写作课——笔记]]></title>
    <url>%2F2021%2F07%2F22%2FGoogle%E6%8A%80%E6%9C%AF%E5%86%99%E4%BD%9C%E8%AF%BE%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文是阅读学习google 英文技术写作 课程的笔记。 Courses One Introduction Learning objectives 前后一致的使用术语（包括缩写形式） 能够区分并消除代词的歧义 能够识别被动语态和主动语态，并能将被动语态转换为主动语态 掌握让句子更加简短、表达更加清晰更加吸引人的几种方法。 理解项目符号列表和数字符号列表的区别，能够正确的选用 段落和文档结构上：能在文档开头说明关键点，学会写有效的段首句，每个段落只讲一个主题。 能够明白目标读者已经知道的和你想让他们知道的，避免知识诅咒 避免习语（黑话） 能够将大的话题拆成合适的段落分别说明 正确的使用标点符号 使用Markdown Word Define new or unfamiliar terms 对于目标读者不熟悉的术语： 如果是已经有的术语，给一个好的已有的解释的连接（不要重复造轮子） 如果是你的文档的新术语，给一个清晰的定义。如果很多，给一个术语表 Use tems consistently 前后一致的使用术语，如：不要前边用 Protocol Buffers 后边用 protobufs。 若要使用缩写应当在术语第一次出现时在括号内说明，之后保持一致。如： Protocol Buffers (or protobufs for short) Use acronyms properly 术语第一次出现时要写全称，但之后可以通过使用所写来简化段落。 但是不要出现全称和缩写再次混用。 Use the acronym or the full term 太多的简写读者的脑子里可能要维护一个大的map来存对应关系，因此对于一些术语我们可能不要用简写会好一点。 对于只出现几次的术语不需要定义简写 对同时满足一下情况的术语定义简写 简写要比全称短的多 简写会在文档里出现很多次（读者熟悉的缩写可以尽情使用，如HTML） Disambiguate pronouns 代词很容易出现歧义，在恰当时候使用，尽量重复使用名词来表达。 永远不要在你引入一个名词前就使用代词指代 将代词和它指代的名词放一起（5个单词举例以内——英文标准） 如果在代词和指定代的名词之间有第二个名词，建议直接重复使用名词。= This and That 对于this和 that有几种技巧能够消除歧义 直接将 this和that换成对应的名词 在this 和 that 后边紧跟一个名词 Active voice Distinguish active voice from passive voice in simple sentences Prefer active voice to passive voice 被动时态往往省略了行为人，读者需要猜测行为人 主动时态较被动时态要比被动时态直接 主动时态的句子一般比被动时态短 Clear sentences Choose strong verbs 技术写作中，动词（verb）是句子的最重要组成部分。动词用的好，句子就无需额外解释。 选用清晰、有力和具体的动词可以有效地吸引和教育读者。 Weak Verb Strong Verb The error occurs when clicking the Submit button. Clicking the Submit button triggers the error. This error message happens when… The system generates this error message when… We are very careful to ensure… We carefully ensure… 其他的句子问题： 句子中没有清晰的主语 被动时态句子 hava a xxx 或者 be xxx Reduce there is/there are 以There is 或者There are开头的句子开很千篇一律。 直接用具体的主语来代替。 用 you来代替 Minimize certain adjectives and adverbs 形容词和副词对于科技写作来说没有足够的客观性和精确性。 在科技写作中应当使用真实精确的数据替代这些。 Short sentences Focus each sentence on a single idea 每个句子应当只表达一个意思 Convert some long sentences to lists 当出现用到连词或者分号的长句子时，换用列表的形式更加直观。 Eliminate or reduce extraneous words 句子中往往会有很多废话（高级表达 ，要精简这样的词语。 Wordy Concise at this point in time now determine the location of find is able to can Reduce subordinate clauses 子句或者从句会打破一个句子只表达一个意思的原则，导致读者理解困难，所以要尽量减少脱离主句核心意思的从句。 Distinguish that from which that 和 which 从句分别何时使用，有一个经验法则： which 从句去掉后不影响主句的意思 that 去掉后主句的意思不完整 Python is an interpreted language, which means the processor runs the program directly. FORTRAN is perfect for mathematical calculations that don’t involve linear algebra. 或者：尝试读句子，如果发现读到从句时需要停顿，那适合使用 which；否则使用 that。 List and table Choose the correct type of list 项目符号列表 无序的项目（换顺序不影响表达的意思） 数字序号列表 有序的项目 嵌入列表（在句子中罗列） 一般不是一种好的方式，应该用其他两种代替 Keep list items parallel 好的列表在以下几个方面应该保持一致： 语法 逻辑类型 大小写 标点符号 Start numbered list items with imperative verbs 在有序列表中，使用祈使句来表达流程。 Punctuate items appropriately 只在列表项是一个句子时，首字母大写和使用标点符号。其他情况下不使用。 Create useful tables 加入表格应当遵守以下原则： 每一列都要有一个明确的列头。 避免一个单元格内有太多文本(不要超过两句话)。 表格内的数据应当尽量保持关联，不要将毫不相关的东西放到一起。 Introduce each list and table 在引入表格和列标签都用一句话介绍一下。 Paragraphs Write a great opening sentence 每段的第一句是最重要的。许多比较忙的读者可能只会跳着读每段的第一句 Focus each paragraph on a single topic 每段都应该只有一个主题思想。当段落内有描述其他段的内容时，应该直接删掉。 Dont’t make paragraphs too long or too short 太长的段落会看起来很吓人，容易被读者跳过。（3-5句为佳，超过7句就太长了） 相应的，也不要让段落太短了，这样会使读者聚德你的文章组织不靠谱。 Anser what, why, and how 一个段落应该能回答以下三个问题： What are you trying to tell your reader? Why is it important for the reader to know this? How should the reader use this knowledge? Alternatively, how should the reader know your point to be true? Audience good documentation = knowledge and skills your audience needs to do a task − your audience’s current knowledge and skills Define your audience 严肃的文档可能会做很多的调研工作来确定读者，但也有一些比较简单的方法： 确认读者角色 明确角色的knowledge base（相同角色的读者会有差不多的knowledge base） 找出对同一个角色的读者的差异 对于同一个角色的读者有些内容是有些人知道，有些人不知道的。如C++工程师可能比Python工程师更加熟悉操作系统 确认角色的日常经验 软件工程师虽然一般学过微积分，但可能他们长时间不用，已经不会了，但可能对项目中的知识很了解。 Sample audience analysis 这是一个例子： The target audience for Project Zylmon falls into the following roles: software engineers technical product managers The target audience has the following proximity to the knowledge: My target audience already knows the Zyljeune APIs, which are somewhat similar to the Zylmon APIs. My target audience knows C++, but has not typically built C++ programs in the new Winged Victory development environment. My target audience took linear algebra in university, but many members of the team need a refresher on matrix multiplication. Determine what your audience needs to learn 用一个列表写下所有你读者读完你的文档需要能够学到的东西。有时你列这些目标会有一个顺序，需要先知道xxx再学到jjj,也要列出来。如果你是在写一个份设计规约，最好关注在让你的读者了解整个设计，而不是专精于某个细节。 Fit documentation to your audience 你必须要用读者感兴趣的语言说明问题，而不是你自己习惯的表的方式。 Vovabulary and concepts 用读者能听懂的单词和概念。当目标读者比较广泛的时候，必须要进行更多的名词和概念的解释。 Curse of knowledge 一个专家可能意识不到读者不知道他已经知道的知识 Simple words 尽量使用简单的单词，避免给非母语者造成困扰。 Cultural neutrality and idioms 尽量保持文章文化中立。不要使用一些特定文化内的俗语或者缩写。 Documents State your document’s scope 一篇好的文档在开头就应当描述清楚文档的内容。更好的文档还会指明不会不包括的内容（可能是读者预期能够独到的）。 State your audience 在开头明确目标读者，除了明确目标读者的角色，可能还需要明确读者需要具备的知识或经验。在一些文档中，可能还要明确需要提前阅读的其他文档。 Establish your key points up front 在第一段就表明观点。保证你的第一段能够让读者理解。 在第一页多下功夫，以能够吸引读者读到后边去。 长文档一定要写一个执行摘要（TL; DR）；同时TLDR应当简短有趣，否则会吓退读者。 Write for your audience Define the audience Who is your target audience? What do your readers already know before they read your document? What should your readers know or be able to do after they read your document? Organize for your audience’s needs 以清晰的方式组织文档，以便读者能够有效地掌握或学习。 Break your topic into sections 有结构的切分你的话题 组织文章就像把罐子填满： 先以大的主题内容搭建文章框架。 再列举每一部分的主题。 最后用细节填充。 Courses Two Introduction Learning objectives 写草稿的方法和修正的方法。 几种检测文章中错误的方法 大型文档的组织方法 介绍文章内容和前置知识 清楚的数字说明 正确使用技术插图 创建有用的、准确的、简洁的、清晰的、可重用的、注释良好的示例代码 区分不同的文档类型 描述任何事情 为初学者读者提供指南 Self-editing Adopt a style guide 在组内或公司内使用统一的文档风格 style-guide highlights。 Think like your audience 在读者角度看你的文章，保证你的文档是清晰的，同时有必要的名词解释。 Read it out loud 通过大声读出来可以找出文章中不自然的地方。同时，读出来也能帮助你判断你的行文风格是否符合文档的场景，如： getting started guide 需要偏口语化，轻松一些； 开发者文档追求严谨，准确。 Come back to it later 在写完草稿后先放到一边，过1-2小时后再来看一遍，往往会注意到新的东西。 Change the context 将你的文档复制，用更换字体字号以及颜色等来进行修改。（类似于改作文时用红笔） Find a peer editor 和代码一样，文档也需要review。注意reviewer应当熟悉你们规定的文档风格。 Organizing large documents When to write large documents 不同的读者的阅读喜好不一样， 因此要区分开来。有以下几个指导原则： 操作指南、介绍性概述和概念介绍这类的文档，简短最好。 深入的教程、最佳实践指南和命令行参考页面这类的文档，可以长一点。 优秀的长文档应当能够引导读者一部分一部分的读完整个教程。 许多长文档的编写目的就不是被一次读完的，可能是供需要时查询。 Organize a document Outline a document 在写文章前要现有一份结构化的，高层次的大纲。一份好的大纲有以下指导原则： 在告诉读者要做什么之前，先告诉他们为什么 大纲里的一项涉及的范围应当限制在描述一个概念或执行一个具体的动作的范围内。 把你的大纲组织曾最能够方便读者理解的形式。 介绍概念和实践交替介绍，帮助读者最有影响的时候实践。 在开始草稿前应该把大纲分享给你的伙伴。 Introduce a document 如果读者不能知道你的文档是不是和他关心的主题有关，他可能就不会读了，所以文档中应该包含以下几个部分： What the document covers What prior knowledge you expect readers to have. What the document doesn’t cover Add navigation 添加导航栏，导航栏应该包括： 介绍和总结段 逻辑清晰的主题 能帮助读者理解主题的主副标题 能够显示当前位置的菜单栏 链接到相关的资源和更深层次的信息 链接到下一步该学习的内容 Prefer task-based headings 用读者正在处理的任务作为标题（如用C写服务器），避免出现读者目前还不熟悉的术语和工具（如不要出现具体的C框架名）。 Provide text under each heading 在每段标题下最少要有一段简短的介绍。不要标题挨着这标题 Disclose information progressively 太多的新术语和新名词会让读者难以读下去，应当在需要时才循序渐进的向读者提供信息。 以下小技巧可以帮助你更好的平衡： 尽量在需要用到的地方附近介绍新术语或概念 避免巨大的一段出现在文本上， 加入一些表格、插图或者标题。 将大的流程分成多步 。 用一个简单的例子开始，逐步的添加更多复杂的、有意思的技巧。 Illustrating 添加插图后，不管是好是坏，会让读者更愿意阅读文档 Write the caption first 好的标题： 应该是简洁的。 应该能够告知读者要点。 应该能够引导读者注意力在某一点上。 Constrain the amount of information in a single drawing 就像避免冗长复杂的句子一样，一个图例中也不要放太多信息（一个经验值：需要解释的内容不要超过5个项目符号）。 Focus the reader’s attention 使用一些视觉标记，比如说箭头或者圈，让读者能够注意到重要的部分。 Illustrating is re-illustrating 第一版的图或标题很难是最优的，因此需要反复迭代。 Creating sample code 好的示例代码就是最好的文档。 Correct 示例代码直接影响你的用户写的代码是什么样的，示例代码需要符合以下标准： Build without errors. Perform the task it claims to perform. Be as production-ready as possible. For example, the code shouldn’t contain any security vulnerabilities. Follow language-specific conventions. Running sample code 好的文档会解释怎么跑示例代码： Install a certain library. Adjust the values assigned to certain environment variables. Adjust something in the integrated development environment (IDE). Concise 示例代码应该是简短的，只包含必要的组件。 Understandable 有以下建议： Pick descriptive class, method, and variable names. Avoid confusing your readers with hard-to-decipher programming tricks. Avoid deeply nested code. Optional: Use bold or colored font to draw the reader’s attention to a specific section of your sample code. However, use highlighting judiciously—too much highlighting means the reader won’t focus on anything in particular. Commented Keep comments short, but always prefer clarity over brevity. Avoid writing comments about obvious code, but remember that what is obvious to you (the expert) might not be obvious to newcomers. Focus your commenting energy on anything non-intuitive in the code. When your readers are very experienced with a technology, don’t explain what the code is doing, explain why the code is doing it. Reusable 好的示例代码，应当提供以下内容： All information necessary to run the sample code, including any dependencies and setup. Code that can be extended or customized in useful ways. The example and the anti-example 同时展示正确示例和错误示例，有利于读者理解。 Sequenced 示例代码只展示了一部分的复杂性。太复杂的功能读者可能也理解不了。]]></content>
      <categories>
        <category>软技能</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>英文写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021-07-技术文摘]]></title>
    <url>%2F2021%2F07%2F06%2FTechnicalDigest%2F2021-07-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[Socket缓存究竟如何影响TCP的性能？ https://zorrozou.github.io/docs/Socket缓存究竟如何影响TCP的性能.html 所以，选择不同的拥塞控制算法，更多影响的是丢包之后的快速恢复过程和慢启动过程的效果。比如，bbr这种对丢包不敏感的拥塞控制算法，在有丢包的情况下，对窗口的影响比其他拥塞控制算法更小。而如果网络仅仅是延时大，丢包很少的话，选什么拥塞控制算法对带宽利用率影响并不大，缓存影响会更大。 运维平台建设 https://segmentfault.com/a/1190000014088336 运维三个阶段 第一阶段：黑屏，三角形是代表整个运维给用户的一些体感或者给研发的体感，人工运维，目前很多企业可能还是这样。 第二阶段：白屏，自动化运维，以前把脚本做成工具去弄，有什么特征，人push机器去干活，自助运维。 第三阶段：用户对运维体感很少，但是运维这个领域是不变的。最重要的是人机交互变少了，无屏虽说是不可能的，非常极端，但是个趋势，少量的人机交互，它有自决策、自驱动。 为什么WebAssembly中的内存是安全的 https://segmentfault.com/a/1190000025183711 内存泄漏 当附加了内存对象的WebAssembly实例超出范围时，可以对整个内存数组进行垃圾回收。 内存隔离 每当WebAssembly中有负载或存储时，引擎都会进行数组边界检查，以确保地址位于WebAssembly实例的内存中。 如果代码尝试访问越界地址，则引擎将引发异常。这样可以保护其余的内存。 单元测试成神之路——c++ https://zhangyuyu.github.io/cpp-unit-test/ 比较清晰，值得翻阅。]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[造💩规范]]></title>
    <url>%2F2021%2F06%2F02%2F%E9%80%A0%F0%9F%92%A9%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[类命名： 父类 BaseShi 子类 Shi1 Shi2]]></content>
  </entry>
  <entry>
    <title><![CDATA[2021-06-技术文摘]]></title>
    <url>%2F2021%2F06%2F01%2FTechnicalDigest%2F2021-06-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[压缩算法 https://tech.meituan.com/2021/01/07/pack-gzip-zstd-lz4.html 以构建部署的情景下，介绍了多种压缩算法的效率和压缩比。其中ISA-L Acceleration Version 的加速方法，指令级的优化比较新颖 自适应算法和学习算法 https://zhuanlan.zhihu.com/p/24893109 自适应算法虽然考虑了锅可能会发生变化，但是并不去主动了解当前的到底是用了什么锅，而学习算法则非常关注当前使用的 是哪一种锅，从而可以建立对应的资料库。在两种算法都收敛后，对于自适应算法，如果换掉锅，那么接下来又是一系列调整，直到用水量合适。而对于学习算法，一查资料库，就能得到最佳的用水量。 位运算技巧 位运算简介及技巧系列 位运算简介及实用技巧（一）：基础篇 位运算简介及实用技巧（二）：进阶篇(1) 位运算简介及实用技巧（三）：进阶篇(2) 位运算简介及实用技巧（四）：实战篇 20个位运算实用技巧 https://blog.csdn.net/zmazon/article/details/8262185 高性能环形队列实现 https://hedzr.com/algorithm/golang/ringbuf-01-intro/ RDMA技术详解 非常详细的系列 能够从原理上理解RDMA的工作方式 https://zhuanlan.zhihu.com/p/55142557 https://zhuanlan.zhihu.com/p/55142547 https://zhuanlan.zhihu.com/p/55142568 使用RDMA的优势如下： 零拷贝(Zero-copy) - 应用程序能够直接执行数据传输，在不涉及到网络软件栈的情况下。数据能够被直接发送到缓冲区或者能够直接从缓冲区里接收，而不需要被复制到网络层。 内核旁路(Kernel bypass) - 应用程序可以直接在用户态执行数据传输，不需要在内核态与用户态之间做上下文切换。 不需要CPU干预(No CPU involvement) - 应用程序可以访问远程主机内存而不消耗远程主机中的任何CPU。远程主机内存能够被读取而不需要远程主机上的进程（或CPU)参与。远程主机的CPU的缓存(cache)不会被访问的内存内容所填充。 消息基于事务(Message based transactions) - 数据被处理为离散消息而不是流，消除了应用程序将流切割为不同消息/事务的需求。 支持分散/聚合条目(Scatter/gather entries support) - RDMA原生态支持分散/聚合。也就是说，读取多个内存缓冲区然后作为一个流发出去或者接收一个流然后写入到多个内存缓冲区里去。 读取配置优先级源码设计 https://www.cnblogs.com/wucy/p/13586003.html 介绍了.Net读取配置的优先级顺序，从源码层面探究了这样的不同配置源的优先级的实现方式，很有借鉴意义。 程序员之路 https://icyfenix.cn/tricks/2021/geekbang.html 人生苦短，光阴易逝，把有限的时间和精力投入到对自己最有价值的方向上显得尤为关键，多数人都能接受“选择永远比努力更重要”的观点，但进一步问什么才是好的选择时，就只有少数人能对自己学习的知识技能、从事的工作方向做出定量的价值判断。这里我以上面提问为例，拿出自己的判断模型，供你参考： 价值 = (技能收益 + 知识收益) × 提升空间 / 投入成本 技能收益：问题里“每天都是对着协议研究业务实现”就属于典型的技能，它往往代表着直接收益。一项每天工作都要用到的技能，无论你是否感有趣，都值得花一些时间精力去掌握，它至少对短期利益起到了明确的支撑作用；反之，永远都不会派上用场的屠龙术，再高大上也是水月镜花。 正视技能收益的意义在于避免自己变得过度浮躁，以“兴趣不合”、“发展不符”为借口去过度挑剔。我也提倡兴趣驱动，提倡快乐工作，但不设前提条件的兴趣驱动就未免太过“凡尔赛”了，首先在社会中务实地生存，不涉及是否快乐，先把本分工作做对做好，再追求兴趣选择和机遇发展，这才是对多数人的最大的公平。 知识收益：问题里“架构方面的课程”有不少都属于知识，知识的收益往往是间接的，最终会体现在缩减模型中的“投入成本”因素，即降低认知负荷（Cognitive Load）上。世界上鲜有“烟囱式”的专业人才，专才的知识体系基本还是“金字塔式”的，在领域里能够显著超过他人高度的前提条件，往往便是拥有着超过他人的知识广度。具体到软件开发中，像计算机体系结构、编译原理、操作系统原理等原理性的知识，对于不写编译器、不开发操作系统的程序员，在实践中几乎找不到直接的应用场景的，但它们毫无疑问是程序员知识体系的基石，是许多实用技能和常见工具溯源的归宿。 花费一定成本去学习这类知识，目的是要将自己的知识点筑成体系，将大量的不同的零散的知识点、通过内化、存储、整理、归档、输出等方式组合起来，以点成线、以线成面，最终形成系统的、有序的、清晰的脉络结构，这就是知识体系。程序员是需要终身学习的群体，当新的信息输入时，如果能在知识体系中快速找到它应该安放的位置，定位它的问题与解题空间，找到它与其他知识点的关联关系，那你接受新信息的认知负荷就降低了，通俗地讲，你就有了比别人更高的学习效率，更敏锐的技术触觉。 提升空间：如果一项工作对你来说是个全新的领域，甚至能称为是一项挑战，那风险的背后往往也蕴含有更高的收益。但我将提升空间归入到价值判断的因素之中，更重要的目的是为了规避舒适区的陷阱。人性会在持续的颓废时发出示警，却容易被无效的努力所欺骗。去做已经完全得心应手的事情，不耗费什么精力，不会觉得痛苦困难，如果把它当作打游戏看电影般的娱乐消遣，放松自己是合适的，但不应该再指望从中追求什么价值。 没有价值，是因为提升空间是可以下降至零，但投入成本不可能为零，因为成本中不仅包括精力，还包括有时间，花时间重复去做已经完全熟练的事情，相当于计算分子为零的算式，结果必然是没有价值的。 投入成本：在这门架构课程中，我经常讲的一个词是“权衡”，经常说的一句话是“凡事不能只讲收益不谈成本”，在我的价值模型里，收益大小也是必须在确定的成本下才有衡量比较的意义。这里的成本，既包括你花费的时间、金钱与机会，也包括你投入的知识、精神与毅力。 强调投入成本，是希望你不要去钻牛角尖，如果一项知识或技能，你学习起来非常吃力，花费大力气弄懂之后过一段时间却又会迅速遗忘掉，这很可能是因为你既没有实际应用它的场景，知识体系中也没有建立好掌握它的稳固的前置基础。这种就属于你目前还拿不动的东西，不妨趁早放手，先做好减法，才能做好加法；也不必觉得可惜，如果它对你来说是必要的，一定还会再次出现，想躲也躲不掉。 eBPF + Kubernetes https://arthurchiao.art/blog/ebpf-and-k8s-zh/ 本文内容的时间跨度有 8 年，覆盖了 eBPF 发展的整个历史，非常值得一读。 网卡中TX和RX的意思 https://blog.csdn.net/myweishanli/article/details/25506745?utm_source=blogxgwz0 其实正常来解释： tx是发送（transport），rx是接收(receive)。 康威定律 https://zh.wikipedia.org/wiki/康威定律 康威定律尝试使用社会学的方法去解释软件研发中的问题，其核心观点是“沟通决定设计”（Communication Dictates Design），如果技术层面紧密联系在一起特性，在组织层面上强行分离开来，那结果会是沟通成本的上升，因为会产生大量的跨组织的沟通；如果技术层面本身没什么联系的特性，在组织层面上强行安放一块，那结果会是管理成本的上升，因为成员越多越不利于一致决策的形成。 BDD行为驱动测试 pytest-bdd用法介绍 Python behave介绍 Nebula BDD实践 Neo4j Cypher 的套件]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021-05-技术文摘]]></title>
    <url>%2F2021%2F05%2F13%2FTechnicalDigest%2F2021-05-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[12要素 https://12factor.net/zh_cn/ https://zhuanlan.zhihu.com/p/243404169 I. 基准代码 一份基准代码，多份部署 II. 依赖 显式声明依赖关系 III. 配置 在环境中存储配置 IV. 后端服务 把后端服务当作附加资源 V. 构建，发布，运行 严格分离构建和运行 VI. 进程 以一个或多个无状态进程运行应用 VII. 端口绑定 通过端口绑定提供服务 VIII. 并发 通过进程模型进行扩展 IX. 易处理 快速启动和优雅终止可最大化健壮性 X. 开发环境与线上环境等价 尽可能的保持开发，预发布，线上环境相同 XI. 日志 把日志当作事件流 XII. 管理进程 后台管理任务当作一次性进程运行 长尾请求 长尾请求一般是指明显高于均值的那部分占比较小的请求 http://accelazh.github.io/storage/Tail-Latency-Study 一种Google 的策略： 树形请求分发 http://highscalability.com/blog/2011/2/1/google-strategy-tree-distribution-of-requests-and-responses.html 大概思想是中间加一层proxy，降低中心压力。 最后的结构会像CDN一样 队头阻塞 https://juejin.cn/post/6844903853985366023 HTTP3的解决方式 https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/ 动态密码算法 https://blog.csdn.net/LVXIANGAN/article/details/79926112]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灵光一闪]]></title>
    <url>%2F2021%2F04%2F21%2F%E7%81%B5%E5%85%89%E4%B8%80%E9%97%AA%2F</url>
    <content type="text"><![CDATA[记录一下平时突然想到的一些好的 idea。 计算机 架构应当解耦，但架构设计的思考过程不能解耦。 代码复用性越高，功能可用性就越低（观某难产项目后有感 80%的bug出现在设计阶段， 单测是横好的检验方法 高并发情境下，CPU以外的内存、磁盘都可能成为并发瓶颈 测试和需求是一致的， 有什么样的需求就会有什么样的测试。 代码的传染性：CodeBase内的代码会被各处copy 云作为基础设施，未来应当像自来水一样随用可取。同样的云原生应用也应当是随用可取的。 经济学 产品的第一步或冷增长应当是社交(爆款或裂变)为佳，机器推荐提供的是产品黏性。 服务业的服务价格取决于当地消费者的收入水平（机会成本），即你的收入实际上取决于与你分工的人的收入水平。如：剪发、按摩、中介等。 优质资产是相对概念在同一资产类目中排名靠前的资产即为优质资产。而排名考虑的是两点：α（超额收益）和β（系统风险系数） 新技术提供的是更多的可选项，而不是应该要使用。技术发展带来的是自由而不是“最新方案“的约束。 由于物质和能量守恒，所以物质财富是取之不竭的。其区别在于多少能够被人类所利用。 利润来源于系统不确定性。 确定概率的不确定性——偶然不确定性。 不确定概率的不确定性——认知（系统）不确定性。 风口不属于投机者，而是属于那些原本就在行业中深耕的人。 2020年中国零售消费市场 39万亿元 盈亏同源 投资的最重要的事 -&gt; 避险 -&gt;控制风险 -&gt; 控制不确定性 特别是系统不确定性 厚雪 长坡 护城河 靠谱方法论 办事利索（指思路清晰，行动坚定）可以减少反复沟通造成的注意力损耗，从而更有利于高质量的完成任务。 可行性验证应当从最难的部分开始，而不是从简单可实现的部分开始下手。 旁观者在研究成功者的成功路径时，看到的是一条合理的确定路径。而成功者在当下，遇到的都是不确定性。 所以关键在于将自己代入情景，认识并学习成功者面对不确定性的方法。 邓宁克鲁格效应 先验概率应当被视为是先前经验的结果，而不是超越经验的，因为人的认识是有限主观的。 机器学习中，之前数据的训练结果即可视为一个先验概率，结合新的测试数据，进行最大似然概率的估计。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数学文摘]]></title>
    <url>%2F2021%2F04%2F13%2F%E6%95%B0%E5%AD%A6%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[贝叶斯方法 http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/ 但也绝对不是两眼一抹黑瞎蒙——具体地说，我们需要做两件事情：1. 算出各种不同猜测的可能性大小。2. 算出最靠谱的猜测是什么。第一个就是计算特定猜测的后验概率，对于连续的猜测空间则是计算猜测的概率密度函数。第二个则是所谓的模型比较，模型比较如果不考虑先验概率的话就是最大似然方法。]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021-04-技术文摘]]></title>
    <url>%2F2021%2F04%2F11%2FTechnicalDigest%2F2021-04-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[GDB保存断点 https://blog.csdn.net/weiwangchao_/article/details/45557971 拜占庭将军问题 https://zhuanlan.zhihu.com/p/217827966 两军问题 https://zh.wikipedia.org/wiki/两军问题 两军问题（英语：Two Generals’ Problem）是计算机领域中的一个思想实验。两军问题显示，通过不可靠的通信通道交换信息并达成共识是难以实现的。在该问题中，两支军队的将军只能通过派遣信使穿越敌方领土来互相通信，以此约定在同一时间点共同进攻。该问题希望求解如何在两位将军派出的任何信使都可能被俘虏的情况下，就发动攻击的时间点达成一致。 protobuf之string bytes的区别 https://izualzhy.cn/protobuf-difference-between-string-and-bytes]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021-03-技术文摘]]></title>
    <url>%2F2021%2F03%2F25%2FTechnicalDigest%2F2021-03-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[FOQS 一种可以水平扩缩容 分布式 priority queue https://engineering.fb.com/2021/02/22/production-engineering/foqs-scaling-a-distributed-priority-queue/ 锁性能优化 https://cloud.tencent.com/developer/article/1511694 介绍了java jdk的一些锁优化工作，对其他语言开发思路也有启发]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021-02-技术文摘]]></title>
    <url>%2F2021%2F02%2F01%2FTechnicalDigest%2F2021-02-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[6w字搞定Linux基本操作，建议收藏 https://juejin.cn/post/6917096816118857736 很齐全 值得翻一翻 程序员职场经验 https://juejin.cn/post/6924205515191320589 真正有价值的社交其实都是弱社交。也就是那些和你不太熟悉的人，比如前同事，校友，不怎么来往的同学等等。经营人脉其实并没有太多东西，就是就只有一点，就是管理好外界对我们的看法和认知，维持住“人设”。简单来说，就是我们要注意羽毛和口碑，说不定什么时候它就起到了作用。 在职场当中真正好机会是很稀缺的，很多机会只有局内人才能接触到。 Linux 堆内存管理 Linux堆内存管理深入分析（上） Linux堆内存管理深入分析（下） brk 和 mmap 计算和储存分离 https://juejin.cn/post/6844904055840440333 https://juicefs.com/blog/cn/posts/why-disaggregated-compute-and-storage-is-future/ 这个时候谷歌摒弃了之前的观念“移动存储到计算”，采取了“移动计算到存储的观念”，将计算和存储耦合了，因为当时的网络速度对比现在来说慢了几百倍，网络速度跟不上我们的需要。在在典型的MapReduce部署中计算和存储都在同一个集群中进行，比如后续的hadoop。这里其实也就是用本地IO速度来替换网络传输速度。 随着技术的进步，我们的网络速度也越来越快，我们的瓶颈不再是网络速度，但是我们的磁盘I/O速度却没有明显的速度增长，计算和存储融合的架构缺点也再逐渐暴露： 作者：咖啡拿铁 链接：https://juejin.cn/post/6844904055840440333 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Swig 封装C++接口 https://www.cnblogs.com/terencezhou/p/10059156.html CPU分支预测 http://djs66256.github.io/2019/01/29/2019-01-29-CPU分支预测/ 介绍了几种分支预测的算法 Varint编码 https://segmentfault.com/a/1190000020500985 Varint是一种使用一个或多个字节序列化整数的方法，会把整数编码为变长字节。对于32位整型数据经过Varint编码后需要15个字节，小的数字使用1个byte，大的数字使用5个bytes。64位整型数据编码后占用110个字节。在实际场景中小数字的使用率远远多于大数字，因此通过Varint编码对于大部分场景都可以起到很好的压缩效果。 Perf – Linux下的系统性能调优工具 Perf 是用来进行软件性能分析的工具。 通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题 (per thread)，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。 eBPF技术 https://blog.fleeto.us/post/what-is-ebpf/ 概念和基本原理的介绍文章 https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/ 一个全面的ebpf学习路线]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具杂记]]></title>
    <url>%2F2021%2F01%2F07%2F%E5%B7%A5%E5%85%B7%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[VScode 21个Vscode快捷键 https://juejin.cn/post/6844903894305210381 VScode教程 这个教程还是很全的，只是找起来不太方便 https://geek-docs.com/vscode/vscode-tutorials/what-is-vscode.html CPP 使用ccls：C++ language server https://zhuanlan.zhihu.com/p/31672451 使用Doxygen创建C/C++文档 https://blog.srefan.com/2020/05/doxygen-generate-docs/ Git Git 中大文件清理 https://rtyley.github.io/bfg-repo-cleaner/ Docker Docker多阶段构建（多个 From） https://segmentfault.com/a/1190000016137548 Docker 17.05版本以后，新增了Dockerfile多阶段构建。所谓多阶段构建，实际上是允许一个Dockerfile 中出现多个 FROM 指令。 GDB GDB保存断点 https://blog.csdn.net/weiwangchao_/article/details/45557971 使用save breakpoint命令保存到指定的文件 必须在gdb加载文件的命令中指定断点文件，具体就是使用-x参数。例如，我需要调试fig8.3这个文件，指定刚才保存的断点文件fig8.3.bp。 我使用的是gdb fig8.3 -x fig8.3.bp]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021-01-技术文摘]]></title>
    <url>%2F2021%2F01%2F03%2FTechnicalDigest%2F2021-01-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[刨根问底，kafka 到底会不会丢消息 Kafka有三次消息传递的过程： 生产者发消息给Kafka Broker。 Kafka Broker 消息同步和持久化 Kafka Broker 将消息传递给消费者。 在这三步中每一步都有可能会丢失消息，下面详细分析为什么会丢消息，如何最大限度避免丢失消息。 … Kafka通过配置request.required.acks属性来确认消息的生产： 0表示不进行消息接收是否成功的确认；不能保证消息是否发送成功，生成环境基本不会用。 1表示当Leader接收成功时确认；只要Leader存活就可以保证不丢失，保证了吞吐量。 -1或者all表示Leader和Follower都接收成功时确认；可以最大限度保证消息不丢失，但是吞吐量低。 kafka producer 的参数acks 的默认值为1，所以默认的producer级别是at least once，并不能exactly once。 … Kafka通过多分区多副本机制中已经能最大限度保证数据不会丢失，如果数据已经写入系统 cache 中但是还没来得及刷入磁盘，此时突然机器宕机或者掉电那就丢了，当然这种情况很极端。 … 场景一：先commit再处理消息。如果在处理消息的时候异常了，但是offset 已经提交了，这条消息对于该消费者来说就是丢失了，再也不会消费到了。 场景二：先处理消息再commit。如果在commit之前发生异常，下次还会消费到该消息，重复消费的问题可以通过业务保证消息幂等性来解决。 … 数据库MVCC https://juejin.cn/post/6871046354018238472 刻意练习 https://zhuanlan.zhihu.com/p/39785609 5分钟了解MPP数据库 https://zhuanlan.zhihu.com/p/148621151 PIMPL技巧 PIMPL(Pointer to Implementation)这个手法可以解決/改善C++编码时常碰到的2大问题。 1.class增加private/protected成员时，使用此class的相关 .cpp(s) 需要重新编译。 2.定义冲突与跨平台编译 https://blog.csdn.net/pp5576155/article/details/6895608?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control https://blog.csdn.net/caoshangpa/article/details/78590826?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control 编译原理知识 https://juejin.cn/post/6844903482454081549 这篇比较清楚的讲明白了Rumtime和语言的区别以及关系。 https://www.infoq.cn/article/qvvkrri0io6u0qwai1qg 这篇基础概念讲的比较直白 Hash 相关算法 介绍了各种Hash相关的数据结构和算法：https://zhuanlan.zhihu.com/p/133711073 数据摘要技术 https://cacm.acm.org/magazines/2017/9/220427-data-sketching/fulltext 一篇科普文章，介绍了多种数据摘要技术。 https://www.sketchingbigdata.org/ https://www.sketchingbigdata.org/fall20/lec/notes.pdf 一系列数据摘要算法的课程 https://www.jianshu.com/p/55defda6dcd2 https://zhuanlan.zhihu.com/p/77289303 https://zhuanlan.zhihu.com/p/58519480 HyperHyperLog 算法实现 基于SSD的Kafka应用层缓存架构设计与实现 冷热分层存储做缓存 和Pravega思路差不多 时间序列特征分析 https://blog.csdn.net/dQCFKyQDXYm3F8rB0/article/details/95400860 读源码 https://juejin.cn/post/6918976731042807821 然后要自顶向下的看源码，不要一头就钻进细节，先从官网等渠道对开源框架有个全面的了解，然后看源码理清主流程。 上下文切换Cost https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html 很不错的一个实验，测试了各代Intel CPU上下文切换的耗时。 CPU Memeory 详解 https://akkadia.org/drepper/cpumemory.pdf 07年的文章 现在的体系结构有小的区别 Netem 流量模拟工具 https://wiki.linuxfoundation.org/networking/netem Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能，诸如低带宽、传输延迟、丢包等等情况 Docker里跑Docker https://cloud.tencent.com/developer/news/300876 Trie树|前缀树的介绍与实现 https://songlee24.github.io/2015/05/09/prefix-tree/]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-12-技术文摘]]></title>
    <url>%2F2020%2F12%2F15%2FTechnicalDigest%2F2020-12-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[软件研发中的信任链问题 当系统被划分为多层时，不同层面的人思考关注的问题不一样，并且这种不同有时甚至造成误解。 报警的哲学 报警的（电话，短信）触达应当是紧急的，重要的，可行动的，真实的。 规则应当表示是你的服务处于过程中或者即将发生的问题。 为了保持报警项的精确，有效；宁可过度移除报警噪音。因为过度监控比监控不足更难解决 你应该总是能够将问题分为以下几种：基本功能的可用性问题；延迟；正确性（数据的完整性、新鲜性和持久性）；以及特定功能问题。 规则描述症狀是更好的方法，可以更轻松，更全面，更可靠地捕获更多的问题。 在基于症状的页面或仪表板中包含基于原因的信息，但要避免直接针对原因发出警报。 报警越往上层的服务走，在一个报警规则中可以抓住的明显问题就越多。但不要走得太远，你无法充分区分发生了什么。 如果你想在值班时，报警系统保持安静, 那么需要有一套系统和标准化的流程能够自动处理那些需要被尽快处理，但不至于让你半夜三点钟爬起来上线的事件。 基于症状的报警： 基本的可用性和正确性。 延迟，系统响应要足够快。 完整性/新鲜度/持久性。你的用户数据应该是安全的，应该在你要求的时候回来，搜索索引应该是最新的。 功能。你的用户关心的是服务的所有功能是否正常工作–你应该监控任何对你的服务很重要的方面，即使它不是核心功能/可用性（例如，计算器和股票行情显示在搜索结果中）。 谈谈OPS 为此我写了很多 shell 脚本，来帮助提高工作效率，当时觉得很自豪。可是后来才慢慢感受到，真正优秀的 Ops 流程，是不需要自己现场去手写这些脚本的，工具应该帮我们干了几乎所有的事情。手动脚本是介于手动命令和工具之间的手段，但总体来说依然是一个容易犯错而且缺乏延续性的做法。一个成熟的运维流程，应该把这些犯错的可能减到最小。 其原因之一就是，工程师的成本。招聘运维团队的工程师，其实并不容易，而如果能够用尽量少的研发工程师团队，“顺便” 去把运维的事情做了，这无疑是很节约成本的事情。从这个角度说，资源的限制才能促进创新和发展 让研发工程师去做运维，能做好吗？不是应该让专业的人去做专门的事情吗？这个观点是两说的，如果不具备合适的工具，那一定是个灾难，但如果具备，情况就不同了。运维技能的缺乏可以通过优秀的运维工具来缓解；而另一方面，每多一种 “专业的人”，就意味着整个工作系统中，多了一个角色，就多了多个需要沟通的环节，这些都是内耗 在我曾经的一个团队中，在项目发布以前的最后阶段，有限的时间里面（一般都是一个晚上），需要把最重要和最核心功能过一遍，这个功能清单叫做 checklist。为什么不把所有的测试案例都覆盖了？因为时间有限。这就是一个很简单也很容易执行的流程。但是，随着时间推演，问题变得很多。比如产品发布了以后，发现有一个比较大的问题，于是研发团队就要回溯问题，发现问题以后，为了杜绝问题的再次发生，就打算采取某些措施。（到目前为止做法上面都没有什么问题，可接下去就有争议了。）于是一条用于检测这个问题的识别项被加到这个 checklist 当中。这里面有很多检查项事实上在问题修复以后是不会再出现的了，也有一些检查项明显是用于覆盖位于边角的 corner case，而不是主要的 case，但是既然出过问题，为了保险起见，还是都加进去了。就这样，随着时间和版本的演进，这个 checklist 变得越来越长，某些验证项的执行难度颇为复杂，在几年以后，已经到了几个小时都无法过完这个 checklist 的地步，于是这个流程就变成了一个越来越难以执行的累赘。 造成这一问题的原因是什么，就是流程太简便了，太有效了，以至于这些聪明人不再思考应该采用什么样的方式来从根本上彻底地解决问题。 流程更多地，是用来在效率损失可以接受的情况下，控制风险，从而导向正向的影响力。对于一些服务更 critical 的团队来说，风险控制相对地，更为重要，因而流程的比重可以适当增加；反之，流程需要简化，保证效率在一个高标准之上。 一个健康的研发体系，绝大多数 Ops 的工作，就应该交给普通的软件工程师来完成。 而这一类真正可以委托给 Ops 团队做的事情，恰恰有一个共同的特点——都是简单劳动，而且可以自动化。换言之，缺少的是充分和有效的工具。 长远来说，多数情况下，投入到工具开发的成本，和让开发人员来做 Ops 的成本，最终会小于聘用 Ops 团队的成本。 除了开发人员自己做 Ops，没有任何一种组织结构能够提供这样没有回馈损耗的反哺机制，没有任何一种方式能让开发人员 “吃自己的狗食” 和其它软件工程的问题一样，Ops 没有银弹。 单元测试要求易于执行，由于需要反复执行和根据结果修改代码，快速的反馈是非常重要的，几十秒内必须得到结果。我见过有一些团队的单元测试跑一遍要十分钟以上，那么这种情况就要保证能够跑增量的测试，换言之，改动了什么内容，能够重跑改动的那一部分，而不是所有的测试集合。 有一些实践在我看来，是非常糟糕的，它们包括： SSH+命令/脚本。这大概是最糟糕的了，尤其是线上的运维，在实际操作中，一定是最好更相信工具，而不是人。如果没有工具，只能手工操作，只能使用命令+脚本来解决问题，于是各种吓人的误操作就成了催命符。你可以看看 《手滑的故事》，我相信很多人都经历过。最好的避免这样事情发生的方式是什么？限制权限？层层审批？都不是，最好的方式是自动化。人工命令和脚本的依赖程度和 Ops 的成熟度成逆相关。 流程至上。这里我不是否认流程的作用，我的观点在这篇文章中已经说过了。其中一个最典型的操作就是堆人，发现问题了，就靠加人，增加一环审批来企图避免问题。 英雄主义。这是很多公司的通病，一个写优质代码的工程师不会起眼，只有埋 bug 造灾难，再挺身而出力挽狂澜，从而拯救线上产品的 “英雄” 才受人景仰。正所谓，没有困难制造困难也要上。 背锅侠。这和上面的英雄主义正好相反，却又相辅相成。找运维不规范操作背锅（可事实呢，考虑到复杂性、枯燥性等原因，几乎没法 “规范” 操作，人都是有偷懒和走捷径的本性的），找开发埋地雷，测试漏覆盖背锅。当场批评，事后追责。 用户投诉驱动开发，线上事故驱动开发。这一系列通过糟糕的结果来反向推动的运维反馈开发的方式（其它各种奇葩的驱动开发方式，看这里）。 把研发的时间精力投入 ops。这是恶性循环最本质的一条，没时间做好需求分析，没时间做好设计，没时间做好测试，没时间写好代码，什么都没时间，因为全都去 Ops 解线上问题去了。结果呢，糟糕的上游造就了更糟糕的下游，问题频出，于是更多的人花更多的人去 ops。如此恶性循环…… Rust 半小时教程 https://colobu.com/2020/03/05/A-half-hour-to-learn-Rust/ C++服务编译耗时优化原理及实践 2.2 C++编译特点 （1）每个源文件独立编译 C/C的编译系统和其他高级语言存在很大的差异，其他高级语言中，编译单元是整个Module，即Module下所有源码，会在同一个编译任务中执行。而在C/C中，编译单元是以文件为单位。每个.c/.cc/.cxx/.cpp源文件是一个独立的编译单元，导致编译优化时只能基于本文件内容进行优化，很难跨编译单元提供代码优化。 （2）每个编译单元，都需要独立解析所有包含的头文件 如果N个源文件引用到了同一个头文件，则这个头文件需要解析N次（对于Thrift文件或者Boost头文件这类动辄几千上万行的头文件来说，简直就是“鬼故事”）。 如果头文件中有模板（STL/Boost），则该模板在每个cpp文件中使用时都会做一次实例化，N个源文件中的std::vector会实例化N次。 （3）模板函数实例化 在C++ 98语言标准中，对于源代码中出现的每一处模板实例化，编译器都需要去做实例化的工作；而在链接时，链接器还需要移除重复的实例化代码。显然编译器遇到一个模板定义时，每次都去进行重复的实例化工作，进行重复的编译工作。此时，如果能够让编译器避免此类重复的实例化工作，那么可以大大提高编译器的工作效率。在C++ 0x标准中一个新的语言特性 – 外部模板的引入解决了这个问题。 在C++ 98中，已经有一个叫做显式实例化（Explicit Instantiation）的语言特性，它的目的是指示编译器立即进行模板实例化操作（即强制实例化）。而外部模板语法就是在显式实例化指令的语法基础上进行修改得到的，通过在显式实例化指令前添加前缀extern，从而得到外部模板的语法。 ① 显式实例化语法：template class vector。 ② 外部模板语法：extern template class vector。 一旦在一个编译单元中使用了外部模板声明，那么编译器在编译该编译单元时，会跳过与该外部模板声明匹配的模板实例化。 （4）虚函数 编译器处理虚函数的方法是：给每个对象添加一个指针，存放了指向虚函数表的地址，虚函数表存储了该类（包括继承自基类）的虚函数地址。如果派生类重写了虚函数的新定义，该虚函数表将保存新函数的地址，如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址将被添加到虚函数表中。 调用虚函数时，程序将查看存储在对象中的虚函数表地址，转向相应的虚函数表，使用类声明中定义的第几个虚函数，程序就使用数组的第几个函数地址，并执行该函数。 使用虚函数后的变化： ① 对象将增加一个存储地址的空间（32位系统为4字节，64位为8字节）。 ② 每个类编译器都创建一个虚函数地址表。 ③ 对每个函数调用都需要增加在表中查找地址的操作。 （5）编译优化 GCC提供了为了满足用户不同程度的的优化需要，提供了近百种优化选项，用来对编译时间，目标文件长度，执行效率这个三维模型进行不同的取舍和平衡。优化的方法不一而足，总体上将有以下几类： ① 精简操作指令。 ② 尽量满足CPU的流水操作。 ③ 通过对程序行为地猜测，重新调整代码的执行顺序。 ④ 充分使用寄存器。 ⑤ 对简单的调用进行展开等等。 如果全部了解这些编译选项，对代码针对性的优化还是一项复杂的工作，幸运的是GCC提供了从O0-O3以及Os这几种不同的优化级别供大家选择，在这些选项中，包含了大部分有效的编译优化选项，并且可以在这个基础上，对某些选项进行屏蔽或添加，从而大大降低了使用的难度。 O0：不做任何优化，这是默认的编译选项。 O和O1：对程序做部分编译优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。 O2：是比O1更高级的选项，进行更多的优化。GCC将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环展开以及函数内联优化。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。 O3：在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。 Os：主要是对代码大小的优化， 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。 编译优化有可能带来的问题： ① 调试问题：正如上面所提到的，任何级别的优化都将带来代码结构的改变。例如：对分支的合并和消除，对公用子表达式的消除，对循环内load/store操作的替换和更改等，都将会使目标代码的执行顺序变得面目全非，导致调试信息严重不足。 ② 内存操作顺序改变问题：在O2优化后，编译器会对影响内存操作的执行顺序。例如：-fschedule-insns允许数据处理时先完成其他的指令；-fforce-mem有可能导致内存与寄存器之间的数据产生类似脏数据的不一致等。对于某些依赖内存操作顺序而进行的逻辑，需要做严格的处理后才能进行优化。例如，采用Volatile关键字限制变量的操作方式，或者利用Barrier迫使CPU严格按照指令序执行。 (6)C/C++ 跨编译单元的优化只能交给链接器 当链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定义表，对其中记录的地址进行重定向（加上一个偏移量，即该编译单元在可执行文件上的起始地址）。然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上填写实现地址，最后把所有的目标文件的内容写在各自的位置上，就生成一个可执行文件。链接的细节比较复杂，链接阶段是单进程，无法并行加速，导致大项目链接极慢。 编译耗时分段统计是从结果上看各个文件的编译耗时以及各个编译阶段的耗时情况，这个是直观的一个结果，正常情况下，是和文件展开大小以及头文件引用个数是正相关的，cmake通过指定环境变量能打印出编译和链接阶段的耗时情况，通过这个数据能直观的分析出耗时情况。 123&gt; set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE "$&#123;CMAKE_COMMAND&#125; -E time")&gt; set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK "$&#123;CMAKE_COMMAND&#125; -E time")&gt; Git Change Log Some websites such as Keep A Changelog explain that you shouldn’t make a changelog only by copying and pasting your git commits (refer to the simple way). Indeed, I recommend trying to avoid this way if you are working on a professional product.]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-如何写代码注释]]></title>
    <url>%2F2020%2F12%2F12%2FPrograming%2F%E8%BD%AC-%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[许多人认为，如果代码写得足够扎实，注释就没什么用了。在他们看来，当一切都设计妥当时，代码本身会记录其作用，因此代码注释是多余的。我对此持不同意见，主要出于两个原因： \1. 许多注释并未起到解释代码的作用。 \2. 注释使读者不必凭空想象太多细枝末节，帮助读者降低认知负担。 注释的分类 我的工作始于随机地阅读Redis源代码，以检查注释是否以及为什么在不同的上下文中起作用。我很快发现，注释的作用来源于多方面：它们在功能，编程风格，长度和更新频率方面往往非常不同。我最终转向了注释分类。 在研究期间，我确定了九种注释类别： * 函数注释 Function comments * 设计注释 Design comments * 原因注释 Why comments * 教学注释 Teacher comments * 清单注释 Checklist comments * 引导注释 Guide comments * 琐碎注释 Trivial comments * （代码）负债注释 Debt comments * 备份注释 Backup comments 在我看来，前六个主要是非常积极的注释形式，而最后三个有点值得怀疑。在接下来的部分中，我将使用Redis源代码中的示例分析每种注释类型。 函数注释 函数注释的目标是防止读者直接阅读代码。 在阅读注释之后，读者应该可以将一些代码视为应遵守某些规则的黑箱子。通常情况下，函数注释位于函数定义的顶部。 rax.c： C++收起 1234/ * 在当前节点的子树中寻找最大的key。 如果内存不足返回0，否则 返回1. * /int raxSeekGreatest（raxIterator * it）&#123; ...&#125; 函数注释实际上是一种内联API文档。如果函数注释编写得好，那么用户在大多数时候能跳回到她正在阅读的内容（如阅读调用此类API的代码），而无需阅读函数（function），类（class），宏（macro）等的实现过程。 在所有注释类型中，函数注释被整个编程界广泛接受和需要。要分析的唯一一点是：在代码内部放置以API参考文档为主的注释是否是件好事。 对我来说答案很简单：我希望API文档与代码完全匹配。随着代码的更改，文档也得到更改。出于这个原因，我们将函数注释用作函数或其他元素的序言，使API文档接近代码，完成三个任务： * 随着代码的更改，我们可以轻松更改文档，API参考也不会有过时的风险。 * 这种方法使得更改者（理应是最清楚更改目的的人）在最大限度上成为API文档的更改者。 * 读者能通过阅读代码直接找到函数或方法（method）的文档，以便阅读代码的读者只关注代码，而不是代码和文档之间的上下文切换。 设计注释 “函数注释”通常位于函数的开头，而设计注释通常位于文件的开头。 设计注释一般说明了给定代码片段使用某些算法、技术、技巧和具体实现的方式和原因，对代码中实现的内容进行了更高级别的概述。在这样的背景下，阅读代码会更简单一些。 bio.c C++收起 1234567*设计* ------**设计很简单，我们用一个结构代表要执行的一项 Job*每种Job类型有不同的线程和Job队列。*每个线程都在等待队列中的新Job，并按照顺序处理*每个Job。 ... 原因注释 原因注释解释了代码执行某些操作的原因——即使代码执行的操作非常明确。请看以下来自Redis replication的代码 的示例。 replication.c： C++收起 123456789101112131415161718192021222324if（idle&gt; server.repl_backlog_time_limit）&#123; /* 当我们释放 backlog时，我们总是使用新的 * replication ID并清除ID2。这是 * 因为在没有backlog时，master_repl_offset * 未更新，但我们仍会保留我们的 * replication ID，由此导致以下问题： * * 1.我们是一个主实例（master instance）。 * 2.我们的副本成为主服务器（Master）。repl-id-2将会 * 与我们的repl-id相同。 * 3.我们作为主服务器，收到了一些更新命令，但不会 * 增加master_repl_offset。 * 4.稍后我们将变成副本，连接到新的 * 主服务器，它将接受我们第二个副本ID的 * PSYNC请求，但会有数据不一致的情况 * 因为我们接受了写命令。*/ changeReplicationId（）; clearReplicationId2（）; freeReplicationBacklog（）; serverLog(LL_NOTICE, &quot;Replication backlog freed after %d seconds &quot; &quot;without connected replicas.&quot;, (int) server.repl_backlog_time_limit); &#125; 如果我只检查函数调用，就没什么需要纠结的：如果超时了就更改主replication ID，清除辅助ID，最后释放replication backlog。 教学注释 教学注释不会试图解释代码本身或我们应该注意的某些副作用。教学注释教授的是代码运行的“领域”（例如数学，计算机图形学，网络系统，统计，复杂的数据结构等），这些信息可能超出了读者的认知范围，或者细节多到难以回忆。 版本5中的LOLWUT命令需要在屏幕上显示旋转的方块。为了做到这一点，它使用了一些基本的三角函数：尽管涉及的数学内容很简单，但许多阅读Redis源代码的程序员可能没有任何数学背景知识，因此函数顶部的注释解释了该函数的原理。 C++收起 123456789101112131415/** 绘制一个以指定的x，y坐标为中心的正方形* 旋转角度和大小已定。为了写出旋转方块的代码，我们使用了* 参数方程：** x = sin（k）* y = cos（k）** 绘制一个圆（0-2*PI）。然后，如果我们从45度* 开始，即k = PI / 4，以此作为第一个点，然后我们发现* 其他三个点的K值以PI / 2（90度）递增，于是我们得到* 了构成一个圆的点。为了旋转方块，我们从* k = PI / 4 + rotation_angle开始，然后我们就完事儿了。* ......* / 注释不包含任何与函数本身的代码，或其副作用，或与函数相关的技术细节等内容。注释描述的部分仅限于函数内部使用以达到给定目标的数学概念。 清单注释 这是一个非常常见且奇怪的问题：有时由于语言限制，设计问题，或者仅仅因为系统内部固有的复杂性，我们无法将某个概念或界面集中在一个代码片段中，因此代码中有一些部分能提醒你在代码的某个部分做某件事。一般概念是： / * 警告：如果你在此处添加类型ID，请务必修改 * getTypeNameByID（）函数。* / 在一个完美世界中，我们永远不需要添加这类注释；但在实践中有时没法省略这一步。 在这种情况下，防御性注释有时能起作用：如果你修改了某节代码，它会提醒你修改代码的其他相关部分。具体而言，清单注释会发挥以下一种作用（或者两种兼而有之）： * 告诉你在修改某些内容时要执行的一系列操作。 * 警告你应该如何进行某些更改。 引导注释 我滥用引导注释到这种程度：Redis中的大多数注释都是引导注释。然而，引导注释正是大多数人认知中那类完全无用的注释： * 他们没有说明代码中不甚明了的内容。 * 指导注释不提供有关设计方面的提示。 引导注释只做了一件事：他们照顾了读者的需求，在读者处理源代码中的内容时提供明确的划分（division）和节奏（rhythm），并介绍接下来需要阅读的内容。 rax.c C++收起 12345678910/*调用节点回调（如果有的话），如果回调返回true *则替换节点指标*/if (it-&gt;node_cb &amp;&amp; it-&gt;node_cb(&amp;it-&gt;node)) memcpy(cp,&amp;it-&gt;node,sizeof(it-&gt;node)); /*对于“下一步”，每次找到一个键就停止*一次，因为相比较后面子节点分支中的内容*键本身字典序较小。*/if (it-&gt;node-&gt;iskey) &#123; it-&gt;data = raxGetData(it-&gt;node); return 1;&#125; Redis内“实际上”充满了引导注释，所以基本上你打开的每个文件都会包含很多引导注释。为什么要费这个力气呢？在这篇博客文章中所分析的所有注释类型中，这绝对是最主观的一种。我并不觉得没有引导注释的代码就不是好代码。但我坚信，如果人们认为Redis代码是可读的，部分原因就在于其中的引导注释。 引导注释还有一些别的用处。因为它们明确地将代码划分为独立的部分，所以我们能在合适的位置插入新代码，而不是随便加在其他代码后面。在代码附近设置相关语句能大大提高可读性。 引导注释能简要地告诉读者函数将要执行什么操作，所以如果你只对大框架感兴趣，则无需回过头去阅读函数。 琐碎注释 引导注释是非常主观的工具。不管你喜不喜欢，我反正超爱引导注释。 然而，引导注释可能会退化为极其糟糕的注释：它很容易变成“琐碎注释”（trivial comment）。 琐碎注释这种引导注释所带来的认知负荷和仅阅读相关代码比起来相差无几，甚至可能更高。以下这种琐碎注释正是许多书籍规劝你避免的。 array_len ++; / 增加数组的长度。 / 因此，如果你写引导注释的话，请避免写琐碎注释。 （代码）负债注释 负债注释是源代码内部硬编码的技术债务语句： C++收起 12345entries -= to_delete;marked_deleted += to_delete;if (entries + marked_deleted &gt; 10 &amp;&amp; marked_deleted &gt; entries/2) &#123; / * TODO：执行垃圾收集操作。* /&#125; FIXME，TODO，XXX，这些都是负债注释。总的来说这些注释不算好，我试图避免使用它们，但看起来不太可能。有时候，比起永远忘记一个问题，我更喜欢在源代码中放置一个节点。程序员至少应该定期查看这些注释，看看是否可以能改进一下表述，或者这些问题是否已不再相关或可以立即解决。 备份注释 备份注释是开发人员对某些代码块的旧版本甚至是整个函数做出的注释，因为他/她对新版本中运行的更改放不下心。令人费解的是，现在有了Git，人们却还在使用这类注释。我想人们对于丢失代码片段有一种不安全感，过去提交代码时，使用备份注释会显得更加理智可靠。 但源代码并不是用来备份的。如果你需要保存旧版本的函数或代码，说明你的工作尚未完成，也无法提交。要么确保新函数比过去的更好，要么只在开发树（development tree）中使用它，直到你确定为止。 备份注释是我分类中的最后一项。我们来做个总结。 总结 注释是和未来的代码读者聊天，读者们还能在Twitter上评价你的注释。所以在这个过程中，你真心地在审视自己所注释的内容是否“能让人接受”，看自己写得是否足够体面、足够好。如果不是，你就勤勤恳恳地再做一遍，拿出更好的注释来。 你可能认为编写注释不是个高端工作。毕竟你“会写代码”！但请考虑这一点：代码是一组语句和函数调用（或者你做的其他编程范例也一样）。如果代码写得不好，这些语句就没有多大意义。注释常常要求你进行一些设计过程，并从更深层次来理解你正在编写的代码。 最重要的是，为了写出好的注释，你必须培养自己的写作能力。这种写作技巧能帮你更好地编写电子邮件、文案、设计文档、博客文章和提交文件。 我写代码是因为我迫切想要与他人沟通交流、分享想法。注释能够为代码提供帮助，把作者的心血表现出来。说到底，我喜欢写注释，就像我喜欢写代码一样。]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-日志规范]]></title>
    <url>%2F2020%2F12%2F12%2FPrograming%2F%E8%BD%AC-%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[日志 日志是什么？ 日志，维基百科的定义是记录服务器等电脑设备或软件的运作。 日志文件提供精确的系统记录，根据日志最终定位到错误详情和根源。日志的特点是，它描述一些离散的（不连续的）事件。 例如：应用通过一个滚动的文件输出 INFO 或 ERROR 信息，并通过日志收集系统，存储到一些存储引擎（Elasticsearch）中方便查询。 日志有什么用？ 在上文中我们解释了日志的作用是提供精准的系统记录方便根因分析。那么具体在哪些具体方面它可以发挥作用？ 打印调试：即可以用日志来记录变量或者某一段逻辑。记录程序运行的流程，即程序运行了哪些代码，方便排查逻辑问题。 问题定位：程序出异常或者出故障时快速的定位问题，方便后期解决问题。因为线上生产环境无法 debug，在测试环境去模拟一套生产环境，费时费力。所以依靠日志记录的信息定位问题，这点非常重要。还可以记录流量，后期可以通过 ELK（包括 EFK 进行流量统计）。 用户行为日志：记录用户的操作行为，用于大数据分析，比如监控、风控、推荐等等。这种日志，一般是给其他团队分析使用，而且可能是多个团队，因此一般会有一定的格式要求，开发者应该按照这个格式来记录，便于其他团队的使用。当然，要记录哪些行为、操作，一般也是约定好的，因此，开发者主要是执行的角色。 根因分析（甩锅必备）：即在关键地方记录日志。方便在和各个终端定位问题时，别人说时你的程序问题，你可以理直气壮的拿出你的日志说，看，我这里运行了，状态也是对的。这样，对方就会乖乖去定位他的代码，而不是互相推脱。 什么时候记录日志？ 上文说了日志的重要性，那么什么时候需要记录日志。 系统初始化：系统或者服务的启动参数。核心模块或者组件初始化过程中往往依赖一些关键配置，根据参数不同会提供不一样的服务。务必在这里记录 INFO 日志，打印出参数以及启动完成态服务表述。 编程语言提示异常：如今各类主流的编程语言都包括异常机制，业务相关的流行框架有完整的异常模块。这类捕获的异常是系统告知开发人员需要加以关注的，是质量非常高的报错。应当适当记录日志，根据实际结合业务的情况使用 WARN 或者 ERROR 级别。 业务流程预期不符：除开平台以及编程语言异常之外，项目代码中结果与期望不符时也是日志场景之一，简单来说所有流程分支都可以加入考虑。取决于开发人员判断能否容忍情形发生。常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等。 系统核心角色，组件关键动作：系统中核心角色触发的业务动作是需要多加关注的，是衡量系统正常运行的重要指标，建议记录 INFO 级别日志，比如电商系统用户从登录到下单的整个流程；微服务各服务节点交互；核心数据表增删改；核心组件运行等等，如果日志频度高或者打印量特别大，可以提炼关键点 INFO 记录，其余酌情考虑 DEBUG 级别。 第三方服务远程调用：微服务架构体系中有一个重要的点就是第三方永远不可信，对于第三方服务远程调用建议打印请求和响应的参数，方便在和各个终端定位问题，不会因为第三方服务日志的缺失变得手足无措。 日志打印 Slf4j &amp; Logback Slf4j 英文全称为 “ Simple Logging Facade for Java ”，为 Java 提供的简单日志门面。Facade 门面，更底层一点说就是接口。它允许用户以自己的喜好，在工程中通过 Slf4j 接入不同的日志系统。 Logback 是 Slf4j 的原生实现框架，同样也是出自 Log4j 一个人之手，但拥有比 Log4j 更多的优点、特性和更做强的性能，Logback 相对于 Log4j 拥有更快的执行速度。基于我们先前在 Log4j 上的工作，Logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上 10 倍。在保证 Logback 的组件更加快速的同时，同时所需的内存更加少。 日志文件 日志文件放置于固定的目录中，按照一定的模板进行命名，推荐的日志文件名称： Plain Text收起 123当前正在写入的日志文件名：&lt;应用名&gt;[-&lt;功能名&gt;].log如：example-server-book-service-access.log已经滚入历史的日志文件名：&lt;应用名&gt;[-&lt;功能名&gt;].yyyy-MM-dd-hh.[滚动号].log 如：example-server-book-service-access.2019-12-01-10.1.log 日志变量定义 推荐使用 lombok（代码生成器） 注解 @lombok.extern.slf4j.Slf4j 来生成日志变量实例。 代码示例 Java收起 12345678910import lombok.extern.slf4j.Slf4j; @Slf4jpublic class LogTest &#123; public static void main(String[] args) &#123; log.info(&quot;this is log test&quot;); &#125; &#125; 日志配置 日志记录采用分级记录，级别与日志文件名相对应，不同级别的日志信息记录到不同的日志文件中。如有特殊格式日志，如 access log，单独使用一个文件，请注意避免重复打印（可使用 additivity**=“false”** 避免 ）。 参数占位格式 使用参数化形式 {} 占位，[] 进行参数隔离，这样的好处是可读性更高，而且只有真正准备打印的时候才会处理参数。 Java收起 1234// 正确示例，必须使用参数化信息的方式log.debug(&quot;order is paying with userId:[&#123;&#125;] and orderId : [&#123;&#125;]&quot;,userId, orderId);// 错误示例，不要进行字符串拼接,那样会产生很多 String 对象，占用空间，影响性能。及日志级别高于此级别也会进行字符串拼接逻辑。log.debug(&quot;order is paying with userId: &quot; + userId + &quot; and orderId: &quot; + orderId); 日志的基本格式 日志时间 作为日志产生的日期和时间，这个数据非常重要，一般精确到毫秒。 Plain Text 1yyyy-MM-dd HH:mm:ss.SSS 日志级别 日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。 主要使用如下的四个级别： DEBUG：DEUBG 级别的主要输出调试性质的内容，该级别日志主要用于在开发、测试阶段输出。该级别的日志应尽可能地详尽，开发人员可以将各类详细信息记录到 DEBUG 里，起到调试的作用，包括参数信息，调试细节信息，返回值信息等等，便于在开发、测试阶段出现问题或者异常时，对其进行分析。 INFO：INFO 级别的主要记录系统关键信息，旨在保留系统正常工作期间关键运行指标，开发人员可以将初始化系统配置、业务状态变化信息，或者用户业务流程中的核心处理记录到INFO日志中，方便日常运维工作以及错误回溯时上下文场景复现。建议在项目完成后，在测试环境将日志级别调成 INFO，然后通过 INFO 级别的信息看看是否能了解这个应用的运用情况，如果出现问题后是否这些日志能否提供有用的排查问题的信息。 WARN：WARN 级别的主要输出警告性质的内容，这些内容是可以预知且是有规划的，比如，某个方法入参为空或者该参数的值不满足运行该方法的条件时。在 WARN 级别的时应输出较为详尽的信息，以便于事后对日志进行分析。 ERROR：ERROR 级别主要针对于一些不可预知的信息，诸如：错误、异常等，比如，在 catch 块中抓获的网络通信、数据库连接等异常，若异常对系统的整个流程影响不大，可以使用 WARN 级别日志输出。在输出 ERROR 级别的日志时，尽量多地输出方法入参数、方法执行过程中产生的对象等数据，在带有错误、异常对象的数据时，需要将该对象一并输出。 DEBUG / INFO 的选择 DEBUG 级别比 INFO 低，包含调试时更详细的了解系统运行状态的东西，比如变量的值等等，都可以输出到 DEBUG 日志里。 INFO 是在线日志默认的输出级别，反馈系统的当前状态给最终用户看的。输出的信息，应该对最终用户具有实际意义的。从功能角度上说，INFO 输出的信息可以看作是软件产品的一部分，所以需要谨慎对待，不可随便输出。如果这条日志会被频繁打印或者大部分时间对于纠错起不到作用，就应当考虑下调为 DEBUG 级别。 由于 DEBUG 日志打印量远大于 INFO，出于前文日志性能的考虑，如果代码为核心代码，执行频率非常高，务必推敲日志设计是否合理，是否需要下调为 DEBUG 级别日志。 注意日志的可读性，不妨在写完代码 review 这条日志是否通顺，能否提供真正有意义的信息。 日志输出是多线程公用的，如果有另外一个线程正在输出日志，上面的记录就会被打断，最终显示输出和预想的就会不一致。 WARN / ERROR 的选择 当方法或者功能处理过程中产生不符合预期结果或者有框架报错时可以考虑使用，常见问题处理方法包括： 增加判断处理逻辑，尝试本地解决：增加逻辑判断吞掉报警永远是最优选择抛出异常，交给上层逻辑解决 抛出异常，交给上层逻辑解决 记录日志，报警提醒 使用返回码包装错误做返回 一般来说，WARN 级别不会短信报警，ERROR 级别则会短信报警甚至电话报警，ERROR 级别的日志意味着系统中发生了非常严重的问题，必须有人马上处理，比如数据库不可用，系统的关键业务流程走不下去等等。错误的使用反而带来严重的后果，不区分问题的重要程度，只要有问题就error记录下来，其实这样是非常不负责任的，因为对于成熟的系统，都会有一套完整的报错机制，那这个错误信息什么时候需要发出来，很多都是依据单位时间内 ERROR 日志的数量来确定的。 强调ERROR报警 ERROR 级别的日志打印通常伴随报警通知。ERROR的报出应该伴随着业务功能受损，即上面提到的系统中发生了非常严重的问题，必须有人马上处理。 ERROR日志目标 给处理者直接准确的信息：ERROR 信息形成自身闭环。 问题定位： 发生了什么问题，哪些功能受到影响 获取帮助信息：直接帮助信息或帮助信息的存储位置 通过报警知道解决方案或者找何人解决 线程名称 输出该日志的线程名称，一般在一个应用中一个同步请求由同一线程完成，输出线程名称可以在各个请求产生的日志中进行分类，便于分清当前请求上下文的日志。 opentracing 标识 在分布式应用中，用户的一个请求会调用若干个服务完成，这些服务可能还是嵌套调用的，因此完成一个请求的日志并不在一个应用的日志文件，而是分散在不同服务器上不同应用节点的日志文件中。该标识是为了串联一个请求在整个系统中的调用日志。 唯一字符串（trace id） 调用层级（span id） 通过搜索 trace id 就可以查到这个 trace id 标识的请求在整个系统中流转（处理）过程中产生的所有日志。 biz 标识 在业务开发中，我们的日志都是和业务相关联的，有时候是需要根据用户或者业务做聚类的，因此一次请求如果可以通过某项标识做聚类的时候，可以将聚类标识打印到日志中。 用户标识（user id） 业务标识（biz id） 日志记录器名称 日志记录器名称一般使用类名，日志文件中可以输出简单的类名即可，看实际情况是否需要使用包名和行号等信息。主要用于看到日志后到哪个类中去找这个日志输出，便于定位问题所在。 日志内容 禁用 System.out.println 和 System.err.println 变参替换日志拼接 输出日志的对象，应在其类中实现快速的 toString 方法，以便于在日志输出时仅输出这个对象类名和 hashCode 预防空指针:不要在日志中调用对象的方法获取值，除非确保该对象肯定不为 null，否则很有可能会因为日志的问题而导致应用产生空指针异常。 异常堆栈 异常堆栈一般会出现在 ERROR 或者 WARN 级别的日志中，异常堆栈含有方法调用链的系统，以及异常产生的根源。异常堆栈的日志属于上一行日志的，在日志收集时需要将其划至上一行中。 最佳实践 日志格式 Bash 12019-12-01 00:00:00.000|pid|log-level|[svc-name,trace-id,span-id,user-id,biz-id]|thread-name|package-name.class-name : log message 时间 pid，pid log-level，日志级别 svc-name，应用名称 trace-id，调用链标识 span-id，调用层级标识 user-id，用户标识 biz-id，业务标识 thread-name，线程名称 package-name.class-name，日志记录器名称 log message，日志消息体 日志模块扩展 日志模块是基于以下技术点做扩展的。 Slf4j MDC 实现原理（暂不开展详解，如有兴趣私下沟通） Opentracing Scope 原理（暂不开展详解，如有兴趣私下沟通） 在每个 tracing 链路中，将 Opentracing Scope 中的上下文信息放置 MDC 中，根据 Spring Boot Logging 扩展接口扩展的取值逻辑 **logging.pattern.level **的取值逻辑。 相关源码参考 [Spring Cloud Sleuth]github.com/spring-clou… 修改 logback 配置文件中每个 appender 的 pattern 为以下默认值即可实现标准化。 Bash 1%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;|$&#123;PID:- &#125;|%level|$&#123;LOG_LEVEL_PATTERN:-%5p&#125;|%t|%-40.40logger&#123;39&#125;: %msg%n logback.xml 节选 XML收起 12345678&lt;configuration&gt;&lt;property name=&quot;LOG_PATH&quot; value=&quot;$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;&quot;/&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;APP_NAME&quot; source=&quot;spring.application.name&quot; defaultValue=&quot;spring-boot-fusion&quot;&quot;LOG_PATTERN&quot; value=&quot;%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;|$&#123;PID:- &#125;|%level|$&#123;LOG_LEVEL_PATTERN:-%5p&#125;|%t|%-40.40logger&#123;39&#125;: %msg%n&quot;&quot;fileInfo&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;$&#123;LOG_PATH&#125;/$&#123;APP_NAME&#125;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;$&#123;LOG_PATH&#125;/$&#123;APP_NAME&#125;&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt;$&#123;LOG_PATTERN&#125;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;复制代码 代码使用示例： Plain Text收起 12345678910@Overridepublic Result&lt;PagingObject&lt;SimpleResponse&gt;&gt; page(@RequestParam(value = &quot;page-num&quot;, defaultValue = &quot;1&quot;) int pageNum, @RequestParam(value = &quot;page-size&quot;, defaultValue = &quot;10&quot;) int pageSize) &#123; LogStandardUtils.putUserId(&quot;userId123&quot;); LogStandardUtils.putBizId(&quot;bizId321&quot;); producerService.sendMsg(&quot;xxx&quot;); simpleClient.page(pageNum, pageSize); return new Result&lt;&gt;(simpleService.page(pageNum, pageSize));&#125;复制代码 日志记录 Bash收起 123456782019-12-04 16:29:08.223|43546|INFO|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.n.u.concurrent.ShutdownEnabledTimer : Shutdown hook installed for: NFLoadBalancer-PingTimer-example-server-order-service2019-12-04 16:29:08.224|43546|INFO|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.netflix.loadbalancer.BaseLoadBalancer : Client: example-server-order-service instantiated a LoadBalancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=example-server-order-service,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:null2019-12-04 16:29:08.234|43546|INFO|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.n.l.DynamicServerListLoadBalancer : Using serverListUpdater PollingServerListUpdater2019-12-04 16:29:08.247|43546|INFO|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.n.l.DynamicServerListLoadBalancer : DynamicServerListLoadBalancer for client example-server-order-service initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=example-server-order-service,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:ConsulServerList&#123;serviceId=&apos;example-server-order-service&apos;, tag=null&#125;2019-12-04 16:29:08.329|43546|WARN|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.p.f.l.ctl.common.rule.StrategyRule : No up servers available from load balancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=example-server-order-service,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:ConsulServerList&#123;serviceId=&apos;example-server-order-service&apos;, tag=null&#125;2019-12-04 16:29:08.334|43546|WARN|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.p.f.l.ctl.common.rule.StrategyRule : No up servers available from load balancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=example-server-order-service,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:ConsulServerList&#123;serviceId=&apos;example-server-order-service&apos;, tag=null&#125;2019-12-04 16:29:08.342|43546|ERROR|[example-server-book-service,ac613cff04bac8b1,4a9adc10fdf0eb5,userId123,bizId321]|XNIO-1 task-4|c.p.f.w.c.advice.ExceptionHandlerAdvice : 当前程序进入到异常捕获器，出错的 url 为：[ http://127.0.0.1:10011/simples ]，出错的参数为：[ &#123;&quot;querystring&quot;:&quot;&#123;&#125;&quot;,&quot;payload&quot;:&quot;&quot;&#125; ]java.lang.RuntimeException: com.netflix.client.ClientException: Load balancer does not have available server for client: example-server-order-service 实践说明 普通格式日志 Bash 12019-11-26 15:01:03.332|1543|INFO|[example-server-book-service,28f019d57b8336ab,630697c7f34ca4fa,105,45982043|XNIO-1 task-42]|c.p.f.w.pay.PayServiceImpl : order is paying with userId: 105 and orderId: 45982043 普通日志前缀是固定的，可以固定分词索引，方便更快的查询分析。 特定格式日志 以 access 日志为例 Bash收起 12345678910111213142019-11-26 15:01:03.332|1543|INFO|[example-server-book-service,28f019d57b8336ab,630697c7f34ca4fa,105,45982043|XNIO-1 task-42]|c.p.f.w.logging.AccessLoggingFilter : &gt; url: http://liweichao.com:10011/actuator/health&gt; http-method: GET&gt; request-header: [Accept:&quot;text/plain, text/*, */*&quot;, Connection:&quot;close&quot;, User-Agent:&quot;Consul Health Check&quot;, Host:&quot;liweichao.com:10011&quot;, Accept-Encoding:&quot;gzip&quot;]&gt; request-time: 2019-11-26 15:01:03.309&gt; querystring: -&gt; payload: -&gt; extra-param: - &lt; response-time: 2019-11-26 15:01:03.332&lt; take-time: 23&lt; http-status: 200&lt; response-header: [content-type:&quot;application/vnd.spring-boot.actuator.v2+json;charset=UTF-8&quot;, content-size:&quot;15&quot;]&lt; response-data: &#123;&quot;status&quot;:&quot;UP&quot;&#125; 特定格式日志可按格式创建索引更方便聚焦查询分析和告警，如根据 take-time，http-status，biz-code 等值。 作者：猿天地 链接：https://juejin.im/post/6844904030330683405 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java杂记]]></title>
    <url>%2F2020%2F12%2F12%2FJava%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Java Proto对象转byte http://itindex.net/detail/30996-%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95 12345678910111213public byte[] serialize(Object obj) throws IOException &#123;Map data=(Map)obj;ByteArrayOutputStream baos= new ByteArrayOutputStream();CodedOutputStream cos=CodedOutputStream.newInstance(baos);cos.writeInt32NoTag(data.size());for(Map.Entry e:data.entrySet())&#123;cos.writeStringNoTag(e.getKey());cos.writeInt64NoTag(e.getValue());&#125; cos.flush();return baos.toByteArray();&#125; Java无符号类型 https://blog.csdn.net/CrownP/article/details/88834275?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control Java park和unpark的内存消耗 https://juejin.cn/post/6844904001067040781 Completeable Future https://colobu.com/2016/02/29/Java-CompletableFuture/#主动完成计算]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-11-技术文摘]]></title>
    <url>%2F2020%2F12%2F12%2FTechnicalDigest%2F2020-11-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[Big List Of 20 Common Bottlenecks http://highscalability.com/blog/2012/5/16/big-list-of-20-common-bottlenecks.html 数据库 Working size超过可用内存 Working Size怎么理解？肯定不是指数据库的大小，应该是在保证业务指标——响应时间、QPS的情况下，数据库使用的内存大小。其超过可用内存后的直接影响就是系统开始使用“swap”，从而大大降低DB的性能。所以，DB服务器要有充足的内存。 长查询和短查询 指运行时间很长和很短的查询。运行时间很长的查询，要是么很消耗内存、CPU，比如联合查询，要么是很消耗磁盘I/O，比如没有用到索引的“遍历”——这应该算是“事故”。长查询对“DB性能”的影响是显而易见的。 短查询，我可能理解有误，咨询了我们的DBA，认为大概是“短连接”的意思。DB的连接，也是消耗资源的，大约每个2M内存的样子，所以，Java使用“连接池”来避免频繁连接数据库。当短连接并发过多的时候，建议改用“长连接”来避免不必要的开销，提代高性能。 写冲突（需要用锁的场景） 写冲突的场景，通常会遇到“锁”，如MyISA的“表锁”，与InnoDB的“行锁”，当遇上“锁”时，只能有一个“用户”在写，其他用户均需要等待。当有大量的冲突时，用户需要等待的时间就越长，“锁”机制会导致CPU的有效利用率大大下降——花在“获取锁”上的CPU时间变多，从而导致DB可用的有效CPU时间变少，性能下降。 大量的Join操作消耗内存 Join操作本身比较消耗内存和CPU，尽可能不用或少用。 虚拟化 共享磁盘，磁盘随机读严重 虚拟化场景，使用共享磁盘（HDD），磁盘会成为瓶颈。磁盘差不多是计算机上最慢的设备了。随机I/O能力极差。 网络I/O波动 因为虚拟化场景同一台物理机上的多个VM之间的网络是共享的，会互相影响。 程序 线程：死锁，与“事件驱动型”（方案）相比过重，debug，非线性扩展，等等 事件驱动编程：回调的复杂度，如何保存函数状态，等等 缺乏“profiling”、跟踪、日志机制。 耦合严重，单独故障，不可水平扩展，等等 有状态的应用（不易水平扩展） 糟糕的设计：开发都开发了一个程序，在自己的电脑上运行良好；到了生产环境，对于两三个用户，也运行良好。等到数月、数年过后，用户量上来以后，程序不能运行了，需要重构、重写。 算法复杂性 依赖其他服务，比如DNS查询以及其它，你可会被阻塞。 栈空间 磁盘 本地磁盘访问 随机磁盘I/O（引发大量磁盘寻道） 磁盘碎片（增加寻道机会和时间） 当写入数据量超过SSD空间量以后，SSD性能的下降 操作系统 Fsync flushing, linux buffer cache filling up TCP Buffer过小 文件句柄限制 功率分配（CPU节能？） 缓存 不使用Memcached(数据库前端) HTTP：headers,etags，不压缩，等等 不充分利用浏览器的缓存 字节码缓存（比如PHP的APC） 处理器的L1/L2缓存：这是一个重要的“瓶颈”。保持重要的热数据在L1/L2缓存中。这个关系到方方面面太广， 处理器 CPU超载 上下文切换-&gt;一个核上太多线程，这可能是因为“坏运气”或者是Linux调度器；太多系统调用，等等 I/O等待-&gt;所有CPU以相同的速度在等待（同时等待） CPU缓存：未完…… 主板能力（其它限制CPU性能的因素） 网络 网卡最大带宽，IRQ饱和，软中断用光CPU资源 DNS查询 丢包 意外路由 网络磁盘访问（比如NFS, drbd） 共享SANs 服务故障-&gt;服务不响应 进程 测试时间 程序调试时间 团队大小 预算 代码“欠债” 内存 OOM-&gt;杀进程，使用交换甚至导致死机 OOM导致磁盘超负荷（因为swap） 内存管理库极限 内存碎片 Java中会导致GC停顿，速度变慢 C中，导致malloc()分配内存变慢 最新性能测试：Kafka、Pulsar 和 Pravega 哪个最强？ https://www.infoq.cn/article/fp1TLWAUROkOXxq15qGf Pravega 的前景 https://www.zhihu.com/question/310212569/answer/581672480 爱奇艺如何处理千亿级数据 https://www.infoq.cn/article/zI6d1pYAlyoLhQojILXq cherry pick使用 https://blog.csdn.net/FightFightFight/article/details/81039050 我敢说 80% 的程序员都掉进了「老鼠赛跑」的陷阱 https://xie.infoq.cn/article/e0c5a94acbaabff00aa065c03 不要天天谈什么框架，什么库，框架每年层出不穷，可是扒下框架那层炫酷漂亮的外衣，里面还是那些最基础的知识和原理。就是这些算法，数据结构，计算机网络，计算机原理这些看似基础的东西。如果这些掌握扎实了，你才有更加深一步的可能。 我们应该学会提升认知效率，而非技术效率。 软件架构中的解耦 https://www.infoq.cn/article/8hlh2qEWP1Y00qumdMQj 香蕉法则 讲到自主开发软件系统，这里先引入一个《哈佛商业评论》中讲述过的有趣理论。 现在有很多企业为了增加雇员与企业的感情，会给员工提供免费的下午茶和水果。时间久了就会发现一个有意思的现象，在水果区，香蕉永远比橙子更受青睐。而且更值得玩味的现象是，当香蕉没了橙子还剩很多时，想吃水果的雇员也极少会去选择橙子。 有人专门研究了这一现象，他们在拜访过数百家大型企业的职场人士之后得出结论：在职场上，香蕉之所以会比橙子更受欢迎，其原因只是因为香蕉比橙子更容易剥皮。其实，有点生活常识的就会知道，香蕉不仅容易剥，而且吃完后也容易处理。但反观橙子，不仅处理起来非常麻烦，容易喷溅的橙汁还可能弄脏手和衣服。 社会心理学家认为，这是人类长期进化而来的一种天性，可以帮助人类更高效的生活在这个社会，他们称之为“香蕉法则”。 香蕉法则让我立刻联想起，罗伯特弗里茨（Robert Fritz）所著的《最小阻力之路》（The Path of Least Resistance），书中提出了一个观点，即结构决定行为，所有的能量都沿着最小阻力之路进行。 两种理论有异曲同工之妙，二者都表达出了同一个意思。即，但凡有多条路可选，人一定会选最好走的那条路。因为这条路受到的阻力最小。所以，当下有很多的设计师和程序开发者都从中获得了更多见解与灵感。 我们不妨试着将香蕉法则与最小阻力理论引入软件的开发与设计中。大型企业旗下的开发团体通常都是非常忙碌的，他们每一个项目的时间预算都非常紧张，如果遇到复杂的软件开发项目，那单靠开发者加班加点将很难按时完成任务。所以，想要解决这一难题，就得减少开发过程中会拖延开发进度的各种复杂、重复的工作。 关于【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案 https://juejin.im/post/6844903807797690376 Release Train Release Train直译过来意思为：发版火车/火车发版。火车大家不陌生，它有一个显著的特点：定时定点发车。这里的发车在软件领域就等同于软件的发版。 为何需要Release Train发版模式？ 在公司还很小很小的时候，整个公司可能只有一个软件，版本发布非常的简单，没什么需要协调的，发就完了。但是，一旦公司快速发展变得比较大后，核心产品功能数以十、百计，各功能模块由不同的团队负责，沟通成本明显升高，单单在版本上稍不注意就会产生各种问题，很容易给人一种“乱如麻”的感觉。 使用Release Train的发版模式就能很大程度上避免这些问题，可以这样做：规定每个月的最后一天（精确的发版日期）需要发一版（类比于火车发车），那么就可以以这个时间点为deadline，参与的的各方包括产品经理、RD、QA等等都提前沟通好需求内容，并做好计划，充分做好统一发车的准备。在这期间，如果中间某一团队出现问题跟不上节奏了，那么请及时下车（前提是控制好下车的影响面），不要影响整体发车时间点。 总的来讲：火车是按点准时出发的，各方应按点上车，倘若本次赶不上车的那么就请等下一趟车。通过这种方式可以确保软件产品的持续迭代，保证产品的稳定性，这就是Release Train发版模式。 AWS 运维仪表盘最佳实践 https://aws.amazon.com/builders-library/building-dashboards-for-operational-visibility/ 如何进行网络框架的学习和设计 https://www.infoq.cn/article/27hRZ4qgcNXHuk7NauMe 为什么每家企业都在构建内部Kubernetes平台？ https://www.infoq.cn/article/uOMfYqHxRArwJcMIGctL 在许多情况下，应用程序有时会变得太大而无法在本地运行。那时，从本地开发环境转移到基于云的 Kubernetes 开发环境通常是有意义的。 新技术学习不完全指北 https://juejin.cn/post/6898953413250252814 严肃学习是指通过权威的、一手的、经典的、系统化的学习材料进行学习的过程。 高强度间歇性训练方法，原本是用以健身，现在我们借用来描述知识学习的一种时间规划策略。 找到严肃材料之后，只达成了第一个层面的严肃性。第二层面的严肃性，需要我们自我建设。世界上的严肃材料这么多，如何向我们的大脑证明眼前这一堆确实是严肃的、重要的材料呢？ 一个有效途径是，让这些材料反复出现，即高频次、高密度、高强度地出现。 找到严肃的学习材料，扎实且认真地学习了这些材料之后，下一个阶段是——超纲训练。 看过一遍书，不代表充分理解了书里的知识。我们要去证明自己确实在一定程度上领会了知识。 如何证明？ 做那些没有参考答案的训练，即超纲训练。 网易云音乐推荐中的用户行为序列深度建模 https://www.infoq.cn/article/caqErFHGX7S1LLX1Y2wg 什么是分布式任务调度 https://zhuanlan.zhihu.com/p/136843131]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数修饰符]]></title>
    <url>%2F2020%2F12%2F12%2FC%2B%2B%2FC-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[C++ 函数修饰符学习 https://tlanyan.me/cpp-function-modifier-summary/ 函数名前 返回值类型 返回值类型是C++中定义函数的必备部分，这些修饰符包括void，(unsigned) int，bool等内置基本数据类型和自定义类型，也包括修饰返回值const关键字（如const int*），还包括C++11中新增的类型自动推导auto关键字。 template template关键字声明函数是模板函数。 virtual virtual关键字声明函数是虚函数，可被子类覆盖。 inline inline关键字提示编译器应将函数内联。 srtatic static修饰类的成员函数时指示函数是静态成员函数，不从属于具体对象；修饰单独的函数时，限定函数的可见范围为本文件内。 extern extern关键字声明一个定义在外部的函数 explicit explicit关键字在C++11新增，只用于构造函数，指定构造函数要显式定义，不能隐式转换。 friend friend关键字声明类的友元函数，在函数内可直接访问对象的私有或受保护成员及成员函数。 constexpr C++11中新增，指示函数返回常量表达式（可以简单理解为返回字面量）。 函数名后 noexcept https://www.cnblogs.com/sword03/p/10020344.html https://www.zhihu.com/question/30950837 noexcept关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。 如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。 const 表示函数不会修改对象（或者说调用期间对象不变），注意不包括mutable修饰的成员变量 volatile 类似于const修饰的函数，表示对象状态可能随时会改变；const修饰的函数内只能调用自身的const成员方法，同理volatile函数内也只能调用自身volatile成员函数。 &amp; C++11引入的功能，左值引用限定符，指示函数只能被左值对象调用。 &amp;&amp; C++11引入，右值引用限定符，指示函数只能被右值调用。如果函数没有引用限定符修饰，左值和右值均可调用。一个引用限定例子： C++收起 123456789101112#include &lt;iostream&gt; struct S &#123; void f() &amp; &#123; std::cout &lt;&lt; &quot;lvalue\n&quot;; &#125; void f() &amp;&amp;&#123; std::cout &lt;&lt; &quot;rvalue\n&quot;; &#125; &#125;; int main()&#123; S s; s.f(); // 打印“ lvalue ” std::move(s).f(); // 打印“ rvalue ” S().f(); // 打印“ rvalue ” &#125; override C++11引入的功能，声明成员函数覆盖父类的虚函数。声明为override后，子类声明时可不写virtual。 final C++11引入，指示函数是最终实现，子类不应当再定义或覆盖，可与override同时使用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-10-技术文摘]]></title>
    <url>%2F2020%2F12%2F12%2FTechnicalDigest%2F2020-10-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[源码分析怎么做 https://xie.infoq.cn/article/edfa7ea32baaff2dbf21ff766 源码分析应从软件整体入手而不是代码 源码分析的目的 代码要解决什么问题、 代码如何解决问题的 代码为什么要这么解决问题 源码分析重要的是分析，是以软件为切入点，从务实的角度，讲解代码要解决什么问题、代码如何解决问题的以及代码为什么要这么解决问题，绝对不是大篇幅的复制粘贴真正的源代码。 我们在编程的时候强调不要测试三方库的行为，应该测试业务逻辑的行为。这是因为软件之间应该有清晰的限界上下文。源码分析也一样， 这其中最有意义的是模块的逻辑划分和交互图，因为这个是我们从一个高的抽象层次来理解一个模块的助力。 其次比较有意义的是时序图。对于关键的交互流程来说，时序图是一种细化的交互流程表达方式，往往能够指导代码的实现以及排查交互的问题。 UML 图真的是没什么大用。《领域驱动设计》里面就提过，很多 UML 图在某些地方过于细致，同时在某些地方又有很多遗漏。细致的点在于人们认为必须将所有要编码的对象都放到建模工具中，而细节过多的结果是不分轻重。 一个中心两个基本点 一个中心是源码分析要从软件入手而不是源代码本身入手，从务实的角度分析代码要解决什么问题、代码如何解决问题的以及代码为什么要这么解决问题。 两个基本点包括分析的过程要逐层深入，从高层次的抽象完整地讲解，低层次的细节只需要讲解要点；以及抓大放小，对旁路的、不重要的内容一笔带过或完全不提。 最后在技巧上，不要选择 UML 图或者复杂的时序图作为辅助说明的手段，它们只会把事情变得更复杂；应该选择模块划分图、模块交互图和功能流程图作为辅助说明的手段。不得不提的是，不要大段大段地贴源代码！ Code Review怎么做 第一层（检查是否是打磨过的代码） 代码是否足够简单，是否容易阅读，是否容易理解 代码有没有陌生的或者不符合常人思维的概念 代码的排版是否符合编程规范，风格是否和现有代码一致 代码是否容易测试，是否有相应的测试代码 代码是否有明显的重复，是否拷贝了其他模块的代码 第二层（宏观上） 新增的代码和已有的架构设计是否一致。 上下文的切分是否合理。 依赖是否正交。（编程中正交这个词指相互独立，不可替代，并且组合起来可实现其它功能。） 第三层（微观上） 语言最佳实践。 算法的时间或者空间复杂度。 设计模式的使用。 安全问题。 非功能性约束之性能-性能银弹：缓存 一般我们使用缓存来存储一些内容，这些内容有如下一些特点（符合一条或多条）： 使用较频繁 变更不频繁 获取较耗时 多系统访问 主动缓存 用户主动选择和修改缓存数据的缓存 被动缓存 根据请求自动添加缓存数据的缓存 缓存置换算法（for 被动） RR（Random replacement） FIFO（First in first out） LIFO（Last in first out） MRU（Most recently used） LFU（Least-frequently used） LRU（Least recently used） TLRU（Time aware least recently used） PLRU（Pseudo-LRU） LRU-K SLRU（Segmented LRU） MQ（Multi queue） LFRU（Least frequent recently used） LFUDA（LFU with dynamic aging） LIRS（Low inter-reference recency set） ARC（Adaptive replacement cache） CAR（Clock with adaptive replacement） Pannier（Container-based caching algorithm for compound objects） 做好分库分表其实很难 https://xie.infoq.cn/article/ee41e234529bb31ab1de4c69b https://xie.infoq.cn/article/378822829ef1a4563683b5e0e 是否需要分 单台数据库的能力并非想象中那么脆弱。就算是mysql单表数据量大部分场景下也在百万级别（当然这和存储的具体数据格式有关），sqlserver更是不在话下，我司用的sqlserver，单表千万级别数据的大有所在，亿级的也有几个，Oracle更是不用多说。 分库 根据业务分 推荐大家根据业务来进行划分 务按照规则划分好边界，每个业务对应的数据库自然而然就诞生了，不要站在数据库的层面上去给业务分库。 统一业务横向分 但是如果分配到多个服务器上，意味着这个业务整体的最大IO得到了提升，在一定程度上要比拆表效果要好，当然如果用到了表分区，每个分区散落在不同的物理磁盘上，也不一定比分库方式差。 分表 代价 数据表垂直切分之后，原来一次查询有可能会变为连表的join查询，在一定程度上会有性能损失。 数据表横向切分需要一定的规则，常用的主要有两种规则：范围切分和哈希值切分。范围切分是指按照某个字段的范围来切分，比如用户表按照用户ID来切分，id为1到10万的位于User表1中，100001到200000万的位于User2中，这样切分的优势是，可以无限的扩容下去，不用考虑数据迁移的问题，劣势就是新表和旧表数据分布不均匀，而且分表的范围选取有一定难度，范围太小会导致表太多，太大会导致问题根本上没有解决的困惑。另外一种分表策略就是把某一列按照哈希值来路由到不同的表中，同样以用户ID为例，假如我们一开始就规划了10个数据库表，路由算法可以简单地用 user_id %10的值来表示数据所属的数据库表编号，ID为985的用户放到编号为 5的子表中，ID为10086的用户放到编号为 6 的字表中。这种切分规则的优势是每个表的数据分布比较均匀，但是后期扩容会设计到部分数据的迁移工作。 表拆分之后如果遇到有order by 的操作，数据库就无能为力了，只能由业务代码或者数据库中间件来完成了。 当有搜索的业务需求的时候，sql语句只能是Join多个表来进行连表查询了，类似的还有统计的需求，例如count的统计操作。 Fluid Fluid是一个开源的Kubernetes原生的分布式数据集编排和加速引擎，主要服务于云原生场景下的数据密集型应用， https://developer.aliyun.com/article/775574?spm=a2c6h.12873581.0.0.5ce86c4dtRCO1D 深入Spark （一）内存计算的由来 https://www.infoq.cn/article/oPpQzsJIFopeBpzVcbx7 RDD RDD（Resilient Distributed Datasets），全称是“弹性分布式数据集”。 为了弄清楚 RDD 的基本构成和特性，我们从它的 5 大核心属性说起。 属性名 成员类型 属性含义 dependencies 变量 生成该 RDD 所依赖的父 RDD compute 方法 生成该 RDD 的计算接口 partitions 变量 该 RDD 的所有数据分片实体 partitioner 方法 划分数据分片的规则 preferredLocations 变量 数据分片的物理位置偏好 （二）DAG https://www.infoq.cn/article/LBzKJPoaFAre5c0cI4ur 2w 字 + 40 张图带你参透并发编程！ https://xie.infoq.cn/article/aa1587c2bb3dcc80579f63260 并发性是操作系统非常重要的特征，操作系统具有同时处理和调度多个程序的能力，比如多个 I/O 设备同时在输入输出；设备 I/O 和 CPU 计算同时进行；内存中同时有多个系统和用户程序被启动交替、穿插地执行。操作系统在协调和分配进程的同时，操作系统也会为不同进程分配不同的资源 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。 竞态条件也就好定义了，它指的就是两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition) ，线程切换是导致竞态条件出现的诱导因素 volatile 是一种轻量级的 synchronized，也就是一种轻量级的加锁方式，volatile 通过保证共享变量的可见性来从侧面对对象进行加锁。可见性的意思就是当一个线程修改一个共享变量时，另外一个线程能够 看见 这个修改的值。volatile 的执行成本要比 synchronized 低很多，因为 volatile 不会引起线程的上下文切换。 IO https://xie.infoq.cn/article/95e01c862c66bf956a30daed2 BIO、NIO and AIO BIO：同步阻塞IO NIO：同步非阻塞IO AIO：异步非阻塞IO 文件权限 每个权限位有3个bit r（Read）：代表该文件可以被当前用户读，操作权限的序号是 100 w（Write）：代表该文件可以被当前用户写，操作权限的序号是 010 x（Execute）：该文件可以被当前用户执行，操作权限的序号是 001 Linux 下文件的操作权限分为三种用户： 文件所有者：拥有的权限是红框中的首位上三个bit，-代表没有某个权限 文件所在组的所有用户：拥有的权限是红框中的中间三个bit 其它组的所有用户：拥有的权限是红框中的最后三个bit GotW #91 Solution: Smart Pointer Parameters https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/ 精准测试 https://www.infoq.cn/article/xUu91CRqA4HcJz8UoMJS 精准测试的概念 借助一定的技术手段、通过辅助算法对传统软件测试过程进行可视化、分析及优化的过程，使得测试过程更加可视化、智能、可信和精准。 性能优化 https://www.infoq.cn/article/bm8pD6jDPYTW3wV6D6Z6 那么，在做性能优化时，本质上也是从“优化时间”、“优化空间”、“时空互换（用时间换空间或用空间换时间）”三个方向去思考，然后在空间、时间上不停地做取舍。 数据库缓存 oceanBase存储引擎的设计哲学和应用实践 https://zhuanlan.zhihu.com/p/78183692 [玩转MySQL之四]MySQL缓存机制 https://zhuanlan.zhihu.com/p/55947158 tidb 下推结果缓存 https://docs.pingcap.com/zh/tidb/stable/coprocessor-cache 内核干货 | 数据库存储引擎如何利用好CPU缓存 https://developer.aliyun.com/article/750668?spm=a2c6h.14164896.0.0.3f1b4185PzqStT CPU缓存一致性 https://xie.infoq.cn/article/2b40b30085796b41752c88e61]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘空间不足的排查方法]]></title>
    <url>%2F2020%2F12%2F12%2FLinux%2F%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[磁盘空间不足原因及排查方法 https://blog.csdn.net/jiedao_liyk/article/details/78497625 不足原因： block满 df -h inode满 df -i 文件被占用一直没被彻底删除 lsof |grep deleted]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux运维</tag>
        <tag>故障排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Include路径顺序]]></title>
    <url>%2F2020%2F12%2F12%2FC%2B%2B%2FC-Include%E8%B7%AF%E5%BE%84%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C++ Include C++ 中include头文件时&lt;&gt;与&quot;&quot;的区别 #include &lt;&gt;格式：引用标准库头文件，编译器从标准库目录(IncludePath)开始搜索 #incluce &quot;&quot;格式：引用非标准库的头文件，编译器从用户的工作目录开始搜索，然后再在标准位置寻找文件。 Include 搜索过程 #include “headfile.h”引用头文件的搜索顺序为： 先搜索当前目录 然后搜索-I指定的目录 再搜索gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH） 最后搜索gcc的内定目录：/usr/include，/usr/local/include，/usr/lib/gcc/x86_64-redhat-linux/4.1.1/include各目录存在相同文件时，先找到哪个使用哪个。 #include &lt;headfile.h&gt;引用头文件的搜索顺序为： 先搜索-I指定的目录 然后搜索gcc的环境变量CPLUS_INCLUDE_PATH 最后搜索gcc的内定目录：/usr/include，/usr/local/include，/usr/lib/gcc/x86_64-redhat-linux/4.1.1/include 各目录存在相同文件时，先找到哪个使用哪个。 库搜索过程 编译时，库文件搜索路径： gcc会去找-L 再找gcc的环境变量LIBRARY_PATH 再找内定目录 /lib /usr/lib /usr/local/lib，这是当初compile gcc时写在程序内的 运行时，动态库搜索路径： 编译目标代码时指定的动态库搜索路径（这是通过gcc 的参数&quot;-Wl,-rpath,“指定。当指定多个动态库搜索路径时，路径之间用冒号”：&quot;分隔） 环境变量LD_LIBRARY_PATH指定的动态库搜索路径（当通过该环境变量指定多个动态库搜索路径时，路径之间用冒号&quot;：&quot;分隔） 配置文件/etc/ld.so.conf中指定的动态库搜索路径； 默认的动态库搜索路径/lib； 默认的动态库搜索路径/usr/lib。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pthread_barrier_t]]></title>
    <url>%2F2020%2F12%2F12%2FC%2B%2B%2Fpthread-barrier-t%2F</url>
    <content type="text"><![CDATA[pthread_barrier_t 概念 barrier是用户协调多个线程并行工作的同步机制 原理：屏障允许每个线程等待，直到所有的合作线程都到达某一点（屏障），然后从该点继续执行工作 初始化和释放 int pthread_barrier_init(pthread_barrier_t *restrict barrier,const pthread_barrierattr_t *restrict attr,unsigned int count)： **功能：**对屏障变量进行初始化 参数： **参数1：**初始化的屏障变量 **参数2：**屏障初始化时的属性。如果用默认属性，此处填NULL（屏障属性见文章：https://blog.csdn.net/qq_41453285/article/details/90904886） **参数3：**用此参数指定，在允许所有线程继续执行之前，必须到达屏障的线程数目。当到达了这个数目之后就可以继续执行 int pthread_barrier_destroy(pthread_barrier_t *barrier)： **功能：**屏障变量的反初始化，释放销毁 **参数：**屏障变量 如果在pthread_barrier_destroy之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失 **备注（重点）：**此函数只是反初始化屏障变量，并没有释放内存空间，如果屏障变量是通过malloc等函数申请的，那么需要在free掉读屏障变量之前调用pthread_barrier_destroy函数 同步wait int pthread_barrier_wait(pthread_barrier_t *barrier); **功能：**线程调用该函数用来表示自己已经到达了屏障 **工作原理：**如果线程调用这个函数发现屏障的线程计数还未满足要求，那么线程就会进入休眠状态。如果线程调用此函数之后，发现刚好满足屏障计数，那么所有的线程都被唤醒 返回值:成功返回0或者PTHREAD_BARRIER_SERIAL_THREAD；否则返回错误编号 **返回值的注意事项：**如果一个线程调用该函数返回PTHREAD_BARRIER_SERIAL_THREAD，那么其他在屏障中的线程就返回0.这使得一个线程可以作为主线程，它可以工作在其他所有线程已经完成的工作结果上]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++拾遗]]></title>
    <url>%2F2020%2F12%2F12%2FC%2B%2B%2Fc-%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[constexpt使用 https://www.cnblogs.com/DswCnblog/p/6513310.html sleep、yield、busy Spin的区别 sleep 交出cpu 等待SIGALRM唤醒重新调度 yield 交出CPU时间片 等待下次调度 busy Spin 一直占用cpu时间片 C++ 函数模板——返回值 https://blog.csdn.net/caroline_wendy/article/details/17003679 函数模板的返回值也可以定义为模板参数(template parameter), 但是由于无法推导(deduce), 需要显式(explicit)指定; 由于显式指定的顺序是从左至右, 返回值参数尽量放在左面,其余函数参数可以通过传入实参(argument)进行推导; 【C++】 variant https://www.cnblogs.com/thinkway/p/6743684.html https://en.cppreference.com/w/cpp/utility/variant c++17标准中引入了variant来作为union的类型安全替代品。它可以在任意时间保存模板参数列表中某一类型的值或者空值。 C++ handle 在编程时常常看到Handle这个概念。参照：https://stackoverflow.com/questions/1303123/what-is-a-handle-in-c/1303180#1303180 可以了解到，handle是指向某些resource的索引或者工具。你本身无法从handle中获得资源的信息，但将其传给API后就可以进行很多操作。 还有一类是Opaque handle，这一类handle 你在定义时也不能知道其中的内容信息。见：https://www.geeksforgeeks.org/opaque-pointer/ C++ 类成员函数中访问同类对象的私有成员 https://blog.csdn.net/walle_love_eva/article/details/9151273 C++的访问修饰符的作用是以类为单位，而不是以对象为单位。 类方法是所有该类对象共同使用的，因此不存在每个对象有一组类方法的副本。类方法自然可以访问所有该类对象的私有成员。 模板元编程 https://www.cnblogs.com/liangliangh/p/4219879.html GTest 值参数化测试 https://www.cnblogs.com/jycboy/p/6118073.html C++ 函数的类型 123456789101112131415161718// store a call to a member functionstd::function&lt;void(const Foo&amp;, int)&gt; f_add_display = &amp;Foo::print_add;const Foo foo(314159);f_add_display(foo, 1);f_add_display(314159, 1); // store a call to a data member accessorstd::function&lt;int(Foo const&amp;)&gt; f_num = &amp;Foo::num_;std::cout &lt;&lt; "num_: " &lt;&lt; f_num(foo) &lt;&lt; '\n'; // store a call to a member function and objectusing std::placeholders::_1;std::function&lt;void(int)&gt; f_add_display2 = std::bind( &amp;Foo::print_add, foo, _1 );f_add_display2(2); // store a call to a member function and object ptrstd::function&lt;void(int)&gt; f_add_display3 = std::bind( &amp;Foo::print_add, &amp;foo, _1 );f_add_display3(3); C++服务编译耗时优化原理及实践 JeMalloc https://zhuanlan.zhihu.com/p/48957114 C++ ROV RVO是Return Value Optimization的缩写，即返回值优化，NRVO就是具名的返回值优化，为RVO的一个变种，此特性从C++11开始支持。 C++lambda表达式 https://www.jianshu.com/p/d686ad9de817 一文读懂C++右值引用和std::move https://zhuanlan.zhihu.com/p/335994370 但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升 除非设计不允许移动，STL类大都支持移动语义函数，即可移动的。 另外，编译器会默认在用户自定义的class和struct中生成移动语义函数，但前提是用户没有主动定义该类的拷贝构造等函数(具体规则自行百度哈)。 因此，可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用std::move触发移动语义，提升性能。 C++ 完美转发 forward原理 https://www.cnblogs.com/5iedu/p/11324772.html https://www.yuanguohuo.com/2018/05/25/cpp11-perfect-forward/ 万能引用 https://www.cnblogs.com/5iedu/p/11378023.html C++11中range-based for loops中&amp;&amp;与&amp;的区别 https://blog.csdn.net/haolexiao/article/details/56842552 C++ memory order std::atomic_thread_fence https://blog.csdn.net/wxj1992/article/details/103917093 而在C++ 11及之后的标准里，除了利用原子操作指定内存序，还定义了单独使用memory fence（std::atomic_thread_fence）的方式，fence可以和原子操作组合进行同步，也可以fence之间进行同步， GTEST 系列 Guide https://google.github.io/googletest/ Benchmark Guide https://benchmark.docsforge.com/master/getting-started/ 浅析std::ref与reference_wrapper https://blog.csdn.net/u014645632/article/details/78966340 声明于 中的 class std::reference_wrapper&lt;&gt; 主要用来“喂 ” reference 给function template, 后者原本以 by value方式接受参数。对于一个给定类型 T ，这个 class 提供 ref () 用以隐式转换为 T&amp; ，一个 cref () 用以隐式转换为 const T&amp; ，这往往允许 function template 得以操作 reference 而不需要另写特化版本。 STL 中迭代器失效 https://blog.csdn.net/skyroben/article/details/70877008 向容器中添加或者删除元素的操作可能会使指向容器元素的迭代器失效，失效的迭代器将不指向任何元素。 一般有两种情况无法通过迭代器++操作遍历整个stl容器; 无法通过迭代器存取迭代器所指向的内存。 Modern Cmake https://cliutils.gitlab.io/modern-cmake/ enable_if的几种用法 https://yixinglu.gitlab.io/enable_if.html 用法一：类型偏特化 用法二：控制函数返回类型 用法三：校验函数模板参数类型 typename用法 https://feihu.me/blog/2014/the-origin-and-usage-of-typename/ A name used in a template declaration or definition and that is dependent on a template-parameter is assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified by the keyword typename. 对于用于模板定义的依赖于模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前使用了typename关键字来修饰，编译器才会将该名称当成是类型。除了以上这两种情况，绝不会被当成是类型。 C++ 中的 mutable 关键字 https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker内使用SSH-Key]]></title>
    <url>%2F2020%2F12%2F12%2FDocker%E5%86%85%E4%BD%BF%E7%94%A8SSH-Key%2F</url>
    <content type="text"><![CDATA[Docker内使用SSH Key DockerFile： 123456789101112ARG SSH_KEYARG SSH_KEY_PASSPHRASE# Authorize SSH HostRUN mkdir -p /root/.ssh &amp;&amp; \ chmod 0700 /root/.ssh &amp;&amp; \ ssh-keyscan github.com &gt; /root/.ssh/known_hosts # Add the keys and set permissionsRUN echo "$ssh_prv_key" &gt; /root/.ssh/id_rsa &amp;&amp; \ echo "$ssh_pub_key" &gt; /root/.ssh/id_rsa.pub &amp;&amp; \ chmod 600 /root/.ssh/id_rsa &amp;&amp; \ chmod 600 /root/.ssh/id_rsa.pub 构建命令 1$ docker build -t example --build-arg ssh_prv_key="$(cat ~/.ssh/id_rsa)" --build-arg ssh_pub_key="$(cat ~/.ssh/id_rsa.pub)"]]></content>
      <categories>
        <category>k8s/docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中Static]]></title>
    <url>%2F2020%2F12%2F12%2FC%2B%2B%2FC-%E4%B8%ADStatic%2F</url>
    <content type="text"><![CDATA[C++中static用途 从两方面来分析： 作用域 生存期 C/C++都有 静态局部变量 作用域：函数体内部 生存期：整个程序运行期间 12345678int foo()&#123; static int si = 1; //note:1 int ci = 1; //note:2 si += 1; printf("&amp;si = %p\t si = %d\t &amp;ci = %p\t ci = %d\n", &amp;si, si, &amp;ci, ci); return si;&#125; 静态全局变量 作用域：文件内部 生存期：整个程序运行期间 12345678910static int gsi = 1;//note:3int gi = 1; //note:4 int gfoo()&#123; gsi += 1; gi += 1; printf("gfoo &amp;gsi= %p\t gsi = %d\t &amp;gi= %p\t gi = %d\n", &amp;gsi, gsi, &amp;gi, gi); return gsi;&#125; 静态函数 作用域：文件内部 生存期：整个程序运行期间 123456789101112131415//extern.c void cfoo()&#123; printf("this is non-static cfoo in extern.c &amp;egsi = %p\t egsi = %d\n", &amp;egsi ,egsi);&#125; //mian.cextern void cfoo();int main()&#123; cfoo(); return 0;&#125; C++中用途 静态数据成员 作用域：全局 生存期：整个程序 静态成员函数 作用域：类 生存期：整个程序]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NanoLog-纳秒级C++日志]]></title>
    <url>%2F2020%2F12%2F12%2FC%2B%2B%2FNanoLog-%E7%BA%B3%E7%A7%92%E7%BA%A7C-%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[NanoLog 背景 现有日志系统缺陷 同步写日志——慢 放到后台线程写，仍有代价。且为了不被卡住，要减少产生日志量： 设置日志等级 随机采样log 观察 人可读懂的Log不是必须在应用中产生。 日志信息存在广泛的重复，大部分内容是静态内容。 设计 思想 在编译阶段提取log信息中的重复的静态部分，用字典ID代替字符串 将format工作推迟到离线任务。 压缩日志中的动态变量，减少IO。 详细设计 NanoLog的具体设计如下图所示： 整个日志系统参与的生命周期被分为了三个部分，分别是：编译、运行时以及离线处理。 编译 编译阶段中，NanoLog的PreProcessor会对用户代码进行处理。其中两个关键函数是record（）和compact（）： record(): record函数接收一个buffer和id，ID唯一表示了一个日志调用，而buffer中，储存了日志调用中的动态变量，有了这些信息，NanoLog即可拼接出日志信息。 compact()：compact函数接收一个buffer，负责将buffer中的数据压缩，减少io消耗。 主要包括几个工作： PreProcessor对用户代码中的NanoLog宏进行处理，对于每个宏调用，会记录其文件、代码行数、静态日志字符串、动态变量类型以及为其生成一个独立的ID。之后会将宏调用替换为一个record()函数调用。 对每个宏调用对记录信息，会通过Combiner合成一个完整对字典，共runtime使用 之后，生成对字典会和NanoRuntime的库代码编译出一份静态库，该库和处理过的用户代码最终编译成可执行文件。 运行时 运行过程中，用户的日志操作实际上就是一个非常简单的函数调用，传入id和buffer，然后被记录为一个带时间戳的event，存入线程单独的stagingBuffer，因此也没有同步开销。 实际写入的是后台的Compaction线程，compaction线程读取各个用户线程stagingBuffer,将其中的event的数据根据编译阶段生成的字典中记录的类型信息进行压缩。之后写入磁盘。 离线 NanoLog实际落盘的是一个压缩过的二进制日志文件，要生成人可读的Log还需要使用Decompressor进行解压。 使用 NanoLog目前提供了2种集成方式。 preprocessor：这种方式利用一个python脚本，在编译前，对代码中的日志调用进行处理，生成新的static调用. c++17 precompile：这种方式利用了c17的一些precompile特性实现了和preprocessor一样对效果，用户不需要提前用preprocessor处理代码。 但需要c17的特性支持。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>日志技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-09-技术文摘]]></title>
    <url>%2F2020%2F12%2F12%2FTechnicalDigest%2F2020-09-%E6%8A%80%E6%9C%AF%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[今日头条品质优化：图文详情页秒开实践 我们把 WebView 截图的图片进行缩小到原图的 1/6，遍历检测图片的像素点，当非白色的像素点大于 5% 的时候我们就认为是非白屏的情况，可以相对高效检测准确得出详情页是否发生了白屏。 可以看到，通过线上页面加载用户每次进入详情页都要通过多次网络加载，极容易受网络波动的影响，这种情况下，也无法保证页面加载的时长和成功率，极大的影响了用户体验。 于是在头条中，我们将新闻中标题和正文内容进行拆分，把头条详情页的公共样式 CSS 和 逻辑 JS 都抽离出来，形成一个独立而完备的详情页模板，这样我们就可以把模板直接内置在客户端中。 快速动态超时策略 单次请求 CDN 的超时时间，根据上次成功请求 CDN 的值计算，因子 1.5（z 值）。且最小为 1s（x 值），最大为 4s（y 值）。超过这一时间不取消，直接请求下个 CDN。 单次请求 CDN 有一个硬性超时时间 4s（w 值，w 需 &gt;=y），超过这一时间请求取消。n 个 CDN 的请求全部取消后反馈用户失败。 高性能开发 IO优化 zero copy 多路复用 系统优化 线程池 无锁编程 Wait-free Lock-free Obstruction-free 网络优化 进程间通信 技术优化 RPC&amp;序列化技术 数据库索引技术 缓存技术&amp;布隆过滤器 全文搜索 分布式技术 负载均衡 初级工程师到高级工程师 一位架构师的感悟：过度忙碌使你落后 提出问题 难于 解决问题 决定 不要什么 比 要什么 更难 非功能性需求决定架构 简单 并不容易 永远不要停止编码 风险优先 从 问题开始，而不是技术 过度忙碌使你落后 向量体系(Embedding) 技术路径 图嵌入技术 LINE Node2Vec 两步走策略（兼顾可扩展性和稀疏数据上的表证可靠性） 确认商品是整个电商场景中的核心，单独学习优化商品向量表征 其他对象都和商品有直接或者间接的关系（交互），通过专门的聚合模块得到对象表征 我为什么反对使用Rust 编译时间是所有事情的倍增器。如果一门语言运行速度慢但编译速度快，那么用它编写的程序也可以运行得更快，因为程序员将有更多的时间来做优化！ Rust在泛型困境中有意选择了慢速编译器。这并不是世界末日（最终的运行时性能改进是真的），但它确实意味着，在较大的项目中，你必须竭尽全力才能获得合理的构建时间。]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>技术文摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k8s-servicedns]]></title>
    <url>%2F2019%2F07%2F07%2Fk8s-servicedns%2F</url>
    <content type="text"><![CDATA[在集群NODE中解析Kuebernetes service域名 只要将core DNS的cluster IP加入到/etc/resolv.conf 即可。但注意，重启系统会根据网卡重写/etc/resolv.conf]]></content>
      <categories>
        <category>k8s/docker</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shared_memory]]></title>
    <url>%2F2019%2F04%2F23%2FLinux%2Fshared-memory%2F</url>
    <content type="text"><![CDATA[[转]C/C++经典案例：Linux难点分析之共享内存shm和mmap的比较 共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过mmap()映射普通文件(特殊情况下还可以采用匿名映射)机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号灯等同步机制共同使用。 1. mmap的机制如：就是在磁盘上建立一个文件，每个进程存储器里面，单独开辟一个空间来进行映射。如果多进程的话，那么不会对实际的物理存储器(主存)消耗太大。 2. shm的机制：每个进程的共享内存都直接映射到实际物理存储器里面。 mmap函数是unix/linux下的系统调用，来看《Unix Netword programming》卷二12.2节有详细介绍。 mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。 mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再 调用read()，write()等操作。mmap并不分配空间, 只是将文件映射到调用进程的地址空间里, 然后你就可以用memcpy等操作写文件, 而不用write()了.写完后用msync()同步一下, 你所写的内容就保存到文件里了. 不过这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了. 简单说就是把一个文件的内容在内存里面做一个映像，内存比磁盘快些。 总结： 1、mmap有两种方式，一种是映射内存，它把普通文件映射为实际物理内存页，访问它就和访问物理内存一样(这也就和shm的功能一样了)(同时不用刷新到文件) 2、mmap可以映射文件，不确定会不会像windows“内存映射文件”一样的功能，如果是，那么他就能映射好几G甚至好几百G的内存数据，对大数据处理将提供强大功能了。 3、shm只做内存映射，和mmap第一个功能一样!只不过不是普通文件而已，但都是物理内存。 本文版权归黑马程序员C/C++学院所有，欢迎转载，转载请注明作者出处。谢谢！ 作者：黑马程序员C/C++培训学院 首发：http://c.itheima.com/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Linux 进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[optimize_program]]></title>
    <url>%2F2019%2F04%2F17%2FPrograming%2Foptimize-program%2F</url>
    <content type="text"><![CDATA[Tips for program optimization 编码优化 恰当的使用 inline来减少函数调用造成的开销。 消除连续的重复调用，将结果固定的重复计算移出循环体。如：数组的size() 消除不必要的内存访问，如:将结果存在一个临时变量中，结果计算完成后一次性写入到内存 结构化优化 通过交换、组合或分配等方式，减少耗时操作(如：乘除法)的计算次数。 采用循环展开(loop unrolling)技术，循环展开在2方面提升了程序性能： 减少条件判断和循环计数计算的操作数量 可以合并一些相关操作，减少关键路径上的操作数量。 利用处理器流水线特性，分离操作，使其能够在流水线中并行。 在分支语句中使用特性，并尽量使得判断条件在大多数情况下成立，减少分支预测错误带来的惩罚。 保持你的代码cache friendly,例：尽管查找树等数据结构算法复杂度更低，但考虑到cache的存在，数组等顺序储存结构的整体性能可能会更高。 并发优化]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>编程进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++内存模型]]></title>
    <url>%2F2019%2F04%2F15%2FC%2B%2B%2Fc-mamorymodel%2F</url>
    <content type="text"><![CDATA[问题引入 乱序 说到内存模型，首先需要明确一个普遍存在，但却未必人人都注意到的事实：程序通常并不是总按着照源码中的顺序一一执行，此谓之乱序，乱序产生的原因可能有好几种： 编译器出于优化的目的，在编译阶段将源码的顺序进行交换。 程序执行期间，指令流水被 cpu 乱序执行。 inherent cache 的分层及刷新策略使得有时候某些写读操作的从效果上看，顺序被重排。 从乱序的种类来看分为以下四类： 写写乱序(store store), 前面的写操作被放到了后面的操作之后，比如： 12345a = 3;b = 4;被乱序为：b = 4;a = 3; 写读乱序(store load)，前面的写操作被放到了后面的读操作之后，比如： 12345a = 3;load(b);被乱序为load(b);a = 3; 读读乱序(load load)， 前面的读操作被放到了后一个读操作之后，比如： 12345load(a);load(b);被乱序为：load(b);load(a); 读写乱序(load store), 前面的读操作被放到了后一个写操作之后，比如： 12345load(a);b = 4;被乱序为：b = 4;load(a); 程序的乱序在单线程的世界里多数时候并没有引起太多引人注意的问题，但在多线程的世界里，这些乱序就制造了特别的麻烦，究其原因，最主要的有2个： 并发不能保证修改和访问共享变量的操作原子性，使得一些中间状态暴露了出去，因此像 mutex，各种 lock 之类的东西在写多线程时被频繁地使用。 变量被修改后，该修改未必能被另一个线程及时观察到，因此需要“同步”。 解决同步问题就需要确定内存模型，也就是需要确定线程间应该怎么通过共享内存来进行交互(查看维基百科). memory model 内存模型所要表达的内容主要是怎么描述一个内存操作的效果，在各个线程间的可见性的问题。修改操作的效果不能及时被别的线程看见的原因有很多，比较明显的一个是，对计算机来说，通常内存的写操作相对于读操作是昂贵很多很多的，因此对写操作的优化是提升性能的关键，而这些对写操作的种种优化，导致了一个很普遍的现象出现：写操作通常会在 CPU 内部的 cache 中缓存起来。这就导致了在一个 CPU 里执行一个写操作之后，该操作导致的内存变化却不一定会马上就被另一个 CPU 所看到，这从另一个角度讲，效果上其实就是读写乱序了。 1234cpu1 执行如下：a = 3;cpu2 执行如下：load(a); 对如上代码，假设 a 的初始值是 0, 然后 cpu1 先执行，之后 cpu2 再执行，假设其中读写都是原子的，那么最后 cpu2 如果读到 a = 0 也其实不是什么奇怪事情。很显然，这种在某个线程里成功修改了全局变量，居然在另一个线程里看不到效果的后果是很严重的。 因此必须要有必要的手段对这种修改公共变量的行为进行同步。 c++11 中的 atomic library 中定义了以下6种语义来对内存操作的行为进行约定，这些语义分别规定了不同的内存操作在其它线程中的可见性问题： 12345678enum memory_order &#123; memory_order_relaxed, //对其它读写操作没有同步，只保证本操作是原子的 memory_order_consume, //load操作，当前线程依赖该原子变量的访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_acquire, //load操作，当前线程所有访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_release, //store操作，当前线程所有访存操作不能reorder到该指令之后，对其他线程load操作(consume)可见 memory_order_acq_rel, //load/store操作，memory_order_acquire + memory_order_release memory_order_seq_cst //memory_order_acq_rel + 顺序一致性(sequential consisten)&#125;;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock-Free 编程]]></title>
    <url>%2F2019%2F04%2F15%2FPrograming%2Flock-free%2F</url>
    <content type="text"><![CDATA[Lock-Free 编程 Lock-Free 编程描述了代码所表述的性质，而没有限定或要求代码该如何编写。一般理解来讲即尽量少的使用LOCK或MUTEX等互斥量或锁，以降低线程间的相互阻塞。可以通过以下框图来判断是否符合lock-free. 从这个意义上来说，Lock-Free 中的 “Lock” 并没有直接涉及 Mutex 或 Lock 等互斥量结构，而是描述了应用程序因某种原因被阻塞的可能性，例如可能因为死锁（DeadLock）、活锁（LiveLock）或线程调度（Thread Scheduling）导致优先级被抢占等。 Lock-Free 编程的一个重要效果就是，在一系列访问 Lock-Free 操作的线程中，如果某一个线程被挂起，那么其绝对不会阻止其他线程继续运行（Non-Blocking）。 通常，应该没有人会期待一个大型的应用程序中全部采用 Lock-Free 技术，应是在有特定需求的类的设计上采用 Lock-Free 技术。例如，如果需要一个 Stack 类应对多线程并发访问的场景，可以使用 Lock-Free 相关技术实现 ConcurrentStack 类，在其 Push 和 Pop 操作中进行具体的实现。在使用 Lock-Free 技术前，需要预先考虑一些软件工程方面的成本： Lock-Free 技术很容易被错误的使用，代码后期的维护中也不容易意识到，所以非常容易引入 Bug，而且这样的 Bug 还非常难定位。 Lock-Free 技术的细节上依赖于内存系统模型、编译器优化、CPU架构等，而这在使用 Lock 机制时是不相关的，所以也增加了理解和维护的难度。 Lock-Free 实现技术 我们要满足 Lock-Free 编程中的非阻塞条件时，有一系列的技术和方法可供使用，如原子操作（Atomic Operations）、内存栅栏（Memory Barrier）、避免 ABA 问题（Avoiding ABA Problem）等。下图提供了一些判断依据： 原子操作(Atomic Operations) 原子操作（Atomic Operations）在操作内存时可以被看做是不可分割的（Indivisible），其他线程不会打断该操作，没有操作只被完成一部分之说。在现代的 CPU 处理器上，很多操作已经被设计为原子的，例如对齐读（Aligned Read）和对齐写（Aligned Write）等。 在C++中可以通过引入来进行原子操作。 RMW 操作在不同的 CPU 家族中是通过不同的方式来支持的。 x86/64 和 Itanium 架构通过 Compare-And-Swap (CAS)方式来实现； PowerPC、MIPS 和 ARM 架构通过Load-Link/Store-Conditional (LL/SC) 方式来实现； Compare-And-Swap 循环（CAS Loops） CAS是由CPU提供的原子操作。 通常开发人员会设计在一个循环中重复地执行 CAS 操作以试图完成一个事务操作。这个过程分为 3 步： 从指定的内存位置读取原始的值； 根据读取到的原始的值计算出新的值； 检测如果内存位置仍然是原始的值时，则将新值写入该内存位置； ABA 问题（ABA Problem） 在实现 CAS Loops 时，当存在多个线程交错地对共享的内存地址进行处理时，如果实现设计的不正确，将有可能遭遇 ABA 问题。 若线程对同一内存地址进行了两次读操作，而两次读操作得到了相同的值，通过判断 “值相同” 来判定 “值没变”。然而，在这两次读操作的时间间隔之内，另外的线程可能已经修改了该值，这样就相当于欺骗了前面的线程，使其认为 “值没变”，实际上值已经被篡改了。 下面是 ABA 问题发生的过程： T1 线程从共享的内存地址读取值 A； T1 线程被抢占，线程 T2 开始运行； T2 线程将共享的内存地址中的值由 A 修改成 B，然后又修改回 A； T1 线程继续执行，读取共享的内存地址中的值仍为 A，认为没有改变然后继续执行； 由于 T1 并不知道在两次读取的值 A 已经被 “隐性” 的修改过，所以可能产生无法预期的结果。 例如，使用 List 来存放 Item，如果将一个 Item 从 List 中移除并释放了其内存地址，然后重新创建一个新的 Item，并将其添加至 List 中，由于优化等因素，有可能新创建的 Item 的内存地址与前面删除的 Item 的内存地址是相同的，导致指向新的 Item 的指针因此也等同于指向旧的 Item 的指针，这将引发 ABA 问题。 内存模型 在多线程系统中，当多个线程同时访问共享的内存时，就需要一个规范来约束不同的线程该如何与内存交互，这个规范就称之为内存模型（Memory Model）。 在传统的C中，需要通过内存栅栏(memory barrier)的方式，在指令间插入内存栅栏来保证内存访问和修改的执行顺序。 在C++11中提供了memoryorder的支持来支持跨平台内存模型规范。详见另一篇博文。]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>C++进阶</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++多线程]]></title>
    <url>%2F2019%2F04%2F09%2FC%2B%2B%2Fc-thread%2F</url>
    <content type="text"><![CDATA[thread 类 &lt;thread&gt;：头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在这个头文件中。 std::thread 构造函数 (1)默认构造函数：创建一个空的 thread 执行对象。 (2) 初始化构造函数：创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。 (3)拷贝构造函数(被禁用)：意味着 thread 不可被拷贝构造。 (4)move 构造函数，move 构造函数：调用成功之后 x 不代表任何 thread 执行对象。 joinable thread thread 类中提供了一个成员函数bool jionable() 用于检测线程是否joinable joinable ： 代表该线程是可结合的线程。如果线程处于joinable状态，则只能只能被创建他的线程等待终止。 **not-joinable ：**通常一下几种情况会导致线程成为not-joinable 由thread的缺省构造函数构造而成(thread()没有参数)。 该thread被move过（包括move构造和move赋值, 原thread被销毁) 该线程调用过join或者detach join and detach 创建一个线程之后，我们还需要考虑一个问题：该如何处理这个线程的结束？ 一种方式是等待这个线程结束，在一个合适的地方调用 thread 实例的 join() 方法，调用者线程将会一直等待着目标线程的结束，当目标线程结束之后调用者线程继续运行； 另一个方式是将这个线程分离，由其自己结束，通过调用 thread 实例的 detach() 方法将目标线程置于分离模式。 move and swap 1234567891011121314151617#include&lt;thread&gt; using namespace std; int main() &#123; thread t1([]() &#123; cout &lt;&lt; "thread1" &lt;&lt; endl; &#125;); cout &lt;&lt; "thread1' id is " &lt;&lt; t1.get_id() &lt;&lt; endl; thread t2 = move(t1);; cout &lt;&lt; "thread2' id is " &lt;&lt; t2.get_id() &lt;&lt; endl; return 0; &#125; 运行结果: thread1 thread1' id is 5620 thread2' id is 5620 可以看到，线程t2可以通过 move 移动 t1 来获取 t1 的全部属性，而 t1 却销毁了。 使用swap也有同样移动的效果： 1234567891011121314151617181920212223242526272829#include&lt;thread&gt; using namespace std; int main() &#123; thread t1([]() &#123; cout &lt;&lt; "thread1" &lt;&lt; endl; &#125;); thread t2([]() &#123; cout &lt;&lt; "thread2" &lt;&lt; endl; &#125;); cout &lt;&lt; "thread1' id is " &lt;&lt; t1.get_id() &lt;&lt; endl; cout &lt;&lt; "thread2' id is " &lt;&lt; t2.get_id() &lt;&lt; endl; cout &lt;&lt; "swap after:" &lt;&lt; endl; swap(t1, t2);//线程交换 cout &lt;&lt; "thread1' id is " &lt;&lt; t1.get_id() &lt;&lt; endl; cout &lt;&lt; "thread2' id is " &lt;&lt; t2.get_id() &lt;&lt; endl; return 0; &#125; 运行结果: thread1 thread2 thread1' id is 4836 thread2' id is 4724 swap after: thread1' id is 4724 thread2' id is 4836 这两种的不同是swap仅仅进行实例（以 id 作标识）的互换，而move则在进行实例标识的互换之前，还进行了转移目的实例（如之前的t2）的清理（通过调用std::terminate()）。 yeild and sleep 123456//让线程等待3秒 this_thread::sleep_for(chrono::seconds(3)); //让线程等待直到到达指定时间this_thread::sleep_until (time);//让cpu执行其他空闲的线程 this_thread::yield(); mutex Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 &lt;mutex&gt; 头文件中。 std::mutex用法 构造函数:std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。 lock():调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况： 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 unlock() 解锁，释放对互斥量的所有权。 try_lock() 尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况: 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 std::recursive_mutex recursive_mutex 与 mutex相同，唯一不同的是**std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，相对应的std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()。** std::time_mutex time_mutex相较于mutex提供了2个新的方法来进行时间相关的上锁： try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 同样的也有对应的recursive_timed_mutex来提供递归上锁。 lock类 std::lock_guard std::lock_gurad 是 C++11 中定义的模板类。定义如下： ​ template &lt;class Mutex&gt; class lock_guard; lock_guard 对象通常用于管理某个锁(Lock)对象，与 Mutex RAII 相关，方便线程对互斥量上锁，即在某个 lock_guard 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 lock_guard 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 shared_ptr 等智能指针管理动态分配的内存资源)。 模板参数 Mutex 代表互斥量类型，例如 std::mutex 类型，它应该是一个基本的 BasicLockable 类型，标准库中定义几种基本的 BasicLockable 类型，分别 std::mutex, std::recursive_mutex, std::timed_mutex，std::recursive_timed_mutex以及 std::unique_lock。 在 lock_guard 对象构造时，传入的 Mutex 对象(即它所管理的 Mutex 对象)会被当前线程锁住。在lock_guard 对象被析构时，它所管理的 Mutex 对象会自动解锁，由于不需要程序员手动调用 lock 和 unlock 对 Mutex 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。 构造函数： locking 初始化 :std::lock_guard&lt;std::mutex&gt; lck(mtx); lock_guard 对象管理 Mutex 对象 m，并在构造时对 m 进行上锁（调用 m.lock()）。 adopting初始化:std::lock_guard&lt;std::mutex&gt; lck(mtx, std::adopt_lock); lock_guard 对象管理 Mutex 对象 m，与 locking 初始化不同的是， Mutex 对象 m 已被当前线程锁住。 拷贝构造: lock_guard对象的拷贝构造和移动构造(move construction)均被禁用，因此 lock_guard 对象不可被拷贝构造或移动构造 std::unique_lock C++11 标准中定义了另外一个与 Mutex RAII 相关类 unique_lock，该类与 lock_guard 类相似，也很方便线程对互斥量上锁，但它提供了更好的上锁和解锁控制。 unique_lock 对象以独占所有权的方式（ unique owership）管理 mutex 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权。 在构造(或移动(move)赋值)时，unique_lock 对象需要传递一个 Mutex 对象作为它的参数，新创建的 unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作。 std::unique_lock 对象也能保证在其自身析构时它所管理的 Mutex 对象能够被正确地解锁（即使没有显式地调用 unlock 函数） 值得注意的是，unique_lock 对象同样也不负责管理 Mutex 对象的生命周期,在某个 unique_lock 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 unique_lock 的生命周期结束之后，它所管理的锁对象会被解锁，这一点和 lock_guard 类似，但 unique_lock 给程序员提供了更多的自由。 另外，与 lock_guard 一样，模板参数 Mutex 代表互斥量类型，例如 std::mutex 类型，它应该是一个基本的 BasicLockable 类型。 构造函数： 默认构造函数 新创建的 unique_lock 对象不管理任何 Mutex 对象。 locking 初始化 新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.lock() 对 Mutex 对象进行上锁，如果此时另外某个 unique_lock 对象已经管理了该 Mutex 对象 m，则当前线程将会被阻塞。 try-locking 初始化 新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.try_lock() 对 Mutex 对象进行上锁，但如果上锁不成功，并不会阻塞当前线程。 deferred 初始化 新创建的 unique_lock 对象管理 Mutex 对象 m，但是在初始化的时候并不锁住 Mutex 对象。 m 应该是一个没有当前线程锁住的 Mutex 对象。 adopting 初始化 新创建的 unique_lock 对象管理 Mutex 对象 m， m 应该是一个已经被当前线程锁住的 Mutex 对象。(并且当前新创建的 unique_lock 对象拥有对锁(Lock)的所有权)。 locking 一段时间(duration) 新创建的 unique_lock 对象管理 Mutex 对象 m，并试图通过调用 m.try_lock_for(rel_time) 来锁住 Mutex 对象一段时间(rel_time)。 locking 直到某个时间点(time point) 新创建的 unique_lock 对象管理 Mutex 对象m，并试图通过调用 m.try_lock_until(abs_time) 来在某个时间点(abs_time)之前锁住 Mutex 对象。 拷贝构造 [被禁用] unique_lock 对象不能被拷贝构造。 移动(move)构造 新创建的 unique_lock 对象获得了由 x 所管理的 Mutex 对象的所有权(包括当前 Mutex 的状态)。调用 move 构造之后， x 对象如同通过默认构造函数所创建的，就不再管理任何 Mutex 对象了。 综上所述，由 (2) 和 (5) 创建的 unique_lock 对象通常拥有 Mutex 对象的锁。而通过 (1) 和 (4) 创建的则不会拥有锁。通过 (3)，(6) 和 (7) 创建的 unique_lock 对象，则在 lock 成功时获得锁。 atomic std::atomic std::atomic对int, char, bool等数据结构进行原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。 构造函数 默认构造函数 atomic() noexcept = default; 初始化构造函数 constexpr atomic (T val) noexcept; 拷贝构造函数 atomic (const atomic&amp;) = delete。可以看出atomic对象是不可复制的。 由上可知，atomic对象可以用其内部存储类型赋值，但是atomic本身是不能进行赋值拷贝的。 atomic经常用的函数有store和load，如下： store函数 12void store (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;void store (T val, memory_order sync = memory_order_seq_cst) noexcept; 其实就是用val替换内部保存的值。内部替换的时候其实是加了线程同步的，所以不用担心多线程访问的问题。 load函数 12T load (memory_order sync = memory_order_seq_cst) const volatile noexcept;T load (memory_order sync = memory_order_seq_cst) const noexcept; 返回内部保存的值，其实就是访问内部值。 std::atomic_flag atomic_flag是一个原子布尔类型。不同于std::atomic的所有专门化，它保证是lock_free。不像std::stomic&lt; bool &gt;，std::atomic_flag不提供负载或存储操作。 构造函数 atomic_flag在构建(或设置或清除)上处于一个未指定的状态，除非它被显式地初始化为ATOMIC_FLAG_INIT。 atomic_flag值不能复制/移动。 成员函数：test_and_set bool test_and_set (memory_order sync = memory_order_seq_cst) volatile noexcept; bool test_and_set (memory_order sync = memory_order_seq_cst) noexcept;。 设置atomic_flag并返回是否在调用之前已经设置的。 整个操作是原子的(一个原子的读-修改-写操作):当在这个函数被修改的时候,读取的(返回)值被读取，值不受其他线程的影响。 成员函数:atomic_flag_clear void clear (memory_order sync = memory_order_seq_cst) volatile noexcept; void clear (memory_order sync = memory_order_seq_cst) noexcept; 清除atomic_flag(即把atomic_flag 设为假)。清除atomic_flag使下一次调用成员atomic_flag::test_and_set对象返回false。 操作是原子的，按照sync所指定的内存顺序。 future std::promise promise 对象可以保存某一类型T值，该值可被 future 对象读取（可能在另外一个线程中）， promise 提供了一种线程同步的手段。 在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值。 可以通过 get_future 来获取与该 promise 对象相关联的 future 对象，调用该函数之后，两个对象共享相同的共享状态(shared state) promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值。 future 对象可以异步返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标志变为 ready，然后才能获取共享状态的值。 12345678910111213141516171819202122232425// promise example #include &lt;iostream&gt; // std::cout #include &lt;functional&gt; // std::ref #include &lt;thread&gt; // std::thread #include &lt;future&gt; // std::promise, std::future void print_int(std::future&lt;int&gt;&amp; fut) &#123; int x = fut.get(); std::cout &lt;&lt; "value: " &lt;&lt; x &lt;&lt; std::endl; &#125; int main() &#123; std::promise&lt;int&gt; prom; // create promise std::future&lt;int&gt; fut = prom.get_future(); // engagement with future std::thread th1(print_int, std::ref(fut)); // send future to new thread prom.set_value(10); // fulfill promise // (synchronizes with getting the future) th1.join(); return 0; &#125; promise 只有移动语义没有拷贝语义。 std::promise::get_future：返回一个与promise共享状态相关联的future对象 std::promise::set_value：设置共享状态的值，此后promise共享状态标识变为ready std::promise::set_exception：为promise设置异常，此后promise的共享状态标识变为ready std::promise::set_value_at_thread_exit：设置共享状态的值，但是不将共享状态的标志设置为 ready，当线程退出时该 promise 对象会自动设置为 ready（注意：该线程已设置promise的值，如果在线程结束之后有其他修改共享状态值的操作，会抛出future_error(promise_already_satisfied)异常） std::promise::swap：交换 promise 的共享状态 std::future 简单来说，std::future提供了一种访问异步操作结果的机制。 从字面意思看，它表示未来。通常一个异步操作我们是不能马上就获取操作结果的，只能在未来某个时候获取。我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态： deferred：异步操作还没开始 ready：异步操作已经完成 timeout：异步操作超时 获取future结果有三种方式：get、wait、wait_for: get 等待异步操作结束(ready)并返回结果 wait 只是等待异步操作完成，没有返回值 wait_for 是超时等待返回结果。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSIsample]]></title>
    <url>%2F2019%2F03%2F31%2FOSIsample%2F</url>
    <content type="text"><![CDATA[OSI七层结构示意图]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI七层结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux namespace与Cgroup简述]]></title>
    <url>%2F2019%2F03%2F31%2FLinux%2Fnamespace-cgroup%2F</url>
    <content type="text"><![CDATA[NameSpace 概述 Namespace 用于不同进程组之间的资源隔离，其目的是将某个特定的全局系统资源（global system resource）通过抽象方法使得namespace 中的进程看起来拥有它们自己的隔离的全局系统资源实例。 Linux 内核中实现了六种 namespace，按照引入的先后顺序，列表如下： namespace 引入的相关内核版本 被隔离的全局系统资源 在容器语境下的隔离效果 Mount namespaces Linux 2.4.19 文件系统挂接点 每个容器能看到不同的文件系统层次结构 UTS namespaces Linux 2.6.19 nodename 和 domainname 每个容器可以有自己的 hostname 和 domainame PID namespaces Linux 2.6.24 进程 ID 数字空间 （process ID number space） 每个 PID namespace 中的进程可以有其独立的 PID； 每个容器可以有其 PID 为 1 的root 进程；也使得容器可以在不同的 host 之间迁移，因为 namespace 中的进程 ID 和 host 无关了。这也使得容器中的每个进程有两个PID：容器中的 PID 和 host 上的 PID。 IPC namespaces Linux 2.6.19 特定的进程间通信资源，包括System V IPC 和 POSIX message queues 每个容器有其自己的 System V IPC 和 POSIX 消息队列文件系统，因此，只有在同一个 IPC namespace 的进程之间才能互相通信 Network namespaces 始于Linux 2.6.24 完成于 Linux 2.6.29 网络相关的系统资源 每个容器用有其独立的网络设备，IP 地址，IP 路由表，/proc/net 目录，端口号等等。这也使得一个 host 上多个容器内的同一个应用都绑定到各自容器的 80 端口上。 User namespaces 始于 Linux 2.6.23 完成于 Linux 3.8) 用户和组 ID 空间 在 user namespace 中的进程的用户和组 ID 可以和在 host 上不同； 每个 container 可以有不同的 user 和 group id；一个 host 上的非特权用户可以成为 user namespace 中的特权用户； Cgroup概述 在Linux里，一直以来就有对进程进行分组的概念和需求，比如session group， progress group等，后来随着人们对这方面的需求越来越多，比如需要追踪一组进程的内存和IO使用情况等，于是出现了cgroup,主要有两大用途: 用来统一将进程进行分组。 在分组的基础上对进程进行监控和资源控制管理等。 cgroup是Linux下的一种将进程按组进行管理的机制，在用户层看来，cgroup技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个subsystem关联，树的作用是将进程分组，而subsystem的作用就是对这些组进行操作。cgroup主要包括下面两部分： subsystem 一个subsystem就是一个内核模块，他被关联到一颗cgroup树之后，就会在树的每个节点（进程组）上做具体的操作。subsystem经常被称作&quot;resource controller&quot;，因为它主要被用来调度或者限制每个进程组的资源，但是这个说法不完全准确，因为有时我们将进程分组只是为了做一些监控，观察一下他们的状态，比如perf_event subsystem。 hierarchy 一个hierarchy可以理解为一棵cgroup树，树的每个节点就是一个进程组，每棵树都会与零到多个subsystem关联。在一颗树里面，会包含Linux系统中的所有进程，但每个进程只能属于一个节点（进程组）。系统中可以有很多颗cgroup树，每棵树都和不同的subsystem关联，一个进程可以属于多颗树，即一个进程可以属于多个进程组，只是这些进程组和不同的subsystem关联。目前Linux支持12种subsystem，如果不考虑不与任何subsystem关联的情况（systemd就属于这种情况），Linux里面最多可以建12颗cgroup树，每棵树关联一个subsystem，当然也可以只建一棵树，然后让这棵树关联所有的subsystem。当一颗cgroup树不和任何subsystem关联的时候，意味着这棵树只是将进程进行分组，至于要在分组的基础上做些什么，将由应用程序自己决定，systemd就是一个这样的例子。 到目前为止，Linux支持12种subsystem，比如限制CPU的使用时间，限制使用的内存，统计CPU的使用情况，冻结和恢复一组进程等。 subsystemID 引入的相关内核版本 提供效果 cpu Linux 2.6.24; CONFIG_CGROUP_SCHED 用来限制cgroup的CPU使 cpuacct Linux 2.6.24; CONFIG_CGROUP_CPUACCT 统计cgroup的CPU的使用率。 cpuset Linux 2.6.24; CONFIG_CPUSETS 绑定cgroup到指定CPUs和NUMA节点。 memory Linux 2.6.25; CONFIG_MEMCG 统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。 devices Linux 2.6.26; CONFIG_CGROUP_DEVICE 限制cgroup创建(mknod)和访问设备的权限。 freezer Linux 2.6.28; CONFIG_CGROUP_FREEZER suspend和restore一个cgroup中的所有进程。 net_cls Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID 将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。 blkio Linux 2.6.33; CONFIG_BLK_CGROUP 限制cgroup访问块设备的IO速度。 perf_event Linux 2.6.39; CONFIG_CGROUP_PERF 对cgroup进行性能监控 net_prio Linux 3.3; CONFIG_CGROUP_NET_PRIO 针对每个网络接口设置cgroup的访问优先级。 hugetlb Linux 3.5; CONFIG_CGROUP_HUGETLB 限制cgroup的huge pages的使用量。 pids Linux 4.3; CONFIG_CGROUP_PIDS 限制一个cgroup及其子孙cgroup中的总进程数。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ trivial类型]]></title>
    <url>%2F2019%2F03%2F31%2FC%2B%2B%2Fc-trivial%2F</url>
    <content type="text"><![CDATA[Trival类型 最近在看《STL源码剖析》时看到对于Trival和POD类型，模板会有相应的特化，对于Trival类型的操作不需逐个调用构造函数和析构函数。但是不清楚Trival的含义，因此查了一下。 A trivially copyable class is a class that: — has no non-trivial copy constructors (12.8), — has no non-trivial move constructors (12.8), — has no non-trivial copy assignment operators (13.5.3, 12.8), — has no non-trivial move assignment operators (13.5.3, 12.8), and — has a trivial destructor (12.4). A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable. [ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes.—end note ] 其他要求： ①没有虚成员（不含虚函数以及虚基类） ②没有类内初始化的非静态数据成员 ③如果它拥有基类或者非静态成员，它们也应该是trivial的 trivial constructor and trivial destructor trivial构造函数即构造函数“什么都不干”。通常情况下，不定义类的构造函数，编译器就会为我们生成一个平凡的默认构造函数。但如果该类含有虚函数或者数据成员没有默认构造函数，编译器是不会为我们生成trivial的默认构造函数的。析构函数也是一样的道理。 trivial copy constructor and trivial copy constructor trivial 拷贝构造函数基本上等同于memcpy进行类型的构造。同trivial 构造函数一样，编译器在用户不提供的情况下，通常会提供trivial 拷贝构造函数。 trivial 移动构造函数执行的操作与trivial 拷贝构造函数相同，都是bytewise的拷贝，只是用于移动语义。 详细请看]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[copy_move_constractor]]></title>
    <url>%2F2019%2F03%2F27%2FC%2B%2B%2Fcopy-move-constractor%2F</url>
    <content type="text"><![CDATA[拷贝构造函数和拷贝赋值函数 12345678910//拷贝构造函数A(const A&amp; t)&#123; ...&#125;//拷贝赋值运算符A&amp; operator=(const A&amp; rhs)&#123; ...&#125; 拷贝构造函数只在对象实例化时才会被调用，也就是说，在复制构造函数调用期间，这个对象处于一个未决状态（直到复制构造函数被成功调用），另外拷贝构造函数不返回任何值。 拷贝构造函数应用的场合有以下几个方面： 1 函数的参数是一个对象，并且是值传递方式 2 函数的返回值是一个对象，并且是值传递方式 3 用一个对象初始化另外一个对象 赋值运算符则在一个现存的对象被赋予新的值时被调用，并且它有返回值。 123456789Test test; //实例化test对象时调用了默认构造函数Test test1=test;// test1使用了复制构造函数（因为这是一个新的对象产生）Test test2(test);//test2时也是用了复制构造函数，Test test3=test2=test1;//而test2=test1则使用了赋值构造函数（没有新的对象产生），Test test3=test2=test1;//test3=test2则使用了复制构造函数，原因同上。 移动构造函数和移动赋值函数 12345678910//移动构造函数A(A&amp;&amp; t)&#123; ...&#125;//移动赋值运算符A&amp; operator=(A&amp;&amp; rhs)&#123; ...&#125; 要实现转移语义，需要定义转移构造函数，当然还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么拷贝构造函数和赋值操作符会被调用。 两者区别与拷贝构造函数和赋值运算符的区别相同，这里不再赘述。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>知识辨析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划总结]]></title>
    <url>%2F2019%2F03%2F26%2FLeetCode%2Fdynamic-programing%2F</url>
    <content type="text"><![CDATA[动态规划的两大原则[转] 最优子结构 用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。 重叠子问题 在斐波拉契数列求解中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。 状态转移方程 构建一个动态规划算法分为几个步骤： 刻画一个最优解的结构特征。 递归地定义最优解的值。 计算最优解的值，通常采用自底向上的方法。 利用计算出的信息构造一个最优解。 确定状态转移方程就在第一步和第二步中，首先要确定问题的决策对象，接着对决策对象划分阶段并确定各个阶段的状态变量，最后建立各阶段的状态变量的转移方程。其形式如下： 状态i=最优解（当前状态k,下一转移状态）+变化量（optional）状态i = 最优解（当前状态k,下一转移状态）+变化量（optional） 状态i=最优解（当前状态k,下一转移状态）+变化量（optional） 常见问题的状态转移公式总结 动态规划的编程模板 ①递归版本 1234567891011int cut(vector&lt;int&gt; p,int n) &#123; if(n==0) return 0; int q=INT_MIN; for(int i=1;i&lt;=n;i++) &#123; q=max(q, p[i-1]+cut(p, n-i)); &#125; return q; &#125; ②备忘录版本 12345678910111213141516171819202122int cutMemo(vector&lt;int&gt; p) &#123; int r[p.size()]]; for(int i=0;i&lt;=p.size();i++) r[i]=-1; return cut(p, p.size(), r); &#125; public static int cut(vector&lt;int&gt; p,int n,vector&lt;int&gt; &amp;r) &#123; int q=-1; if(r[n]&gt;=0) return r[n]; if(n==0) q=0; else &#123; for(int i=1;i&lt;=n;i++) q=max(q, cut(p, n-i,r)+p[i-1]); &#125; r[n]=q; return q; &#125; 备忘录方法就是在递归的时候记录下已经调用过的子函数的值。 ③自底向上 12345678910111213int buttom_up_cut(vector&lt;int&gt; p) &#123; int r[p.size()]; for(int i=0;i&lt;p.size();i++) &#123; int q=-1; //① for(int j=0;j&lt;=i;j++) q=Math.max(q, p[j-1]+r[i-j]); r[i]=q; &#125; return r[p.size()-1]; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++命名空间]]></title>
    <url>%2F2019%2F03%2F25%2FC%2B%2B%2Fc-namespace%2F</url>
    <content type="text"><![CDATA[一、命名空间 **命名空间:**实际上就是一个由程序设计者命名的内存区域，程序设计者可以根据需要指定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开来。 123namespace n1&#123; ...&#125; 命名冲突：只有同一个名字空间中同一作用域下，相同的名字才会冲突。所以要解决冲突无非就是修改名字空间或者作用域。 首先说修改作用域，在C中，文件作用域的标识符有一个链接属性，static修饰的，的作用域仅仅限于本.c文件，而extern（或者默认情况下）作用域是所有.c文件，所以我们可以个其中一个conan加上static修饰，这样就改变了作用域，就不会冲突了，但是问题是，我们既然定义成全局变量，通常情况下，我们都希望它有外部链接属性。我们之所以定义成全局变量，很可能就是为了让其他.c文件使用。所以static虽然解决了冲突，但是没有达到我们的目的。 那么我们只能够用另一种方法解决冲突了，就是修改名字空间，这在C语言中是不可行的，但是在C中是可行的，因为C可以自定义名字空间。 二、嵌套名字空间 1. 普通嵌套名字空间 一个嵌套名字空间就是一个嵌套作用域，其作用域嵌套在包含他的名字空间中。 在外部引用嵌套空间中的成员时,使用下面的形式 1包含嵌套空间的名字空间的名字::嵌套空间的名字::嵌套空间的成员 2. 内联嵌套名字空间 C++11中，新增inline namespace，指示命名空间中的名称同时是外层命名空间直接包含的名称。这便于命名空间的版本管理，减少冲突。 inline描述符使得内联命名空间中的声明看起来就好像是直接在外围的命名空间中进行声明的一样。（使用inline关键字定义的内联名字空间成为默认名字空间。） inline描述符由命名空间的设计者放置，即命名空间的作者可以通过放置inline描述符来表示当前最新的命名空间是哪个. 三、全局命名空间 全局命名空间是隐式声明的,存在于每个程序中。在全局作用域定义实体的每个文件将那些名字加到全局命名空间。 可以用作用域操作符引用全局命名空间的成员。因为全局命名空间是隐含的,它没有名字, 所以使用记号如下方法引用全局命名空间的成员。 1::member_name 四、匿名名字空间 命名空间可以是未命名的,未命名的命名空间在定义时没有给定名字。其定义方法如下： 1234namespace //No name&#123; //members....&#125; 未命名的命名空间与其他命名空间不同,未命名的命名空间的定义局部于特定文件,从不跨越多个文本文件。 未命名的命名空间可以在给定文件中不连续,但不能跨越文件,每个文件有自己的未命名的命名空间。 未命名的命名空间用于声明局部于文件的实体。在未命名的命名空间中定义的变量在程序开始时创建,在程序结束之前一直存在。 未命名的命名空间中定义的名字可直接使用,因为没有命名空间名字来限定它们。 由以上特性，未命名的命名空间可以取代文件中的静态声明 在标准 C++ 中引入命名空间之前,程序必须将名字声明为static,使它们的作用域约束于一个文件中。 文件中静态声明的方法是从 C 语言继承而来, C++ 不赞成文件静态声明，因为这可能在未来版本中不支持。 所以应该避免文件静态而使用未命名空间代替。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类内存结构]]></title>
    <url>%2F2019%2F03%2F25%2FC%2B%2B%2Fc-classmemory%2F</url>
    <content type="text"><![CDATA[原文地址]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[goole styleguide 学习笔记]]></title>
    <url>%2F2019%2F03%2F25%2FPrograming%2Fstyleguide-note%2F</url>
    <content type="text"><![CDATA[一、头文件 1.1. Self-contained 头文件 所有.h头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。 不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 .inc 文件扩展名。 1.2. #define 保护 所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ . 1.3. 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 前置声明有一些优点，也有一些缺点： 优点： 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。 很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义： 12345678910&gt; &gt; // b.h:&gt; &gt; struct B &#123;&#125;;&gt; &gt; struct D : B &#123;&#125;;&gt; &gt; &gt; &gt; // good_user.cc:&gt; &gt; #include "b.h"&gt; &gt; void f(B*);&gt; &gt; void f(void*);&gt; &gt; void test(D* x) &#123; f(x); &#125; // calls f(B*)&gt; &gt; 如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) . 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂. **注意：**前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。 1.4. 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 在通常情况下虚函数和递归函数即使声明为内联也不一定会被编译器内联。 包含循环或switch的函数内联往往得不偿失。 析构函数由于有隐含成员和基类虚构调用的关系，因此往往比想象的长，内联需谨慎。 1.5. #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 对应头文件 -&gt; C 库 -&gt; C++ 库 -&gt; 其他库的 .h -&gt; 本项目内的 .h. 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录). 例如, google-awesome-project/src/base/logging.h 应该按如下方式包含: 1#include "base/logging.h" 二、作用域 1.命名空间 鼓励在 .cc 文件内使用匿名命名空间或 static 声明。 使用具名的命名空间时, 其名称可基于项目名或相对路径。 禁止使用 using 指示（using-directive）。 禁止使用内联命名空间（inline namespace）。 遵守 命名空间命名 中的规则。 像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。 123456789101112131415161718192021// .h 文件namespace mynamespace &#123;// 所有声明都置于命名空间中// 注意不要使用缩进class MyClass &#123; public: ... void Foo();&#125;;&#125; // namespace mynamespace// .cc 文件namespace mynamespace &#123;// 函数定义都置于命名空间中void MyClass::Foo() &#123; ...&#125;&#125; // namespace mynamespace 不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件. 不要在头文件中使用 命名空间别名 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。 1234567891011121314// 在 .cc 中使用别名缩短常用的命名空间namespace baz = ::foo::bar::baz;// 在 .h 中使用别名缩短常用的命名空间namespace librarian &#123;namespace impl &#123; // 仅限内部使用namespace sidetable = ::pipeline_diagnostics::sidetable;&#125; // namespace implinline void my_inline_function() &#123; // 限制在一个函数中的命名空间别名 namespace baz = ::foo::bar::baz; ...&#125;&#125; // namespace librarian 2. 匿名命名空间和静态变量 在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。但是不要在 .h 文件中这么做。 3.非成员函数、静态成员函数和全局函数 使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数… 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间。 4.局部变量 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化. 有一例外： 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低. 1234567891011// 低效的实现for (int i = 0; i &lt; 1000000; ++i) &#123; Foo f; // 构造函数和析构函数分别调用 1000000 次! f.DoSomething(i);&#125;//高效的实现Foo f; // 构造函数和析构函数只调用 1 次for (int i = 0; i &lt; 1000000; ++i) &#123; f.DoSomething(i);&#125; 5. 静态和全局变量 禁止定义静态储存周期非POD变量(POD : Plain Old Data 原生数据类型) 禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。 TODO:这部分还看不太明白 三、类 1. 构造函数职责 不要在构造函数中调用虚函数。 不要在构造函数中尝试报告一个非致命错误。如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 Init() 方法或工厂函数. 2. 隐式类型转化 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字. 接受一个 std::initializer_list 作为参数的构造函数也应当省略 explicit, 以便支持拷贝初始化 (例如 MyType m = {1, 2};) . 拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换. 3. 可拷贝类型和可移动类型 除非你的类型需要才让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用. 123// MyClass is neither copyable nor movable.MyClass(const MyClass&amp;) = delete;MyClass&amp; operator=(const MyClass&amp;) = delete; 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义。 如果让类型可移动，那么就给出移动的两个操作 (移动构造函数和赋值操作) 的定义. 12345678class Foo &#123; public: Foo(Foo&amp;&amp; other) : field_(other.field) &#123;&#125; // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符. private: Field field_;&#125;; 4. 结构体VS类 仅当只有数据成员时使用 struct, 其它一概使用 class. 如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class. 5. 继承 使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承. 所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式. 6. 多重继承 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类 7. 接口 当一个类满足以下要求时, 称之为纯接口，这些类以 Interface 为后缀: 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数). 没有非静态数据成员. 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected. 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承. 8.运算符重载 只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, | 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道. 建议不要将不进行修改的二元运算符定义为成员函数. 不要引入用户定义字面量。 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的。 例如, 如果你重载了 &lt;, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数, &lt; 和 &gt; 不会同时返回 true. 9. 存取控制 将 所有 数据成员声明为 private, 除非是 static const 类型成员 10. 说明顺序 类定义应以 public: 开始, 后跟 protected:, 最后是 private:. 省略空部分. 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数,赋值运算符, 析构函数, 其它函数, 数据成员. 不要将大段的函数定义内联在类定义中. 只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 四、函数 1.参数顺序 函数的参数顺序为: 输入参数在先, 后跟输出参数. 输入参数通常是值参或 const 引用, 输出参数或输入/输出参数则一般为非 const 指针. 2.编写简短函数 果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割. 3. 引用参数 函数参数列表中, 所有引用参数都必须是 const 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap(). 这实际上是Google codestyle 的一个硬性约定 4. 函数重载 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数. 5. 缺省参数 只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. . (例如, 不要写像 void f(int n = counter++); 这样的代码.) 对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作 6. 函数返回类型后置语法 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法. 五、命名约定 1.变量 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_. 123456789101112131415161718string table_name; // 好 - 用下划线.string tablename; // 好 - 全小写.string tableName; // 差 - 混合大小写class TableInfo &#123; ... private: string table_name_; // 好 - 后加下划线. string tablename_; // 好. static Pool&lt;TableInfo&gt;* pool_; // 好.&#125;;struct UrlTableProperties &#123; string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool;&#125;; 2.常量命名 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:const int kDaysInAWeek = 7; 4.类型命名 类型名称采用驼峰式命名, 不包含下划线: MyExcitingClass, MyExcitingEnum. 5.宏命名 尽量不要使用宏 如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 6.枚举命名 枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME. 7. 函数命名 常规函数使用驼峰式命名。 例如： MyExcitingFunction(), MyExcitingMethod(), 取值和设值函数要与变量名匹配，并采用下划线连接 例如： ``my_exciting_member_variable(),set_my_exciting_member_variable()`. 8. 命名空间命名 命名空间以小写字母命名。 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突。 顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字。 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中。 9.文件命名 文件名要全部小写。 可以依照项目的约定包含下划线 (_) 或连字符 (-)。如果没有约定, 那么 “_” 更好。 C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾。 不要使用已经存在于 /usr/include 下的文件名。 通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好。 内联函数定义必须放在 .h 文件中。 复杂的内联函数的定义, 可以放在后缀名为 -inl.h 的头文件中。 六、注释 1.文件注释 在每一个文件开头加入版权公告. 文件注释描述了该文件的内容。 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释。除此之外的其他文件都需要文件注释. 2.类注释 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显. 12345678910// Iterates over the contents of a GargantuanTable.// Example:// GargantuanTableIterator* iter = table-&gt;NewIterator();// for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) &#123;// process(iter-&gt;key(), iter-&gt;value());// &#125;// delete iter;class GargantuanTableIterator &#123; ...&#125;; 3.函数注释 函数声明处的注释描述函数功能; 定义处的注释描述函数实现. 函数声明处注释的内容: 函数的输入输出. 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 函数是否分配了必须由调用者释放的空间. 参数是否可以为空指针. 是否存在函数使用上的性能隐患. 如果函数是可重入的, 其同步前提是什么? 函数定义处注释： 如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 如果函数参数的意义不明显，可采用以下方式： 如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破。 考虑更改函数的签名, 让某个 bool 类型的参数变为 enum 类型, 这样可以让这个参数的值表达其意义。 如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例。 用具名变量代替大段而复杂的嵌套表达式。 万不得已时, 才考虑在调用点用注释阐明参数的意义。 例： 12345ProductOptions options;options.set_precision_decimals(7);options.set_use_cache(ProductOptions::kDontUseCache);const DecimalNumber product = CalculateProduct(values, options, /*completion_callback=*/nullptr); 4. 变量注释 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明. 类数据成员 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途。 如果有变量的抽象属性(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释。 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释. 全局变量 和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因。 5.代码注释 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释. 代码前注释 巧妙或复杂的代码段前要加注释. 比如: 1234567// Divide result by two, taking into account that x// contains the carry from the add.for (int i = 0; i &lt; result-&gt;size(); i++) &#123; x = (x &lt;&lt; 8) + (*result)[i]; (*result)[i] = x &gt;&gt; 1; x &amp;= 1;&#125; 行注释 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如: 123456789101112DoSomething(); // Comment here so the comments line up.DoSomethingElseThatIsLonger(); // Two spaces between the code and the comment.&#123; // One space before comment when opening a new scope is allowed, // thus the comment lines up with the following comments and code. DoSomethingElse(); // Two spaces before line comments normally.&#125;std::vector&lt;string&gt; list&#123; // Comments in braced lists describe the next element... "First item", // .. and should be aligned appropriately."Second item"&#125;;DoSomething(); /* For trailing block comments, one space is fine. */ 6.TODO注释与弃用注释 TODO注释要使用全大写的字符串TODO, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一TODO` 相关的 issue。 您可以写上包含全大写的 DEPRECATED 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行。 在 DEPRECATED 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识。 七、格式 1. 一些普遍格式 每一行代码字符数不超过 80列。 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码。 只使用空格, 每次缩进 2 个空格。 变量初始化用 =, () 和 {} 均可。 预处理指令不要缩进, 从行首开始。 水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白。 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行. 2. 函数声明与定义 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行。 如果同一行文本太多, 放不下所有参数: 12345ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) &#123; DoSomething(); ...&#125; 甚至连第一个参数都放不下: 1234567ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) &#123; DoSomething(); // 2 space indent ...&#125; 注意以下几点: 使用好的参数名. 只有在参数未被使用或者其用途非常明显时, 才能省略参数名. 如果返回类型和函数名在一行放不下, 分行. 如果返回类型与函数声明或定义分行了, 不要缩进. 左圆括号总是和函数名在同一行. 函数名和左圆括号间永远没有空格. 圆括号与参数间没有空格. 左大括号总在最后一个参数同一行的末尾处, 不另起新行. 右大括号总是单独位于函数最后一行, 或者与左大括号同一行. 右圆括号和左大括号间总是有一个空格. 所有形参应尽可能对齐. 缺省缩进为 2 个空格. 换行后的参数保持 4 个空格的缩进. 不要在 return 表达式里加上非必须的圆括号。 3.Lambda表达式 Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开。 若用引用捕获, 在变量名和 &amp; 之间不留空格. 12int x = 0;auto add_to_x = [&amp;x](int n) &#123; x += n; &#125;; 4.函数调用 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里. 如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格： 12bool retval = DoSomething(averyveryveryverylongargument1, argument2, argument3); 参数也可以放在次行, 缩进四格： 12345678if (...) &#123; ... ... if (...) &#123; DoSomething( argument1, argument2, // 4 空格缩进 argument3, argument4); &#125; 如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数： 12int my_heuristic = scores[x] * y + bases[x];bool retval = DoSomething(my_heuristic, x, y, z); 或者放着不管, 补充上注释： 12bool retval = DoSomething(scores[x] * y + bases[x], // Score heuristic. x, y, z); 5.条件语句 1234567if (condition) &#123; // 圆括号里没有空格. ... // 2 空格缩进.&#125; else if (...) &#123; // else 与 if 的右括号同一行. ...&#125; else &#123; ...&#125; 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用: 12if (x == kFoo) return new Foo();if (x == kBar) return new Bar(); 如果语句有 else 分支则不允许: 123// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行if (x) DoThis();else DoThat(); 通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题,但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用: 123456789101112131415161718// 不可以这样子 - IF 有大括号 ELSE 却没有.if (condition) &#123; foo;&#125; else bar;// 不可以这样子 - ELSE 有大括号 IF 却没有.if (condition) foo;else &#123; bar;&#125;// 只要其中一个分支用了大括号, 两个分支都要用上大括号.if (condition) &#123; foo;&#125; else &#123; bar;&#125; 6.循环和switch语句 switch 语句 如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果 default 应该永远执行不到, 简单的加条 assert: 12345678910111213switch (var) &#123; case 0: &#123; // 2 空格缩进 ... // 4 空格缩进 break; &#125; case 1: &#123; ... break; &#125; default: &#123; assert(false); &#125;&#125; 循环语句 在单语句循环里, 括号可用可不用： 123456for (int i = 0; i &lt; kSomeNumber; ++i) printf("I love you\n");for (int i = 0; i &lt; kSomeNumber; ++i) &#123; printf("I take it back\n");&#125; 空循环体应使用 {} 或 continue, 而不是一个简单的分号. 12345while (condition) &#123; // 反复循环直到条件失效.&#125;for (int i = 0; i &lt; kSomeNumber; ++i) &#123;&#125; // 可 - 空循环体.while (condition) continue; // 可 - contunue 表明没有逻辑. 7.指针和引用表达式 句点或箭头前后不要有空格。 指针/地址操作符 (*, &amp;) 之后不能有空格. 8.类 声明 类声明 (下面的代码中缺少注释, 参考 类注释) 的基本格式如下: 12345678910111213141516171819class MyClass : public OtherClass &#123; public: // 注意有一个空格的缩进 MyClass(); // 标准的两空格缩进 explicit MyClass(int var); ~MyClass() &#123;&#125; void SomeFunction(); void SomeFunctionThatDoesNothing() &#123; &#125; void set_some_var(int var) &#123; some_var_ = var; &#125; int some_var() const &#123; return some_var_; &#125; private: bool SomeInternalFunction(); int some_var_; int some_other_var_;&#125;; 注意事项: 所有基类名应在 80 列限制下尽量与子类名放在同一行. 关键词 public:, protected:, private: 要缩进 1 个空格. 除第一个关键词 (一般是 public) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空. 这些关键词后不要保留空行. public 放在最前面, 然后是 protected, 最后是 private. 构造函数 下面两种初始值列表方式都可以接受: 123456789101112131415161718192021222324// 如果所有变量能放在同一行:MyClass::MyClass(int var) : some_var_(var) &#123; DoSomething();&#125;// 如果不能放在同一行,// 必须置于冒号后, 并缩进 4 个空格MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) &#123; DoSomething();&#125;// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行// 并逐行对齐MyClass::MyClass(int var) : some_var_(var), // 4 space indent some_other_var_(var + 1) &#123; // lined up DoSomething();&#125;// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行// 如果这样做合适的话MyClass::MyClass(int var) : some_var_(var) &#123;&#125; 9.命名空间 命名空间内容不缩进 10.水平留白 通用 123456789101112131415void f(bool b) &#123; // 左大括号前总是有空格. ...int i = 0; // 分号前不加空格.// 列表初始化中大括号内的空格是可选的.// 如果加了空格, 那么两边都要加上.int x[] = &#123; 0 &#125;;int x[] = &#123;0&#125;;// 继承与初始化列表中的冒号前后恒有空格.class Foo : public Bar &#123; public: // 对于单行函数的实现, 在大括号内加上空格 // 然后是函数实现 Foo(int b) : Bar(), baz_(b) &#123;&#125; // 大括号里面是空的话, 不加空格. void Reset() &#123; baz_ = 0; &#125; // 用括号把大括号与实现分开. 循环和条件语句 1234567891011121314if (b) &#123; // if 条件语句和循环语句关键字后均有空格.&#125; else &#123; // else 前后有空格.&#125;while (test) &#123;&#125; // 圆括号内部不紧邻空格.switch (i) &#123;for (int i = 0; i &lt; 5; ++i) &#123;switch ( i ) &#123; // 循环和条件语句的圆括号里可以与空格紧邻.if ( test ) &#123; // 圆括号, 但这很少见. 总之要一致.for ( int i = 0; i &lt; 5; ++i ) &#123;for ( ; i &lt; 5 ; ++i) &#123; // 循环里内 ; 后恒有空格, ; 前可以加个空格.switch (i) &#123; case 1: // switch case 的冒号前无空格. ... case 2: break; // 如果冒号有代码, 加个空格 操作符 1234567891011121314// 赋值运算符前后总是有空格.x = 0;// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.// 圆括号内部没有紧邻空格.v = w * x + y / z;v = w*x + y/z;v = w * (x + z);// 在参数和一元操作符之间不加空格.x = -5;++x;if (x &amp;&amp; !y) ... 模板和转化 123456// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.vector&lt;string&gt; x;y = static_cast&lt;char*&gt;(x);// 在类型与指针操作符之间留空格也可以, 但要保持一致.vector&lt;char *&gt; x;]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>C++ code style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tempelte_specialize]]></title>
    <url>%2F2019%2F03%2F25%2FC%2B%2B%2Ftempelte-specialize%2F</url>
    <content type="text"><![CDATA[函数模板具体化 C中允许使用模板来进行泛型编程，在C中模板原型如下所示： 12template &lt;typename T&gt;void swap(T &amp;a, T &amp;b) 模板原型不提供函数声明和定义，需要经过模板具体化过程生成相应声明和定义。 1. 隐式实例化 最初，编译器只能通过隐式实例化，通过对参数列表的类型推断，来使用模板生成对应函数定义，这也是我们最常用的方法；如可以像下面这样使用上面定义的函数模板： 1234short a, b;swap(a, b); // T 为 short 类型int c, d;swap(c, d); // T 为 int 类型 2. 显式实例化 现在C++还允许显式实例化(explicit instrantiation)。这意味着可以直接命令编译器创建特定的实例，其语法有两种形式： 123template void swap&lt;int&gt;(int, int); //显式实例化声明orswap&lt;int&gt;(a,b) //直接在程序中调用 显示实例化可以省去编译器的类型推断过程。 3.显式具体化 显式实例化和显式具体化区别在于：这些声明的意思是“不要使用swap()模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义。”这些原型必须有自己的函数定义。显式具体化声明在关键字template后包含&lt;&gt;，而显式实例化没有。 显式具体化有两种等价声明： 12template &lt;&gt; void swap&lt;int&gt; (int &amp;, int &amp;); //explicit specializationtemplate &lt;&gt; void swap (int &amp;, int &amp;); //根据参数列表的具体化 警告：试图在同一个文件中(或转换单元)中使用同一种类型的显式实例化和显式具体化 将出错。 常规模板，具体化模板，非模板函数的优先调用顺序： 非模板函数（普通函数）&gt; 具体化模板函数 &gt; 常规模板 类模板具体化 使用类模板可以通过类模板自动生成多个类，其模板定义如下： 1234template&lt;typename T1, typename T2&gt;class Point &#123; ...&#125; 1.隐式实例化 2.显式实例化 这两个部分的实例化语法，类模板和函数模板没有太大的区别。 3.显示具体化 类模板的显示具体化语法如下： 1234template&lt;&gt;class Point&lt;char *, char *&gt; &#123; ...&#125; 其中模板类方法的实现的具体化语法和函数模板有所区别，不需要带模板头template&lt;&gt;： 123void Point&lt;char*, char*&gt;::display() const &#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;", y="&lt;&lt;m_y&lt;&lt;endl;&#125; 4. 部分显式具体化 类模板还支持部分显式具体化，即只具体化部分模板参数类型： 12345678910template&lt;typename T2&gt;class Point&lt;char*, T2&gt; &#123; ...&#125;// 部分显式具体化还是需要加上模板头template&lt;typename T2&gt;void Point&lt;char*,T2&gt;::display() const &#123; cout&lt;&lt;"x="&lt;&lt;m_x&lt;&lt;" | y="&lt;&lt;m_y&lt;&lt;endl;&#125; 部分显式具体化只能用于类模板，不能用于函数模板。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类型转换符]]></title>
    <url>%2F2019%2F03%2F22%2FC%2B%2B%2FC-cast%2F</url>
    <content type="text"><![CDATA[四种类型转换运算符 dynamic_cast 用于多态类型的转换 static_cast 用于非多态类型的转换 const_cast 用于删除const ,volatile 和 __unaligned 属性 reinterpret_cast 用于位的简单重新解释 dynamic_cast 1dynamic_cast&lt;type&gt;(expression); 将expression转换为type类型,在运行期间转换，且会执行运行时检查，性能有相应消耗。 转换类型必须是一个指针、引用或者void，用于将基类的指针或引用安全地转换成派生类的指针或引用；* dynamic_cast在运行期间强制转换，运行时进行类型转换检查； 对指针进行转换，失败返回null，成功返回type类型的对象指针，对于引用的转换，失败抛出一个bad_cast ，成功返回type类型的引用； dynamic_cast不能用于内置类型的转换； 用于类的转换，基类中一定要有virtual定义的虚函数（保证多态性），不然会编译错误。 可以在整个类层次结构中移动指针，包括向上转换、向下转换 static_cast 1static_cast&lt;type&gt;(expression); 将expression转换为type类型，在编译过程中完成。有下几个应用场景： 用于非多态类型的转换 **内置类型转换：**转换过程中的精度损失由开发者负责，除非无法完成类型转化，否则编译器不会警告或报错。 把void*转化为目标类型指针 把任意类型转化为void 基类与派生类之间指针或引用的转换：由于不会进行类型检查，所以向上转换时安全的，向下转换是不安全的。 需要注意static_cast无法转换expression的const/volitale/__unaligned属性（会报编译时错误）。 const_cast 1const_cast&lt;type&gt;(expression); 可以提供一个移除expression的const/volitale/__unaligned属性的指针，但只限同类型间转换。 const_cast不能执行其他任何类型转换，只能用于同类型之间不同const/volitale属性的移除。否则会报编译时错误。 需要注意的是，const_cast通常对指针和引用进行转换，而无法直接移除内置类型的const/volitale属性，换言之，这种语法直接提供了一个具有写权限的指针或引用，可以通过间接访问的方式，修改常量。 reinterpret_cast 1reinterpret_cast&lt;type&gt;(expression); reinterpret_cast 允许将任何指针转换为任何其他指针类型。 也允许将任何整数类型转换为任何指针类型以及反向转换。 用于位的简单重新解释,本质作用是重新定义内存数据的解释方式，而不进行任何二进制转换. 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python传值与传引用]]></title>
    <url>%2F2019%2F03%2F22%2FPython%2Fpyrhon-valve-reference%2F</url>
    <content type="text"><![CDATA[可变对象与不可变对象 要明白python在参数传递和赋值过程中的行为，首先要明白python中的两类对象：可变对象与不可变对象。 **不可变对象，该对象所指向的内存中的值不能被改变。**对于这样的对象解释器会采取COW的策略，即当改变某个变量时候，会把把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。 可变对象，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。 Python 的参数传递与赋值 python的函数传参以及赋值是以一种“传对象引用”的方式完成的，但是由于对象类型不同，在修改时，会有不同的结果。 如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值**－－相当于通过“传引用”来传递对象。** 如果函数收到的是一个不可变对象（比如数值类型、字符或者元组）的引用，就不能直接修改原始对象**－－相当于通过“传值’来传递对象。** 另外需要注意的一点，不可变的属性是由外至内的，也即如果一个元组内有多个数组，则这些数组作为元组内的元素，也是不可变的。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>概念辨析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[destory和desallocate的区别]]></title>
    <url>%2F2019%2F03%2F21%2FC%2B%2B%2Fdestory-desallocate%2F</url>
    <content type="text"><![CDATA[deallocate： 123456template &lt;class T&gt; inline void _deallocate(T* buffer) &#123; ::operator delete(buffer); //为什么不用 delete [] ? ,operator delete 区别于 delete //operator delete 是一个底层操作符 &#125; destory: 12345template &lt;class T&gt; inline void _destory(T *ptr) &#123; ptr-&gt;~T(); &#125; destory负责调用类型的析构函数，销毁相应内存上的内容（但销毁后内存地址仍保留） deallocate负责释放内存（此时相应内存中的值在此之前应调用destory销毁，将内存地址返回给系统，代表这部分地址使用引用-1） 原文地址]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>知识辨析</tag>
        <tag>内存管理</tag>
        <tag>malloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc、calloc、realloc的区别]]></title>
    <url>%2F2019%2F03%2F21%2FC%2B%2B%2Fmalloc-calloc-realloc%2F</url>
    <content type="text"><![CDATA[函数原型： 1. malloc ​ void* malloc(unsigned size); ​ 在堆内存中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度。 2. calloc ​ void* calloc(size_t numElements, size_t sizeOfElement); ​ 与malloc相似，参数sizeOfElement为单位元素长度（例如：sizeof(int)），numElements为元素个数，即在内存中申请numElements * sizeOfElement字节大小的连续内存空间。 3. realloc ​ void* realloc(void* ptr, unsigned newsize); 使用realloc函数为ptr重新分配大小为size的一块内存空间。下面是这个函数的工作流程： ​ (1)，对ptr进行判断，如果ptr为NULL，则函数相当于malloc(new_size)，试着分配一块大小为new_size的内存，如果成功将地址返回，否则返回NULL。如果ptr不为NULL，则进入(2)。 ​ (2)，查看ptr是不是在堆中，如果不是的话会抛出realloc invalid pointer异常。如果ptr在堆中，则查看new_size大小，如果new_size大小为0，则相当于free(ptr)，将ptr指向的内存空间释放掉，返回NULL。如果new_size小于原大小，则ptr中的数据可能会丢失，只有new_size大小的数据会保存；如果size等于原大小，等于什么都没有做；如果size大于原大小，则查看ptr指向的位置还有没有足够的连续内存空间，如果有的话，分配更多的空间，返回的地址和ptr相同，如果没有的话，在更大的空间内查找，如果找到size大小的空间，将旧的内容拷贝到新的内存中，把旧的内存释放掉，则返回新地址，否则返回NULL。 区别 函数malloc不能初始化所分配的内存空间,而函数calloc能.如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据.也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题. 函数calloc() 会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零. 函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void类型.void表示未确定类型的指针.C,C++规定，void* 类型可以强制转换为任何其它类型的指针. realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失.realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反，realloc返回的指针很可能指向一个新的地址. realloc是从堆上分配内存的.当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动.]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>知识辨析</tag>
        <tag>内存管理</tag>
        <tag>malloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc 和new]]></title>
    <url>%2F2019%2F03%2F18%2FC%2B%2B%2Fmalocandnew%2F</url>
    <content type="text"><![CDATA[​ malloc() 与 free()相对应，new/new[]与delete/delete[]相对应，都应配对使用。 申请内存位置不同 new操作符可以从其他位置上分配内存，不一定局限于堆。 malloc函数从堆上动态分配内存。 返回类型安全性 new操作符返回的是对象类型的指针，类型匹配，故类型安全。 malloc函数分配成功返回void*，需要进行强制类型转换。 内存分配失败时的返回值 new分配失败会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 空间大小指定方式不同 new 会根据类型推断需要分配的内存的大小。malloc需要自行计算指出内存大小。 分配行为不同 new分配内存会有3个步骤： 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。 第三步：对象构造完成后，返回一个指向该对象的指针。 malloc 只会开辟空间。 对数组的处理 C++提供了new[]与delete[]来专门处理数组类型: A * ptr = new A[10];//分配10个A对象 使用new[]分配的内存必须使用delete[]进行释放：delete [] ptr; new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。 而malloc，它并不知道你在这块内存上要放的数组还是别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小： 是否可以被重载 opeartor new /operator delete可以被重载 而malloc/free并不允许重载。 能否直观地重新分配内存 使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。 new没有。 new与malloc是否可以相互调用 operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。 客户处理内存分配不足 在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数。 对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>内存管理 - malloc - 知识辨析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]数组类问题心得小结]]></title>
    <url>%2F2019%2F03%2F02%2FLeetCode%2Farray%2F</url>
    <content type="text"><![CDATA[常用方法与函数 在C++中，常用vector来作为数组容器。因此我们只讨论vector的相关方法与函数。 方法 作用 a.empty() 判断a是否为空，空则返回ture,不空则返回false a.erase(a.begin()+1,a.begin()+3) 删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+ 3（不包括它） a.size() 返回a中元素的个数 a.resize(10,2) 将a的现有元素个数调至10个，多则删，少则补，其值为2 a.swap(b) b为向量，将a中的元素和b中的元素进行整体性交换 a.insert(a.begin()+1,3,5) 在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5 a.insert(a.begin()+1,5) 在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4 C++算法库中提供了许多算法函数可以对vector进行操作，使用时要包含头文件#include&lt;algorithm&gt; 函数 作用 sort(a.begin(),a.end()) 对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列 reverse(a.begin(),a.end()); 对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1 copy(a.begin(),a.end(),b.begin()+1) 把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素 find(a.begin(),a.end(),10) 在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置 数组遍历 数组遍历一般有两种方式，（1）下标访问遍历，（2）使用迭代器遍历。 使用下标遍历 1234int a[6]=&#123;1,2,3,4,5,6&#125;;vector&lt;int&gt; b(a,a+4);for(int i=0;i&lt;=b.size()-1;i++) cout&lt;&lt;b[i]&lt;&lt;" "; 使用迭代器遍历 1234int a[6]=&#123;1,2,3,4,5,6&#125;;vector&lt;int&gt; b(a,a+4);for(vector&lt;int&gt;::iterator it=b.begin();it!=b.end();it++) cout&lt;&lt;*it&lt;&lt;" "; 常见题型及其常见思路 特定模式的搜索问题 ​ 这类题型会提供你一个特定的模式，要求你在数组中搜索，一般要求回答出现位置或者是否存在，主要考察数组的遍历。 暴力搜索 直接遍历即可，一般都要O（n^2)的复杂度，根据一些题目具体的不同可以做一些简化。 双指针法 使用两个指针来进行遍历，可以保留更多的信息易于判断，同时也减少判断。一般分为快指针+慢指针和头指针+尾指针两种模式。 转化法 如果题目中的模式组合比较有限，则可以从模式本身出发进行问题转化，将对数组的遍历转化为有限模式的统计，复杂度可降至O（n）甚至O（1）。 逐个修改问题 重复问题 交换与旋转问题]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】初级算法——数组]]></title>
    <url>%2F2019%2F02%2F28%2FLeetCode%2FLeetcode-array%2F</url>
    <content type="text"><![CDATA[[LeetCode]# 217 存在重复元素 给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 123&gt; 输入: [1,2,3,1]&gt; 输出: true&gt; 示例 2: 123&gt; 输入: [1,2,3,4]&gt; 输出: false&gt; 示例 3: 123&gt; 输入: [1,1,1,3,3,4,3,2,4,2]&gt; 输出: true&gt; 解答思路 暴力搜索： 最容易想到的方法，当然速度非常慢。 1234567891011121314151617class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return false; &#125; int len =nums.size(); for(int i =0; i&lt;len;i++)&#123; for(int j =i+1; j&lt;len;j++)&#123; if (nums[i] == nums[j])&#123; return true; &#125; &#125; &#125; return false; &#125;&#125;; 先排序 这个方法的好处在于：排序后重复元素就变成相邻元素了，之后的检索时间减少为O(1). 1234567891011class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); int len=nums.size(); for(int i=0;i&lt;len-1;i++)&#123; if(nums[i]==nums[i+1]) return 1; &#125; return 0; &#125;&#125;; [LeetCode] #122 买卖股票的最佳时机 Ⅱ 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 12345&gt; 输入: [7,1,5,3,6,4]&gt; 输出: 7&gt; 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&gt; 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。&gt; 示例 2: 123456&gt; 输入: [1,2,3,4,5]&gt; 输出: 4&gt; 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&gt; 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。&gt; 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。&gt; 示例 3: 1234&gt; 输入: [7,6,4,3,1]&gt; 输出: 0&gt; 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&gt; 解答思路 暴力法 遍历所有可能组合，时间复杂度高达O(n^n),很明显不是最好的方法。 12345678910111213141516171819202122int calculateMaxProfit(vector&lt;int&gt; &amp;prices, int start)&#123;//调用此calculateMaxProfit函数使用递归暴力法 if(start &gt;= prices.size()) return 0; int maxProfit = 0; for (int i = start; i &lt; prices.size() - 1; i++) &#123; int tempProfit = 0; for (int j = i + 1; j &lt; prices.size(); j++) &#123; if (prices[i] &lt; prices[j]) &#123; int profit = prices[j] - prices[i] + calculateMaxProfit(prices, j + 1); if(profit &gt; tempProfit) tempProfit = profit; &#125; &#125; if(tempProfit &gt; maxProfit) maxProfit = tempProfit; &#125; return maxProfit;&#125; 贪心法 事实上由于只能进行一次交易，且交易日连续，因此，利用贪心算法，局部最优解即全局最优解。 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty())&#123; return 0; &#125; int max =0; for (int i=0; i&lt;prices.size()-1; i++ )&#123; if(prices[i]&lt;prices[i+1])&#123; max += prices[i+1] - prices[i] ; &#125; &#125; return max; &#125;&#125;; [LeetCode]#189 旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 1234567&gt; 输入: [1,2,3,4,5,6,7] 和 k = 3&gt; 输出: [5,6,7,1,2,3,4]&gt; 解释:&gt; 向右旋转 1 步: [7,1,2,3,4,5,6]&gt; 向右旋转 2 步: [6,7,1,2,3,4,5]&gt; 向右旋转 3 步: [5,6,7,1,2,3,4]&gt; 示例 2: 123456&gt; 输入: [-1,-100,3,99] 和 k = 2&gt; 输出: [3,99,-1,-100]&gt; 解释: &gt; 向右旋转 1 步: [99,-1,-100,3]&gt; 向右旋转 2 步: [3,99,-1,-100]&gt; 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 解答思路 直接移动 将数组向右移动K次，每次移动一格，时间复杂度为O(Kn). 123456789101112131415161718class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.empty())&#123; return; &#125; int temp =0; int len = nums.size(); for(int i =0; i&lt;k;i++)&#123; temp = nums[len-1]; for(int j =0; j&lt;len-1;j++)&#123; nums[len-1 - j] = nums[len-2 - j]; &#125; nums[0] = temp; &#125; return; &#125;&#125;; 翻转法 这是一个很巧妙的方法： 利用数组的length - k 把数组 分为两半； 1.翻转左边和右边的数组； 2.翻转总数组。 时间复杂度是O(n),空间复杂度是O(1)。 12345678910111213141516171819202122class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n=nums.size(); k=k%n; if(k==0) return ; reverseString(nums,0,n-k-1); reverseString(nums,n-k,n-1); reverseString(nums,0,n-1); &#125; void reverseString(vector&lt;int&gt;&amp; nums,int from,int to) &#123; while(from&lt;to) &#123; int temp=nums[from]; nums[from++]=nums[to]; nums[to--]=temp; &#125; &#125;&#125;; [LeetCode]# 217 存在重复元素 给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 123&gt; 输入: [1,2,3,1]&gt; 输出: true&gt; 示例 2: 123&gt; 输入: [1,2,3,4]&gt; 输出: false&gt; 示例 3: 123&gt; 输入: [1,1,1,3,3,4,3,2,4,2]&gt; 输出: true&gt; 解答思路 暴力搜索 相较于最朴素的遍历略有改进，每次只搜索相应元素后面的元素，时间复杂度仍是O(n^2). 1234567891011121314151617class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return false; &#125; int len =nums.size(); for(int i =0; i&lt;len;i++)&#123; for(int j =i+1; j&lt;len;j++)&#123; if (nums[i] == nums[j])&#123; return true; &#125; &#125; &#125; return false; &#125;&#125;; 排序后检测 这种方法非常快。先对数组进行排序，这样相同的元素一定是挨着的，那么只需要对每一对挨着的元素进行判断即可。 123456789101112public boolean containsDuplicate(int[] nums) &#123; if (nums.length &lt;= 1) &#123; return false; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] == nums[i + 1]) &#123; return true; &#125; &#125; return false;&#125; [LeetCode]# 136 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 123&gt; 输入: [2,2,1]&gt; 输出: 1&gt; 示例 2: 123&gt; 输入: [4,1,2,1,2]&gt; 输出: 4&gt; 解题思路 排序后查找 排序后重复数字将会变成相邻元素，这时搜索时间复杂度就下降为O(n)。 12345678910111213141516171819202122class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return 0; &#125; if(nums.size()==1)&#123; return nums[0]; &#125; sort(nums.begin(),nums.end()); int k=0; for(int i=0;i&lt;nums.size();i++)&#123; if(nums[k] != nums[i])&#123; if((i-k)&lt;=1)&#123; return nums[k]; &#125; k = i; &#125; &#125; return nums[nums.size()-1]; &#125;&#125;; 异或操作 异或操作可以区分两个值是否相同。也就是当a b 两个值相同时，返回0；a b两个值不相等是，返回1。相同为真，不相同为假。 同时有：0 ^ a = a 1234567class Solution &#123; public int singleNumber(int[] nums) &#123; int result = nums[0]; for (int i = 1; i &lt; nums.length; i++) result ^= nums[i]; return result; &#125;&#125; [LeetCode]#283 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 123&gt; 输入: [0,1,0,3,12]&gt; 输出: [1,3,12,0,0]&gt; 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路 依次后移 12345678910111213141516171819202122class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return; &#125; for(vector&lt;int&gt;::iterator it = nums.begin(); it != nums.end(); it++)&#123; if((*it)==0)&#123; vector&lt;int&gt;::iterator zit = it; for(vector&lt;int&gt;::iterator jt = it+1 ; jt != nums.end(); jt++)&#123; if((*jt)!=0)&#123; int temp = *jt; *jt = 0; *zit = temp; zit = jt; &#125; &#125; &#125; &#125; &#125;&#125;; [LeetCode]#68 旋转图像 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 1234567891011121314&gt; 给定 matrix = &gt; [&gt; [1,2,3],&gt; [4,5,6],&gt; [7,8,9]&gt; ],&gt; &gt; 原地旋转输入矩阵，使其变为:&gt; [&gt; [7,4,1],&gt; [8,5,2],&gt; [9,6,3]&gt; ]&gt; 示例 2: 12345678910111213141516&gt; 给定 matrix =&gt; [&gt; [ 5, 1, 9,11],&gt; [ 2, 4, 8,10],&gt; [13, 3, 6, 7],&gt; [15,14,12,16]&gt; ], &gt; &gt; 原地旋转输入矩阵，使其变为:&gt; [&gt; [15,13, 2, 5],&gt; [14, 3, 4, 1],&gt; [12, 6, 8, 9],&gt; [16, 7,10,11]&gt; ]&gt; 解题思路 逐个移动 由于是旋转90°，因此将第一个元素旋转90°后再将下一个元素依次移动，这样4步即可停止回到原位。 123456789101112131415class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int n = matrix.size(); for (int i = 0; i &lt; n / 2; ++i) &#123; for (int j = i; j &lt; n - 1 - i; ++j) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[n - 1 - j][i]; matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]; matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]; matrix[j][n - 1 - i] = tmp; &#125; &#125; &#125;&#125;; 翻转1 首先以从对角线为轴翻转，然后再以x轴中线上下翻转即可得到结果。 12345678910111213141516class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int n = matrix.size(); for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = 0; j &lt; n - i; ++j) &#123; swap(matrix[i][j], matrix[n - 1- j][n - 1 - i]); &#125; &#125; for (int i = 0; i &lt; n / 2; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125; &#125; &#125;&#125;; 翻转2 先对原数组取其转置矩阵，然后把每行的数字翻转可得到结果。 123456789101112class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int n = matrix.size(); for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; swap(matrix[i][j], matrix[j][i]); &#125; reverse(matrix[i].begin(), matrix[i].end()); &#125; &#125;&#125;; [LeetCode]#36 有效的数独 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1: 1234567891011121314&gt; 输入:&gt; [&gt; [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],&gt; [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],&gt; [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],&gt; [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],&gt; [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],&gt; [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],&gt; [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],&gt; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],&gt; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]&gt; ]&gt; 输出: true&gt; 示例 2: 12345678910111213141516&gt; 输入:&gt; [&gt; [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],&gt; [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],&gt; [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],&gt; [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],&gt; [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],&gt; [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],&gt; [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],&gt; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],&gt; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]&gt; ]&gt; 输出: false&gt; 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。&gt; 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。&gt; 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 '.' 。 给定数独永远是 9x9 形式的。 解题思路 转换 将数组内的数的区域问题转换为多个坐标比较的问题。这个解决方案有更广泛的通用性，对其他尺寸的数独也适用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; map&lt;int,vector&lt;pair&lt;int,int&gt;&gt;&gt; num_map; if(board.empty())&#123; return false; &#125; //记录每个数及其坐标 for(int i = 0; i&lt; board.size(); i++)&#123; for(int j = 0; j&lt; board[i].size();j++)&#123; if(isdigit(board[i][j]) )&#123; pair&lt;int,int&gt; k = make_pair(i,j); int num = int(board[i][j]); if(num_map[num].empty())&#123; vector&lt;pair&lt;int,int&gt;&gt; list; list.push_back(k); num_map[num] = list; &#125; else&#123; num_map[num].push_back(k); &#125; &#125; &#125; &#125; //比较相同数字的坐标 for(map&lt;int,vector&lt;pair&lt;int,int&gt;&gt;&gt;::iterator iter=num_map.begin();iter!=num_map.end();iter++)&#123; int len = iter-&gt;second.size(); vector&lt;pair&lt;int,int&gt;&gt; array = iter-&gt;second; if(len&gt;1)&#123; for(int i = 0; i&lt;len;i++)&#123; for(int j = i+1; j&lt;len; j++)&#123; pair&lt;int,int&gt; item1 = array[i]; pair&lt;int,int&gt; item2 = array[j]; if(item1.first==item2.first || item1.second == item2.second || (item2.first/3 == item1.first/3 &amp;&amp; item2.second/3 == item1.second/3 ))&#123; cout &lt;&lt; item1.first &lt;&lt; item1.second&lt;&lt;endl; cout &lt;&lt; item2.first &lt;&lt; item2.second&lt;&lt;endl; return false; &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125;; 利用边界 由于数组都是9*9形式，且3 * 3方格固定,故采用数组下标边界即可区分。 12345678910111213141516171819public boolean isValidSudoku(char[][] board) &#123; for(int i = 0; i&lt;9; i++)&#123; HashSet&lt;Character&gt; rows = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; columns = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; cube = new HashSet&lt;Character&gt;(); for (int j = 0; j &lt; 9;j++)&#123; if(board[i][j]!='.' &amp;&amp; !rows.add(board[i][j])) return false; if(board[j][i]!='.' &amp;&amp; !columns.add(board[j][i])) return false; int RowIndex = 3*(i/3); int ColIndex = 3*(i%3); if(board[RowIndex + j/3][ColIndex + j%3]!='.' &amp;&amp; !cube.add(board[RowIndex + j/3][ColIndex + j%3])) return false; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash-变量与表达式]]></title>
    <url>%2F2019%2F01%2F26%2FShell_Bash%2Fbash-%E5%8F%98%E9%87%8F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Shell变量 变量定义 定义变量如下： 123variable=valuevariable='value'variable="value" 注意，变量名和=之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 使用变量 使用一个定义过的变量，只要在变量名前面加美元符号$即可，如： 12author=echo $authorecho $&#123;author&#125; 变量名外面的花括号{ }是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 1skill=&quot;Java&quot;echo &quot;I am good at $&#123;skill&#125;Script&quot; 如果不给 skill 变量加花括号，写成echo &quot;I am good at $skillScript&quot;，解释器就会把 $skillScript 当成一个变量. 单引号与双引号 以单引号' '包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。 以双引号&quot; &quot;包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。 特殊变量 变量 含义 $0 当前脚本的文件名。 $n（n≥1） 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。当被双引号&quot; &quot;包含时，$@ 与 $* 稍有不同。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 表达式与操作符 比较操作符 对应的操作 整数操作 字符串操作 相同 -eq = 不同 -ne != 大于 -gt &gt; 小于 -lt &lt; 大于或等于 -ge 小于或等于 -le 为空 -z 不为空 -n 字符串操作符 字符串替换 格式 解释 ${varname:-word} 返回默认值 ${varname:=word} 设置varname默认值 ${varname:?message} 为空时输出报错信息，message可以为空 ${varname:+word} 若为空，返回word，否则返回空 ${varname:offset:length} 返回从offset开始长度为length的子串。:length可省略，则子串一直到末尾。若offset小于0，offset为字符串末尾。若offset为@，length为从参数offset开始的参数数目 字符串匹配 格式 解释 ${variable#pattern} 删除开头的最短匹配部分 ${variable##pattern} 删除开头的最长匹配部分 ${variable%pattern} 删除结尾的最短匹配部分 ${variable%%pattern} 删除结尾的最长匹配部分 ${variable/pattern/string} 使用string替换匹配到的第一个字符串，pattern中可以以#或%开头 ${variable//pattern/string} 替换所有的字符串 获取字符串长度 命令 解释 ${#variable} 返回variable的长度 字符串截取 格式 说明 ${string: start :length} 从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。 ${string: start} 从 string 字符串的左边第 start 个字符开始截取，直到最后。 ${string: 0-start :length} 从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。 ${string: 0-start} 从 string 字符串的右边第 start 个字符开始截取，直到最后。 ${string#*chars} 从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。 ${string##*chars} 从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。 ${string%*chars} 从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。 ${string%%*chars} 从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符 文件操作符 运算符 含义（ 满足下面要求时返回 TRUE ） -e file 文件 file 已经存在 -f file 文件 file 是普通文件 -s file 文件 file 大小不为零 -d file 文件 file 是一个目录 -r file 文件 file 对当前用户可以读取 -w file 文件 file 对当前用户可以写入 -x file 文件 file 对当前用户可以执行 -g file 文件 file 的 GID 标志被设置 -u file 文件 file 的 UID 标志被设置 -O file 文件 file 是属于当前用户的 -G file 文件 file 的组 ID 和当前用户相同 file1 -nt file2 文件 file1 比 file2 更新 file1 -ot file2 文件 file1 比 file2 更老]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个性化Video_avatars]]></title>
    <url>%2F2019%2F01%2F15%2Fvideo-avatar%2F</url>
    <content type="text"><![CDATA[Video_avatars 这个项目来自马普所的一篇论文Video Based Reconstruction of 3D People Models ，日前，研究人员公布了他们的实现以及数据集。 Website:https://graphics.tu-bs.de/people-snapshot Github: https://github.com/thmoa/videoavatars 由于其文档比较匮乏，使用它的代码对自己的数据进行复现并不容易，经过几天努力，成功的完成了整个建模过程，故记录如下。相关代码以上传到了我的Github上。 原版本Demo 请先使用原版本Demo来验证环境部署成功:Video Avatars 数据准备 这个部分，我们将利用自摄的视频来进行的建模尝试，首先需要有一段如原论文视频相同的自摄视频，提供我的格式： 项目 格式 分辨率 1080*1080 帧率 24FPS 身体姿态 A形姿态旋转3圈 之后你可以使用 frame_get.py来获取到所有视频帧，以供下一步处理。 Step1:视频帧人体区域获取 这一步中，我们需要获得每一视频帧中，如下图形式的人体区域的二值图像： ![mask1](https://wpy-blog.oss-cn-shanghai.aliyuncs.com/mask1.jpg/wpy-blog) 在这一步中，我采用了百度AI开放平台的人像分割API来进行，你也可以采用其他AI开放平台的API，或者使用自己的语义分割实现。这一部分脚本在 human_mask.py 中可以找到。 ![origin](https://wpy-blog.oss-cn-shanghai.aliyuncs.com/origin1.jpg/wpy-blog) 受限于一些图像干扰，以及语义分割本身问题，获取到的mask图像往往还需要进一步处理： 可以看到，有一些无意义的区域，为了提升准确率，需要对mask进行取最大连通域的处理，之后可以再进行一次形态学膨胀操作消除空洞。这部分工作在mask_process.py中实现。 至此，我们就完成了mask的处理工作，之后，利用video_avatars/prpare_data/mask2hdf5.py即可将其转化为HDF5文件。 Step2：人体关节点标识 这一步需要将每一帧的关节点及其坐标转换为Jason格式，这里直接使用，Openpose来进行关节点识别。同样你也可以使用自己的实现或其他途径来进行关节点识别，只需符合COCO模型的关节点模式： Openpose具体安装和使用可以参考这里，我就不再详细介绍。 获取到所有的关节点的json文件后，使用video_avatars/prpare_data/2djoints2hdf5.py 可将其转化为HDF5文件。 Step3:相机相关参数 在video_avatars/prpare_data下，还有 create_camera.py来进行相机相关参数的序列化。 1234567parser.add_argument('out', type=str, help="Output file (.pkl)")parser.add_argument('width', type=int, help="Frame width in px")parser.add_argument('height', type=int, help="Frame height in px")parser.add_argument('-f', type=float, nargs='*', help="Focal length in px (2,)")parser.add_argument('-c', type=float, nargs='*', help="Principal point in px (2,)")parser.add_argument('-k', type=float, nargs='*', help="Distortion coefficients (5,)") 主要参数是分辨率以及像素焦距（Focal length in pixels ），由于我使用手机拍摄，其他参数难以获取，如果你能获取到准确数据可以将相应数据加入。 对于像素焦距（Focal length in pixels ），有以下公式可以计算： Focallengthinpixels=(imagewidthinpixels)∗(focallengthonearth)/(CCDwidthonearth)Focal length in pixels = (image width in pixels) * (focal length on earth) / (CCD width on earth) Focallengthinpixels=(imagewidthinpixels)∗(focallengthonearth)/(CCDwidthonearth) 构建运行 与之前的Demo相同，可以在这里找到具体命令。 最终效果 无衣着效果： 有衣着效果：]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>3D重建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hadoop】jar包及其替换]]></title>
    <url>%2F2019%2F01%2F14%2FHadoop-jars%2F</url>
    <content type="text"><![CDATA[获取Jar包 安装好Hadoop后，在hadoop的文件夹下可以看到share文件夹： 在share文件夹下，doc包含所有的文档内容，hadoop下就是我们可以获得到的Hadoop所有的源码以及测试jar包。 这里我们直接进入hadoop文件夹下，可以看到各个hadoop模块，根据需要可以找到相应jar包。 如果想要修改相应的hadoop模块，那么只需将相应的jar包替换为自己的实现即可。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo部署到云服务器上]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[一、准备 本地环境配置 本文本地环境为Windows10,确保你的计算机环境中装有 nodeJS、npm以及 Git,再进行接下来的步骤。 初始化 hexo 安装 打开命令行，执行以下命令： 1npm install hexo-cli -g 初始化 hexo 安装完成后，进入建立你的hexo目录,并完成初始化: 12345mkdir hexo-blogcd hexo-bloghexo init myblogcd myblognpm install 二、服务器配置 服务器系统为CentOS(7.1) 搭建远程Git库 登陆到远程服务器 安装git 123git --version // 如无，则安装yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y git 建立git用户并配置仓库 参考资料 123456789useradd gitpasswd git # 设置密码su git # 这步很重要，不切换用户后面会很麻烦cd /home/git/mkdir -p hexo/blog # 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git # 创建一个裸露的仓库cd blog.git/hooksvi post-receive # 创建hook钩子函数，输入内容如下（原理可以参考上面的链接） 12#!/bin/shgit --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f 添加完毕后修改钩子的权限，执行如下命令 123chmod +x post-receiveexit # 退出到 root 登录chown -R git:git /home/git/repos/blog.git # 添加权限 测试git仓库是否建立成功 找到另外的空白文件夹，执行如下命令 1git clone git@server_ip:/home/git/repos/blog.git 如果成功的完成克隆，则仓库可用。 设置ssh公钥访问 为了免去每次部署博客时输入密码的麻烦，我们需要采用ssh公钥来登陆服务器. 进入C://User//你的用户名/.ssh,查看是否已有密钥对:id_rsa和id_rsa.pub 若没有已建好密钥对参考此文。 将id_rsa.pub通过WinScp等工具上传至远端服务器/home/git/.ssh目录下，并改名为authorized_keys. 建议登陆git用户上传，上传后确保公钥拥有者为git 搭建nginx服务器 安装nginx 1yum install -y ngix 验证安装是否成功： 1ngix #启动后通过浏览器连接到server_IP 检查是否可以看到测试页面 配置nginx 12345678nginx -s stop # 先停止nginxcd /etc/nginxmv nginx.conf nginx.conf.copycp nginx.conf.defult nginx.conf #移除测试配置，导入默认配置vim nginx.conf#修改 root 解析路径 /home/git/hexo/blog# 同时将 user 改为 root 如下图，不然nginx无法访问nginx -s reload 三、本地部署配置 回到本地hexo目录，修配置文件_config.yml 以上，所有工作顺利完成！ 使用以下命令部署你的hexo: 12hexo g #生成静态文件hexo d #部署到远端 四、总结 整个过程经历了许多波折，大多是ssh公钥相关的配置问题，不过最终，还是解决了问题，可以开心地写博客了！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
</search>
